<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason Xu&#39;s Studio.</title>
  
  <subtitle>He that can have patience, can have what he will.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-16T18:39:09.858Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jason Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECMAScript 6th归纳总结</title>
    <link href="http://yoursite.com/2017/02/02/ECMAScript-6th%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/02/ECMAScript-6th归纳总结/</id>
    <published>2017-02-02T13:37:17.000Z</published>
    <updated>2018-02-16T18:39:09.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6th"><a href="#ECMAScript-6th" class="headerlink" title="ECMAScript 6th"></a>ECMAScript 6th</h1><hr>]]></content>
    
    <summary type="html">
    
      ECMAScript 6th归纳总结
    
    </summary>
    
      <category term="ECMAScript" scheme="http://yoursite.com/categories/ECMAScript/"/>
    
    
      <category term="ECMA-262 6th" scheme="http://yoursite.com/tags/ECMA-262-6th/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 5th归纳总结</title>
    <link href="http://yoursite.com/2014/05/21/ECMAScript-5th%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2014/05/21/ECMAScript-5th归纳总结/</id>
    <published>2014-05-21T13:13:07.000Z</published>
    <updated>2018-02-16T18:36:36.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-5th"><a href="#ECMAScript-5th" class="headerlink" title="ECMAScript 5th"></a>ECMAScript 5th</h1><hr>]]></content>
    
    <summary type="html">
    
      ECMAScript 5th归纳总结
    
    </summary>
    
      <category term="ECMAScript" scheme="http://yoursite.com/categories/ECMAScript/"/>
    
    
      <category term="ECMA-262 5th" scheme="http://yoursite.com/tags/ECMA-262-5th/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记 五</title>
    <link href="http://yoursite.com/2014/03/08/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/"/>
    <id>http://yoursite.com/2014/03/08/JavaScript学习笔记05/</id>
    <published>2014-03-08T09:55:31.000Z</published>
    <updated>2018-02-16T18:27:40.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记-·-五"><a href="#JavaScript学习笔记-·-五" class="headerlink" title="JavaScript学习笔记 · 五"></a>JavaScript学习笔记 · 五</h1><hr>]]></content>
    
    <summary type="html">
    
      JavaScript学习笔记
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记 四</title>
    <link href="http://yoursite.com/2014/03/07/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
    <id>http://yoursite.com/2014/03/07/JavaScript学习笔记04/</id>
    <published>2014-03-07T14:21:11.000Z</published>
    <updated>2018-02-16T18:26:33.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记-·-四"><a href="#JavaScript学习笔记-·-四" class="headerlink" title="JavaScript学习笔记 · 四"></a>JavaScript学习笔记 · 四</h1><hr>]]></content>
    
    <summary type="html">
    
      JavaScript学习笔记
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记 三</title>
    <link href="http://yoursite.com/2014/03/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <id>http://yoursite.com/2014/03/05/JavaScript学习笔记03/</id>
    <published>2014-03-05T05:32:11.000Z</published>
    <updated>2018-02-16T18:25:23.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记-·-三"><a href="#JavaScript学习笔记-·-三" class="headerlink" title="JavaScript学习笔记 · 三"></a>JavaScript学习笔记 · 三</h1><hr>]]></content>
    
    <summary type="html">
    
      JavaScript学习笔记
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记 二</title>
    <link href="http://yoursite.com/2014/03/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>http://yoursite.com/2014/03/03/JavaScript学习笔记02/</id>
    <published>2014-03-03T03:38:51.000Z</published>
    <updated>2018-02-16T18:24:03.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记-·-二"><a href="#JavaScript学习笔记-·-二" class="headerlink" title="JavaScript学习笔记 · 二"></a>JavaScript学习笔记 · 二</h1><hr>]]></content>
    
    <summary type="html">
    
      JavaScript学习笔记
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记 一</title>
    <link href="http://yoursite.com/2014/03/02/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://yoursite.com/2014/03/02/JavaScript学习笔记01/</id>
    <published>2014-03-02T04:18:31.000Z</published>
    <updated>2018-02-16T18:29:11.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记-·-一"><a href="#JavaScript学习笔记-·-一" class="headerlink" title="JavaScript学习笔记 · 一"></a>JavaScript学习笔记 · 一</h1><hr><p>㈠</p><p>㈡JavaScript——ECMAScript的一种实现和扩展；</p><p>⑴JavaScript简介：</p><p>⒈JavaScript起初的目的：JavaScript最早出现的目的是为了做一些简单的表单验证；<br>  JavaScript现在的意义：JS现在的应用几乎无处不在→ PC Web 页面特效；<br>                          → 移动端（web App, App）；<br>                          → AJAX（异步和服务器交互）；<br>                          → 后端开发（NodeJS）；<br>                          → 游戏、vr、智能家电。</p><p>⒉JavaScript是编程语言：<br>    HTML&amp;CSS——标记语言与表：<br>        HTML和CSS不是编程语言，因为它们不具有逻辑描述能力；<br>    JavaScript——编程语言：<br>        JavaScript是一门解释型的、弱类型的、基于原型的编程语言。</p><p>  ①编程语言：具有逻辑描述能力的语言就是编程语言，其中逻辑包括数学逻辑和业务逻辑；<br>  ②源代码和机器码：源代码是编程人员为实现某种需求，按照既定的语法规则编写的代码文件，是人类可以看懂的代码，如.cppC++语言文件、.jsJS脚本文件、汇编语言文件；<br>            机器码是一个纯二进制的指令集合，是机器唯一可以看懂并执行的代码，若想要让计算机能够识别我们所写的源代码，需要一个翻译官把我们的源代码翻译成二进制再交给计算机执行——JavaScript的解释程序（引擎）、C++的编译程序、汇编语言的汇编程序。<br>  ③解释型编程语言：在运行时，将源代码翻译一句，执行一句；优点：开发效率高，缺点：性能相对较低，适合用来开发一些应用级别的软件。<br>    编译型编程语言：在运行前，先一次性将源码全部翻译成目标文件（如C++是可执行文件，如Java是中间文件），然后每次执行时不再使用源文件；优点：程序性能较高，缺点：开发效率低，适合开发一些系统级别的软件。<br>  ④弱类型编程语言：用变量引用数据时，变量不用事先声明其要引用数据的数据类型，在执行时变量所代表的数据类型由实际值来决定（动态的类型），比较灵活；<br>    强类型编程语言：用变量引用数据时，变量必须事先声明其要引用数据的数据类型，在使用时该变量只能引用指定类型的数据（静态的类型），不能匹配（且不能隐式转换）则会报错，也就是说变量类型在代码定义时决定的。</p><p>⒊JavaScript历史：<br>  ①JavaScript问世——Netscape(网景，即现在的Mozilla)公司研发出NetScape Navigator1.0浏览器，并发现需要一种可以嵌入网页的脚本语言，用来控制浏览器行为，主要是提供表单验证功能；<br>              Netscape雇佣了程序员Brendan Eich（布兰登·艾奇）开发这种网页脚本语言——JavaScript 1.0（名字借Java的光，两者没有直接关系），而Navigator 2.0浏览器正式内置了JavaScript脚本语言。<br>  ②JavaScript竞争——微软模仿 JavaScript 开发了一种相近的语言，为避免商标冲突，取名为 JScript，首先内置于IE 3.0；<br>              而在微软之后，共有3种不同的 JavaScript 版本同时存在：NetscapeNavigator 3.0中的 JavaScript、IE中的 JScript 以及CEnvi中的 ScriptEase；<br>              然而，并没有一个标准来统一其语法或特性。<br>  ③JavaScript标准化——ECMA（European Computer Manufacturers Association欧洲计算机制造商协会）发布 ECMA-262 标准文件，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript（为避免商标冲突和体现中立性）。</p><p>⒋JavaScript组成：<br>  ①ECMAScript 标准：JavaScript的核心，包括文法、词法、语法、算法等规定；<br>  ②DOM（Document Object Model）文档对象模型：W3C组织推荐的处理可扩展标记语言（如HTML,SVG or XML）的标准编程接口。DOM将Web页面连接到脚本或编程语言（通常指JavaScript语言），向其提供操作网页中的<br>                          HTML和CSS的API工具（即各种JS对象及其属性、方法）。但将HTML、SVG或XML文档建模为对象不是JavaScript语言的一部分，尽管通常会使用 JavaScript 来访问 DOM，<br>                          但它也可以被其他语言使用；<br>  ③BOM（Browser Object Model）浏览器对象模型：该模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构——简单地说就是一组操作浏览器的API工具，由多个对象组成，其中代表浏览器窗口的window对<br>                          象是BOM的顶层对象，而其他对象都是该对象的子对象；由于BOM没有相关标准，所以除了实际上已经默认的一些标准外，每个浏览器都有其自己对BOM的实现方式。<br>  ★注意：Web API——Web 提供了各种各样的 API 来完成各种的任务，这些API可以用JavaScript来访问，令你可以做很多事儿，小到对任意window或者element做小幅调整，大到使用诸如WebGL和Web Audio的API来<br>      生成复杂的图形和音效。<br>      Web API分类：    文档对象模型（Document Object Model）；<br>            设备 API（Device APIs）；<br>            通信 API（Communication APIs）；<br>            数据管理 APIs（Data management APIs）；<br>            特权 API（Privileged APIs）；<br>            已认证应用程序的私有 API（Certified APIs）。<br>  ☆注意：API——全称Application Programming Interface应用程序编程接口——通常是一些预先定义的函数或是封装好的对象（将函数功能封装到对象内部作为其属性和方法来使用），目的是提供应用程序与开发<br>      人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>⒌JavaScript书写方式：<br>  ①行内JavaScript：将JS代码作为字符串属性值写在对应HTML标签元素的特定事件属性中去，当该事件发生时，浏览器会将这段代码串作为相应的事件处理程序去执行（其执行环境类似于将代码放入function(event){with(document){with(this.form||{}){with(this){code}}}}，然后将此匿名函数传给其接口对象.on事件属性去调用）；<br>        <button onclick="alert(1);">按钮</button><br>  ②内嵌JavaScript：将JS代码写在script标签对之内，并将该script标签放在HTML页面的head标签或body标签之内，甚至可以放在整个html标签之外|下（可以避免标签元素未加载，但不推荐）；<br>        <script type="text/javascript">        //type属性目的是告诉浏览器，该标签中是js代码，type属性在html5版本中可以省略<br>            JavaScript Code;<br>        </script><br>  ③外联JavaScript：将JS代码写在外部的JavaScript源文件（.js后缀）中去，并通过script标签引入相应的HTML页面中，设置script标签的src属性值为要引入的JS文件的路径；<br>        <script src=".js文件的路径"></script><br>  ★注意：外联JS中的script标签对内书写的任何JS代码都不会起作用，因为加载时会把外部代码覆盖到该script标签对之内！！！<br>  ★注意：JavaScript中代码并没有优先级顺序，但是需要注意不同代码执行的先后顺序，修改相同的变量或对象及其属性时会造成覆盖！！！<br>  ★注意：JavaScript代码的加载时机遵循其在HTML页面中的插入位置，即script标签或行内JS所在的元素标签在整个页面中的位置，特别注意两点影响<br>      ·当某段JavaScript代码加载时，此HTML页面中在其引入标签后面的所有其他标签并未加载（包括其他JS代码的引入标签），此时对应的HTML元素并未生成，查找这些元素的接口对象时会返回null值；<br>      ·后加载的JS代码，会覆盖前面的某些设置，同样也可以使用之前的某些设置。</p><p>⒍JavaScript常用输出：<br>  [window.]alert(message);            //弹出警告对话框，将参数message显示为其中的文本提示信息，如果实参是对象则转换为字符串显示<br>  [window.]prompt(message, default);        //弹出输入对话框，将参数message显示为其中的文本提示信息，default为输入框显示的默认值，并将用户输入数据作为★字符串★返回<br>  [window.]confirm(message);            //弹出选择对话框，将参数message显示为其中的文本提示信息，选择确定返回ture，取消返回false<br>  [window.]console.log(obj1[,obj2,…,objN]);    //控制台输出多个数据，number和boolean类型则字体显示为蓝色，string类型显示深灰色，undefined和null显示浅灰色，对象则显示为链接（非实时跟踪）<br>       console.log(msg[,subs1,…,subsN]);     //控制台格式化输出，msg是带有 格式占位符 的格式字符串，%s字符串，%d整数，%i整数，%f浮点数，%o对象的链接，%cCSS格式字符串<br>  [window.]console.dir(obj);            //控制台输出一个对象，检查其所有属性和属性值（实时跟踪）<br>  [window.]document.write(markup);        //输出内容到HTML页面的文档流，作为HTML代码去解析<br>                        //★注意：在关闭(即已加载了所有标签)的文档上调用 document.write时，会自动调用 document.open 再次打开该文档，而这将清除文档原内容——即事件驱动程序中不要使用；<br>                        //★注意：在页面加载过程中调用 document.write，并不会清空原内容，但要注意JScode加载位置影响其在页面中的输入位置；</p><p>⒎JavaScript调试：发现代码BUG——语法错误和逻辑错误（算数逻辑和业务逻辑）。</p><p>⒏计算机组成部分：<br>  软件：<br>    应用软件；<br>    系统软件┳操作系统；<br>        ┗数据库管理系统。<br>  硬件：<br>    计算器┓中央处理器；<br>    控制器┛CPU；<br>    存储器┳寄存器；<br>          ┣高速缓冲存储器；<br>          ┣主存/内存；<br>          ┗辅存/外存；<br>    输入设备；<br>    输出设备；<br>    总线。</p><p>⑵ECMAScirpt标准语法：</p><p>Ⅰ词法结构：编程语言的词法结构是一套基础性规则，是语法的基础；</p><p>⒈字符集：JavaScript程序使用Unicode字符集编写，Unicode是ASCII和Latin-1的超集，并支持地球上几乎所有在用的语言；</p><pre><code>①JavaScript语言中区分大小写，即关键字、变量名、函数名和所有的标识符都必须采取一致的大小写形式。★注意：HTML中并不区分大小写（除XHTML区分外），所以要注意，在使用浏览器提供的HTML标签或其属性的★API接口★——即获取相应的JavaScript对象或其中的属性时不要混淆，HTML中的标签和属性名可以使用大写    或小写——两者是等价的，而JavaScript中对应的标签名和属性名则必须是小写——如getElementsByTagName(&quot;div&quot;)，element.style中的标签名和属性名不能用大写；    另外，CSS样式的属性名中是可能含有‘-’的，然而JavaScript中标识符是不能含有‘-’的，所以CSS属性在JavaScript的行内样式接口对象style中对应的属性名采取驼峰命名法代替‘-’分割符。②JavaScript会忽略程序中标识（token）之间的空格符号——空格的意义仅在于词法分析阶段，即使解释器能够从源码中区别出ECMAScript语言的token，而在之后的语法解析过程中是不关心空格的；  JavaScript多数情况下同样会忽略换行符（其同样不是token），但其仍然会被传递并参与语法解析过程，以作为自动添加分号的判断依据之一；  Unicode格式控制字符（用\uXXXX表示）可以用在JavaScript的注释、字符串直接量和正则表达式直接量中，但不能用在标识符中（除了零宽连接符\u200D和零宽非连接符\uFEFF是可以出现在标识符中的，但不能为首字符）；③Unicode转义序列：为避免某些计算机系统无法显示Unicode字符全集，JavaScript定义了一种特殊序列，可以使用6个ASCII字符来代表任意16位Unicode内码——转义序列\uXXXX，X表示一位16进制数。</code></pre><p>⒉JavaScript注释：<br>  单行注释：<br>    //注释内容直至行结束符<br>  多行注释：<br>    /<em><br>    注释内容中不能嵌套另一个多行注释，否则会出现匹配错误    </em>/</p><p>⒊直接量[字面量]：在程序中直接使用的数据值；</p><p>⒋变量：在程序中通过绑定的标识符，即变量名，来使用的数据值；<br>★★★★注意：一定要区分JavaScript中的变量与C语言或C++中的变量概念，两者虽然同样是引用数据的一种方式，但却有着巨大的差异；<br>    首先，C语言和C++都是强类型语言，声明变量时需要指定其类型。在程序运行至该变量的定义语句时，会给该变量分配一个固定的内存空间，大小根据其声明的类型。之后，该变量名就与固定的内存地址<br>          始终绑定在一起，而该变量名所代表的值就是其绑定的内存空间所存放的数据。给一个变量赋值，就是向该变量所对应的内存空间上去覆盖原有数据。另外，引用类型是不重新分配内存空间的，因<br>          为引用就是给原有的一个变量起个别名，即该变量同时拥有了两个名字，都绑定到同一个固定内存空间上去，且引用一旦绑定就不能改变。<br>    其次，C语言和C++中初始化和赋值本质上是两种操作（对与引用类型和类类型变量而言尤其明显），初始化发生在创建变量、给变量分配内存空间时，如果变量是类类型则会调用其某一个构造函数，如果<br>          变量是引用类型则必须在定义时初始化，将其绑定到某个同类型的变量上去，并且初始化只发生一次，没有显式或隐式初始化的变量其值不确定；而赋值操作则发生在变量被创建之后，如果变量是<br>          类类型则调用的是对应的赋值运算符，如果变量是引用类型则赋值改变的是其初始化时绑定的变量。<br>    同比，JavaScript是弱类型语言，声明变量时不需要指定其类型。在程序执行某段JavaScript Code前，会先为其建立一个执行环境（即执行上下文，其包括词法环境、变量环境以及this绑定），然后进行<br>          声明绑定初始化——在变量环境中为该代码里的所有声明变量和声明函数各建立一条命名绑定，变量名（若是新建的）绑定undefined，函数名绑定一个函数对象。这个过程就是所谓的“预解析”和<br>          声明提升。所以JS代码中本质上只有变量的赋值操作，而赋值操作就是改变该变量名所绑定的数据值，即每个变量名并没有绑定一个固定不变的内存空间，而是随时可以被修改绑定到其他数据之上的。<br>          JS中的变量很像C++中的引用，只是区别在于它并不固定绑到某一数据。<br>    另外，JavaScript中如果某变量绑定的是基本类型，则将其赋值给另一个变量时会创建一个相同的新值，实际就是将自身绑定的值复制到另一个对应的环境记录绑定中去，但如果绑定的是引用类型的对象，<br>          则赋值操作不会创建新的对象，只是让另一个变量绑定到相同的对象上，可以理解为环境记录中的绑定里放的是对象的地址，而不是对象本身。<br>    ①变量声明：JavaScript是弱类型（动态类型）语言，声明变量时统一用 var 关键字，而不需要声明其类型，其类型由实际运行时所绑定的值来决定；<br>        var identifier[, identifier[, identifier[…]]];<br>        var identifier[ = expression[, identifier[ = expression[…]]]];<br>    ②标识符和保留字：<br>    ③变量使用：<br>        变量赋值——；<br>        变量引用——；<br>    ④变量作用域：<br>    ⑤“预解析”和声明提升：</p><p>⒌类型和值：每个类型的数据值都有两中表现形式——字面量形式和变量形式；<br>    ■基本类型：<br>    ①数字类型：<br>    ②字符串类型：<br>    ③布尔类型：<br>    ④Undefined类型：<br>    ⑤Null类型：<br>    ■引用类型：<br>    ①对象类型：自定义对象和除了Object对象之外的其他内置对象都是由对应的构造函数对象所创建；<br>        按ECMA标准分类：<br>        原生对象：<br>            内置对象：宿主环境提供，但由ECMA规范定义；<br>            自定义对象：用户定义，符合ECMA标准规范；<br>        宿主对象：<br>            window等：宿主环境提供，但不受ECMA规范定义；<br>        按构造方式分类：<br>        普通对象（由Object或相应构造函数构造，无法调用）；<br>        函数对象（由Function构造，可以直接调用）；<br>        构造函数对象（由Function构造，可以直接调用，也可用new调用来构造其他对象）；<br>        内置对象：<br>    ★基本类型和引用类型的区别：<br>        基本类型数据（栈区）存储其原始值绑定到变量，引用类型数据（堆区）存储其地址绑定到变量；<br>        基本类型的值无法修改——对基本类型的变量赋值时只是将变量名绑定到新的值，引用类型的值可以被修改——对引用类型的变量可以修改其属性和属性值；<br>        基本类型的数据赋值时复制其原始值给新的变量，引用类型的数据赋值时传递其存储的地址给新的变量；</p><p>Ⅱ表达式和运算符</p><p>Ⅲ语句</p><p>①<br>②<br>③<br>④<br>⑤<br>⑥跳转语句：<br>    ·throw 语句：抛出异常——使用 throw 语句，所谓异常(exception)是当发生了某种异常情况或错误时产生的一个 信号，而抛出异常就是用该 信号 通知发生了错误或异常状况；<br>              捕获异常——使用 try/catch/finally 语句，是指处理这个被抛出的异常信号，即采取必要的手段从异常中恢复；<br>              当异常被抛出时，JavaScript解释器会 立即停止 当前正在执行的逻辑，并跳转至 就近 的异常处理程序，即 catch 块中；<br>        throw expression;<br>    ·try/catch/finally 语句：<br>        try {<br>            //放入测试代码，当发生错误时：<br>            //直接由throw语句抛出异常，终止当前代码块的执行<br>            //或者由调用的方法间接抛出异常，再在此处进行捕获处理<br>        } catch(error) {<br>            //放入异常处理程序，当且仅当try语句块中抛出了异常时，才会执行这里的代码<br>            //可以通过局部变量 error 来获得对 Error对象 或者抛出的 其他值 的引用，而且catch子句中的标识符具有 块级作用域<br>            //可以基于某种原因处理这个异常，亦可以忽略这个异常<br>            //还可以通过 throw 语句在此重新抛出异常<br>        } finally {<br>            //不管try语句块是否抛出了异常，这里的逻辑总是会执行<br>            //终止一个try语句块的方式：<br>            //1)正常终止，执行完try语句块的最后一条语句<br>            //2)通过break、continue或return语句终止<br>            //3)抛出一个异常，异常被catch从句捕获<br>            //4)抛出一个异常，异常未被捕获，继续向上传播<br>        }</p><p>Ⅳ对象</p><p>Ⅴ数组</p><p>Ⅵ函数<br>①字符串函数：本质上是 String 包装对象的方法；<br>  □索引位获取：<br>    str[index];<br>    str.charAt(index);<br>  □字符串拼接：<br>    str1.concat(str2);<br>    str1 + str2;<br>  □字符串截取：<br>    str.slice(begin, end);<br>    str.substring(begin, end);<br>    str.substr(begin, num);<br>  □大小写切换：<br>    str.toUpperCase();<br>    str.toLowerCase();<br>  □替换：<br>    str.replace(str1|regexp, str2);<br>    str.split(str1).join(str2);<br>  □查找：<br>    str.indexOf(substr);<br>    str.lastIndexOf(substr);<br>  □翻转：<br>    str.split(‘’).reverse().join(‘’);<br>  □去白：<br>    str.trim();            //等价于str.replace(/^\s+|\s+$/g, ‘’)</p><p>⒍闭包：</p><p>Ⅶ类和模块</p><p>Ⅷ正则表达式：是一个描述字符模式的对象，JavaScript用RegExp类型对象来表示正则表达式，其中String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能；</p><p>⒈正则表达式的定义：</p><p>■直接量[字面量]语法：    /…/;                //不能为空，否则被解析为单行注释<br>■RegExp构造函数语法：    new RegExp(“…”);        //参数字符串中的字符内容会被整体作为正则表达式斜杠内的直接量内容，即”/a/“对应正则表达式——/\/a\//<br>            new RegExp(/…/);</p><pre><code>①直接量字符：    直接量字符            匹配        字母和数字            自身(a-z,A-Z,0-9)        \o                NUL字符(\u0000)        \t                制表符(\u0009)        \n                换行符(\u000A)        \v                垂直制表符(\u000B)        \f                换页符(\u000C)        \r                回车符(\u000D)        \xnn                由十六进制数nn指定的拉丁字符        \uxxxx                由十六进制数xxxx指定的Unicode字符        \cX                控制字符^X        \[特殊标点^$.*+?=!:|\/()[]{}]    （必须加\）对应字符标点★注意：虽然其中某些符号只有在正则表达式的特定上下文中才具有某种特殊含义，而在其他上下文中则被当成直接量处理，然而通行规则——必须使用前缀\来使用这些字符的直接量进行匹配！！！        [\]其他标点            （可以不加\）自身★注意：如果不记得哪些标点符号需要反斜线转义，可以在每个标点符号前都加上反斜线！！！    字母和数字则尽量不要用反斜线对其转义，以免其具有特殊含义！    反斜线本身的直接量必须使用反斜线进行转义！②字符类[简单类]：将直接量字符单独放进方括号内就组成了字符类，它可以匹配它所包含的任意字符；  ^ 符号[负向类]：用来定义否定字符类，它匹配所有不包含在方括号内的字符，定义否定字符类时，将一个‘^’符号作为左方括号内的第一个字符即可；  - 符号[范围类]：字符类可以使用连字符来表示字符范围；  预定义字符类：由于某些字符类非常常用，因此在JavaScript的正则表达式语法中，使用了这些特殊字符的转义字符来表示它们；        字符类                匹配        [...]                方括号内的任意字符        [^...]                不在方括号内的任意字符        .                除换行符和其他Unicode行终止符之外的任意字符        \w                任何ASCII字符组成的单词，等价于[a-zA-Z0-9]        \W                任何不是ASCII字符组成的单词，等价与[^a-zA-Z0-9]        \s                任何Unicode空白符        \S                任何非Unicode空白符的字符        \d                任何ASCII数字，等价于[0-9]        \D                除了ASCII数字之外的任何字符，等价于[^0-9]        [\b]                退格直接量（特例）③重复[量词]：        贪婪的重复：尽可能多地匹配，而且允许后续的正则表达式继续匹配；        字符                含义        {n,m}                匹配前一项至少n次，但不能超过m次        {n,}                匹配前一项n次或者更多次        {n}                匹配前一项n次        ?                匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}        +                匹配前一项1次或多次，等价于{1,}        *                匹配前一项0次或多次，等价于{0,}    非贪婪的重复：当★能★匹配连续的多项时，其会尽可能少的匹配，只需在待匹配字符的量词后跟随一个问号即可；    ★★★★注意：正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置，尽管其会尽可能少地匹配，此时也不会考虑它的子串中更短的匹配；        {n,m}?                        {n,}?                        {n}?                        ??                        +?                        *?                ④选择、分组和引用：⑤指定匹配的位置：⑥修饰符：</code></pre><p>⒉正则表达式的方法：</p><p>★注意：当正则表达式没有 “g” 标志时（非全局匹配），每次查找匹配都会从字符串的开头开始；<br>    当正则表达式使用 “g” 标志时（是全局匹配），其工作方式会发生一些改变：<br>        每一次查找匹配后都会重新记录或更新其 lastIndex 属性；<br>        下一次查找匹配将从正则表达式的该 lastIndex 属性指定的位置处开始（即使改变了被查找的字符串也依然会从该位置开始）；<br>        若某一次查找匹配没有找到匹配项（即test()返回false，exec()返回null时），则会重新将 lastIndex 属性置 0——下一次将从开头位置开始查找匹配；<br>    所以，全局匹配时可以多次执行 exec() 方法来查找同一个字符串中的所有成功匹配的子串！！！<br>    但同时要注意——其调用test()方法时也会使用并更新 lastIndex 属性！！！</p><p>◆正则对象.test()方法——检查是否匹配：用来查看正则表达式与指定的字符串str间是否匹配，匹配返回 true ，否则返回 false ；<br>    RegExp.prototype.test(str);<br>◇String对象.search()方法——检查是否匹配：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1；<br>    String.prototype.search(regexp);</p><p>◆正则对象.replace()方法——替换匹配子串：如果匹配模式是RegExp对象时，这个方法在 String.prototype.replace() 的内部调用；<br>    RegExp.prototype<a href="">@@replace</a>;<br>    regexp<a href="str, newSubStr|function">Symbol.replace</a>;<br>◇String对象.replace()方法——替换匹配子串：用一个替换值去替换掉原字符串中一些或所有匹配特定模式的子串，并返回得到的新字符串；<br>                          替换值可以是一个字符串（可以使用特殊变量名）或者一个每次匹配都要调用的函数（用该函数的返回值作为替换值）；<br>                        匹配模式可以是一个字符串（非正则的完整字串，只替换一次）或者一个正则表达式（非全局替换一次，全局替换所有）；<br>  ★注意：该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串！！！<br>    String.prototype.replace(regexp|substr, newSubStr|function);</p><p>◆正则对象.exec()方法——提取匹配子串：在一个指定字符串str中执行一个搜索匹配，并返回一个结果数组或null；<br>  ★注意：返回的数组中只存储了本次找到的匹配项相关信息——包括[0]匹配的全部字符串，[1],…[n]表达式括号中分组所捕获的字符串，index匹配到的字符位于原始字串中基于0的索引位置及input原始字符串；<br>  ★注意：如果本次匹配成功，exec() 方法返回一个结果数组，并更新正则表达式对象的 lastIndex 属性（即下次匹配的起点），返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面；<br>        如果本次匹配失败，exec() 方法返回 null，同时 lastIndex 属性被重置；<br>    RegExp.prototype.exec(str);<br>◇String对象.match()方法——提取匹配子串：使用一个正则表达式对象regexp来进行搜索匹配，并返回一个包含了整个匹配结果以及任何括号捕获的匹配结果的 Array，如果没有匹配项，则返回 null；<br>  ★注意：非全局匹配时（regexp不含g），会返回和 RegExp.exec() 相同的结果；<br>      而全局匹配时（regexp包含g），返回的数组中则只有每个被匹配或捕获到的子串，而没有其他信息；<br>    String.prototype.match(regexp);</p><p>⒊</p><p>Ⅸ ECMAScript 6新增语法：</p><p>   ■变量声明：<br>    ◆let 命令：ES6新增了 let 命令，用来声明变量。它的用法类似于var ，但是所声明的变量，只在 let 命令所在的代码块内有效；<br>        ·for 循环的计数器，就很合适使用 let 命令来声明：<br>            var a = [];<br>            for (var i = 0; i &lt; 10; i++) {<br>                a[i] = function () {<br>                    console.log(i);<br>                };<br>            }<br>            a<a href="">6</a>; // 10<br>        ★注意：若变量 i 是 var 声明的，则其在全局范围内都有效，所以全局只有一个变量 i ！！！<br>            （每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的 function 在运行时，会通过闭包读到这同一个变量 i ，导致最后输出的是最后一轮的 i 的值，也就是10）</p><pre><code>        var a = [];        for (let i = 0; i &lt; 10; i++) {            a[i] = function () {                console.log(i);            };        }        a[6](); // ★居然是6★    ★注意：若变量 i 是 let 声明的，则当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是6！！！        （JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算）    ·for 循环还有一个特别之处，就是 整个循环语句 是一个 块级父作用域 ，而 循环体内部 还有一个单独的 子作用域：        for (let i = 0; i &lt; 3; i++) {            let i = &apos;abc&apos;;            console.log(i);            //因为子作用域内找到了变量 i ，所以输出的是子作用域内的 i = &apos;abc&apos;        }        // abc        // abc        // abc    ·不存在变量提升：        ·var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；        ·let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错；    ·暂时性死区：        ·只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的 同名变量 影响；        ·ES6明确规定，如果区块中存在 let 和 const 命令，则这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量，就会报错；        ·所以在代码块内，使用 let 命令声明变量之前，该变量都是不可用的——这在语法上，称为“暂时性死区”（temporal deadzone，简称 TDZ）；    ·不允许重复声明：        ·let 不允许在相同作用域内，重复声明同一个变量；◆const 命令：const 声明一个只读的常量，一旦声明，常量的值就不能改变；    ·const 声明的变量不得改变值，这意味着， const 一旦声明变量，就必须立即初始化，不能留到以后赋值；    ·const 的作用域与 let 命令相同——只在声明所在的块级作用域内有效；    ·const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；    ·const 声明的常量，也与 let 一样不可重复声明；★注意：const 的本质——const 实际上保证的并不是变量的 值 不得改动，而是变量指向的那个 内存地址 不得改动，所以：        对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量；        对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针， const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了；    因此，将一个对象声明为常量必须非常小心，虽然不能被赋值为另一个对象或者原始值，但是其内的属性值是可以被改变的！！！☆注：如果真的想将对象冻结，应该使用 Object.freeze() 方法：    const foo = Object.freeze({});    // 常规模式时，下面一行不起作用；    // 严格模式时，该行会报错    foo.prop = 123;       除了将对象本身冻结，对象的属性也应该冻结：    var constantize = (obj) =&gt; {        Object.freeze(obj);        Object.keys(obj).forEach( (key, i) =&gt; {            if ( typeof obj[key] === &apos;object&apos; ) {                constantize( obj[key] );            }        });    };</code></pre><p>   ■解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）；<br>    ·数组的解构赋值：<br>        var [a, b, c] = [1, 2, 3];<br>        let [foo, [[bar], baz]] = [1, [[2], 3]];            //模式匹配——只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>        let [head, …tail] = [1, 2, 3, 4];                //rest参数 tail = [2, 3, 4]<br>        let [x, y, …z] = [‘a’];                    //y = undefined，rest参数 z = []<br>        //如果解构不成功，变量的值就等于 undefined<br>        //其中一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组——这种情况下，解构依然可以成功(跳过多余项)<br>    ·对象的解构赋值：<br>        var {x, y, z} = {y:2, x:1, z:3};                //数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p><pre><code>    let obj = { first: &apos;hello&apos;, last: &apos;world&apos; };            //如果 变量名 与 属性名 不一致，必须写成 “属性名:变量名”的形式来进行相应变量的赋值    let { first: f, last: l } = obj;                //对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而不是前者 f=&apos;hello&apos;,l=&apos;world&apos;    let obj = {                            //和数组一样，解构也可以用于嵌套结构的对象        p: [            &apos;Hello&apos;,            { y: &apos;World&apos; }        ]    };    let { p: [x, { y }] } = obj;                    //这时 p 是模式，不是变量，因此不会被赋值 x=&quot;Hello&quot;,y=&quot;World&quot;·字符串的解构赋值：字符串也可以解构赋值，此时，字符串被转换成了一个类似数组的包装对象，其方式类似于 数组 的解构赋值；    const [a, b, c, d, e] = &apos;hello&apos;;                //a=&quot;h&quot;,b=&quot;e&quot;,c=&quot;l&quot;,d=&quot;l&quot;,e=&quot;o&quot;    let {length : len} = &apos;hello&apos;;                    //这个类似数组的对象还有一个 length 属性，因此还可以对这个属性解构赋值 len=5·数值和布尔值的解构赋值：解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，该方式类似于 对象 的解构赋值；    let {toString: s} = 123;                    //s === Number.prototype.toString    let {toString: s} = true;                    //s === Boolean.prototype.toString★注意：解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象——由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错！！！·函数参数解构赋值：    function([m, n, p] [= [1, 2, 3]]){...}                //数组方式    function({m, n, p} [= {...}]){...}                //对象方式·圆括号问题：ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号；    ·不得使用圆括号的情况：        变量声明语句中，不能带有圆括号；        函数参数中，模式不能带有圆括号；        赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中；    ·可以使用圆括号的情况：        赋值语句的非模式部分，可以使用圆括号；★注意：建议只要有可能，就不要在模式中放置圆括号！！！·解构赋值允许指定默认值：    let [x, y = &apos;b&apos;] = [&apos;a&apos;];                     // x = &apos;a&apos;, y = &apos;b&apos;    let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];                // x = &apos;a&apos;, y = &apos;b&apos;    function move({x = 0, y = 0} = {}) {                //指定了不存在 x 对应的解构值、不存在 y 对应解构值以及不存在 解构对象 三种情况下的默认值        return [x, y];    }    function move({x, y} = {x:0, y:0}) {                //只是指定了不存在 解构对象 一种情况下的默认值，若有实参对象时 y:0 就不起作用        return [x, y];    }★注意：ES6 内部使用严格相等运算符&quot;===&quot;，判断一个位置是否有值——如果一个数组成员不严格等于 undefined ，默认值是不会生效的，否则即生效！！！</code></pre><p>   ■字符串扩展：<br>    ◆includes(),startsWith(),endsWith()方法：<br>        string.includes(‘…’, start);                        //返回布尔值，表示是否找到了参数字符串，从 start 开始<br>        string.startsWith(‘…’, start);                    //返回布尔值，表示参数字符串是否在源字符串的头部，从 start 开始<br>        string.endsWith(‘…’, end);                        //返回布尔值，表示参数字符串是否在源字符串的尾部，到 end 为止<br>    ◆repeat()方法：<br>        string.repeat(n)                            //该方法返回一个新字符串，表示将原字符串重复 n 次<br>    ◆模版字符串<code>：模板字符串(template string)是增强版的字符串，用反引号</code>标识，既可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量和表达式；<br>    ·与’’或””混用：<br>        <code>In JavaScript &#39;\n&#39; is a &quot;line-feed&quot;.</code><br>    ·允许换行符：<br>        var str = <code>this is a        test string</code>;<br>    ·解析变量或表达式：<br>        var str = <code>...${expression}...</code>;</p><p>   ■数组的扩展：<br>    ◆Array.from() 方法：用于将两类对象转为真正的数组——类似数组的对象(array-like object)和可遍历(iterable)的对象(包括ES6新增的数据结构Set和Map)；<br>        ·如果参数是一个真正的数组， Array.from 会返回一个一模一样的新数组；<br>        ·只要是部署了 Iterator 接口的数据结构， Array.from 都能将其转为数组；<br>        ★扩展运算符 “…” 也可以将某些数据结构转为数组：<br>            var args = […arguments];                    //调用遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换<br>        ·Array.from 方法则还支持类似数组的对象——所谓类似数组的对象，本质特征只有一点，即必须有 length 属性；<br>            Array.from({ length: 3 });                    //任何有length 属性的对象，都可以通过Array.from 方法转为数组，而此时扩展运算符就无法转换<br>            //[ undefined, undefined, undefined]<br>        ·常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象；<br>        ·Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组；<br>            Array.from(arrayLike, x =&gt; x <em> x);<br>            // 等同于<br>            Array.from(arrayLike).map(x =&gt; x </em> x);</p><pre><code>◆Array.of() 方法：用于将一组值，转换为数组；    ·添加该方法主要为了弥补数组构造函数 Array() 的不足——参数个数的不同，会导致该方法的行为有差异：        Array();                            // []，没有参数 时，创建一个 空数组        Array(3);                            // [, , ,]，一个参数 时，指定数组的 长度        Array(3, 11, 8);                        // [3, 11, 8]，两个及以上的参数时，返回由参数组成的新数组    ·Array.of 基本上可以用来替代 Array() 或 new Array() ；    ·不存在由于参数不同而导致的重载；    ·Array.of 的行为非常统一：        ·总是返回参数值组成的数组；        ·如果没有参数，就返回一个空数组；◆copyWithin() 方法：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖该位置的原有成员），然后返回当前数组。    ·target（必需）：从该位置开始替换数据；    ·start（可选）：从该位置开始读取数据，默认为 0 ；如果为 负值，表示倒数；    ·end（可选）：到该位置前停止读取数据，默认等于 数组长度；如果为 负值，表示倒数；    ·这三个参数都应该是数值，如果不是，会自动转为数值；    Array.prototype.copyWithin(target, start = 0, end = this.length);    //复制范围是 [start, end)★注意：使用这个方法时会修改当前数组！！！◆find() 和 findIndex() 方法：    ·find() 方法，用于找出第一个符合条件的数组成员；        ·参数是一个回调函数，所有数组成员会依次执行该回调函数，直到找出第一个返回值为true 的成员，然后返回该成员；        ·如果没有符合条件的成员，则返回 undefined；        ·find() 方法的回调函数最多可以接受三个参数，依次为当前的值、当前的位置和原数组；    ·findIndex() 方法，与 find() 用法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1；    ·这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象；    ·这两个方法都可以发现 NaN ，弥补了数组的 indexOf() 方法的不足；◆fill() 方法：使用给定值填充一个数组；    ·fill() 方法用于空数组的初始化非常方便，数组中已有的元素会被全部抹去；    ·fill() 方法还可以接受 第二个 和 第三个 参数，用于指定填充的起始位置和结束位置；    Array.prototype.fill(value, start = 0, end = this.length);        //填充范围是 [start, end)◆entries(), keys() 和 values() 方法：用于遍历数组；    ·都返回一个遍历器对象，可以用 for...of 循环进行遍历；    ·keys() 是对键名的遍历；    ·values() 是对键值的遍历；    ·entries() 是对键值对的遍历；◆includes() 方法：返回一个布尔值，表示某个数组是否包含给定的 值，与字符串的 includes() 方法类似；    ·第二个参数表示搜索的起始位置，默认为 0 ；    ·如果第二个参数为 负数，则表示倒数的位置，但如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始；◆数组的空位：数组的空位 指数组的某一个位置没有任何值；★注意：空位不是 undefined ，一个位置的值等于 undefined ，那它依然是“有值的”；而空位是“没有”任何值的， in 运算符可以说明这一点！！！    ·ES5 对空位的处理很不一致，大多数情况下会忽略空位：        ·forEach() , filter() , every() 和 some() 都会跳过空位；        ·map() 会跳过空位，但会保留这个值；        ·join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串；    ·ES6 则是明确将空位转为 undefined ；</code></pre><p>   ■函数的扩展：<br>    ◆函数参数的默认值：<br>    ◆rest参数：<br>    ◆扩展运算符…：<br>    ◆严格模式：<br>        ‘use strict’;<br>    ◆name 属性：<br>    ◆箭头函数：<br>    ◆绑定this：<br>    ◆尾调用优化：<br>    ◆函数参数的尾逗号；</p><p>   ■对象的扩展：</p><p>   ■Promise 对象：<br>    ◆Promise 的含义：<br>        ·Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大；<br>        ·Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象；<br>        ·Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从语法上说，Promise 是一个对象，从它可以获取异步操作的消息；<br>        ·Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理；<br>    ◆Promise 的特点：<br>        ·对象的状态不受外界影响——Promise 对象代表一个异步操作，有三种状态： Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败），而只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态；<br>          这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变！！！<br>        ·一旦状态改变，就不会再变，任何时候都可以得到这个结果—— Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected ；<br>          只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果；这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的；<br>    ◆基本用法：<br>        ·ES6规定，Promise 对象是一个构造函数，用来生成 Promise 实例；<br>          ·Promise 构造函数接受一个 函数 作为参数，该函数的两个参数分别是 resolve 和 reject ——它们是两个函数，由 JavaScript 引擎提供，不用自己部署；<br>          ·resolve 函数的作用是——将 Promise 对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved ），应在异步操作成功时调用，并将异步操作的结果 data，作为参数传递出去；<br>          ·reject 函数的作用是——将 Promise 对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected ），应在异步操作失败时调用，并将异步操作报出的错误 error，作为参数传递出去；<br>            var promise = new Promise(function(resolve, reject) {<br>                // … some async code<br>                if (/<em> 异步操作成功 </em>/){<br>                    resolve(value);<br>                } else {<br>                    reject(error);<br>                }<br>            });<br>        ·Promise 实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数；<br>          ·then 方法可以接受两个回调函数作为参数，第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Reject 时调用；<br>          ·其中，第二个函数是可选的，不一定要提供；<br>          ·这两个函数都分别接受 Promise 对象成功或失败时传出的值作为参数；<br>            promise.then(function(data) {<br>                // success<br>            }, function(error) {<br>                // failure<br>            });<br>    ◆Promise对象API：<br>        ·Promise.prototype.then()：为 Promise 实例添加 状态改变 时的回调函数；<br>            Promise.prototype.then((data)=&gt;{…}, (error)=&gt;{…});<br>            ·then 方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数；<br>            ·then 方法返回的是一个新的 Promise 实例（★注意：并不是原来那个 Promise 实例！！！）——因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法；<br>            ·then 方法的返回值若不是 Promise 实例对象时，会被自动转换为 Promise 对象；<br>        ·Promise.prototype.catch()：catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数；<br>            Promise.prototype.catch((error)=&gt;{…});<br>            ·Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止——也就是说，错误总是会被下一个最近的 catch 语句捕获；<br>            ·跟传统的 try/catch 代码块不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的 错误 不会传递到外层代码——即不会有任何反应；<br>            ·因此，建议总是使用 catch 方法来代替在 then 方法中设置第二个参数，因为这种写法可以捕获前面 then 方法执行中的错误！！！<br>        ·Promise.all()：Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例；<br>            var p = Promise.all([p1, p2, p3]);<br>            ·Promise.all 方法接受一个数组作为参数， p1 、p2 、p3 都是 Promise 对象的实例，如果不是，就会先调用下面的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理；<br>            ·只有 p1 、p2 、p3 的状态都变成 fulfilled， p 的状态才会变成 fulfilled ，此时 p1 、p2 、p3 的返回值组成一个数组，传递给 p 的回调函数；<br>            ·只要 p1 、p2 、p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数；<br>        ·Promise.race()：Promise.race 方法同样是将多个 Promise 实例，包装成一个新的Promise实例；<br>            var p = Promise.race([p1, p2, p3]);<br>            ·只要 p1 、p2 、p3 之中有一个实例率先改变状态， p 的状态就跟着改变，而那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数；<br>            ·Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用下面的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理；<br>        ·Promise.resolve()：将现有对象转为 Promise 对象；<br>            ·参数是一个 Promise 实例，那么Promise.resolve 将不做任何修改、原封不动地返回这个实例；<br>            ·参数是一个 thenable 对象（thenable对象指的是具有 then(resolve,reject) 方法的对象），Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法；<br>            ·参数不是具有 then 方法的对象，或根本就不是对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 Resolved，所以回调函数会立即执行，而且 Promise.resolve 方法的参数会同时传给该回调函数；<br>            ·不带有任何参数，直接返回一个 Resolved 状态的 Promise 对象；<br>        ·Promise.reject()：Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected；</p><pre><code>◆两个有用的附加方法：    ·done()：Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局），因此可以提供一个 done 方法于回调链的尾端，保证抛出任何可能出现的错误；    ·finally()：finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，而它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行；</code></pre><p>   ■Generator 函数：<br>    ◆基本概念：<br>        ·Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同；<br>          ·从语法上，首先可以理解成——Generator 函数是一个状态机，封装了多个内部状态 yield；<br>          ·执行 Generator 函数会返回一个遍历器对象，也就是说——Generator 函数除了状态机，还是一个遍历器对象生成函数；<br>          ·返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态；<br>        ·形式上，Generator 函数是一个普通函数，但是有两个特征：一，function 关键字与函数名之间有一个星号；二，函数体内部使用 yield 语句来定义不同的内部状态；<br>        ·Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号；不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（遍历器对象Iterator Object）；<br>        ·然后，必须调用遍历器对象的 next 方法，使得指针移向下一个状态，也就是说——每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 语句（或 return 语句）为止。换言之，Generator函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行；<br>    ◆yield语句：由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数——yield 语句就是暂停标志；<br>        ·next方法的运行逻辑：<br>          ·遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值，以 false 为 done 属性的值，表示遍历还没有结束；<br>          ·下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句；<br>          ·如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值，以 true 为 done 属性的值，表示遍历已经结束；<br>          ·如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined；<br>    ◆next方法的参数：<br>        ·yield 句本身没有返回值，或者说总是返回 undefined，而 next 方法可以带一个参数，该参数就会被当作★上一个★ yield 语句的返回值；<br>    ◆for…of循环：for(… of func){…} 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法；<br>        function <em>foo() {<br>            yield 1;<br>            yield 2;<br>            yield 3;<br>            yield 4;<br>            yield 5;<br>            return 6;<br>        }<br>        for (let v of foo()) {<br>            console.log(v);                        // 1 2 3 4 5<br>        }<br>    ★注意：一旦 next 方法的返回对象的 done 属性为 true 时， for…of 循环就会立即中止，并且不包含对该返回对象执行循环体语句，所以上面代码的 return 语句返回的 6，不包括在for…of 循环之中——即每次先判断 done 的状态再决定是否执行 循环体！！！<br>    ◆Generator 对象API：<br>        ·Generator.prototype.throw()：Generator函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在Generator函数体内捕获；<br>        ·Generator.prototype.return()：Generator函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历Generator函数；<br>    ◆yield</em> 语句：<br>        ·如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的；<br>        ·此时就需要用到 yield* 语句，用来在一个 Generator 函数里面执行另一个 Generator 函数；</p><p>   ■Async 函数：ES2017 标准引入了 async 函数，使得异步操作变得更加方便，async 函数其实就是 Generator 函数的语法糖——async 函数将 Generator 函数的星号(*)替换成 async ，将 yield 替换成 await ，仅此而已；<br>    ◆优点：<br>        ·内置执行器——Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器，也就是说，async 函数的执行，与普通函数一模一样，只要一行；<br>        ·更好的语义——async 和 await ，比起 星号 和 yield ，语义更清楚了；<br>        ·更广的适用性——co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和 原始类型的值；<br>        ·返回值是 Promise——async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了，用 then 方法指定下一步的操作；<br>    ◆用法：<br>        async function getStockPriceByName(name) {                        //async 表示当前声明的函数是一个异步函数，它的执行过程与普通函数有些许区别<br>            var symbol = await getStockSymbol(name);                    //每当函数体执行到一个 await 语句时，都会暂停下来，等待 await 后面方法返回的 Promise 对象从“未完成”状态转换为“成功”或“失败”，然后返回获得的 data 或 error 对象<br>            var stockPrice = await getStockPrice(symbol);                    //从函数体内部看来，程序“好像”是依次向下同步执行的，但其实在函数外部看来，这依然是一个 异步 过程——当函数第一次 await 暂停时，就开始继续执行当前函数后面的程序了，直到被再次“唤醒”去执行剩余的函数体语句<br>            return stockPrice;                                //async 函数默认会返回一个 Promise 对象（自动转换）<br>        }<br>        getStockPriceByName(‘goog’).then(function (result) {<br>            console.log(result);<br>        });</p><p>⑶DOM（Document Object Model）文档对象模型：</p><pre><code>DOM将整个HTML文档以及其中的标签元素、文本内容、HTML标签属性和标签样式等抽象并封装为一个个的对象或其中属性、方法，而这些对象或属性实质上就是文档中相关内容的编程接口，在JS程序中可以通过对这些</code></pre><p>对象的访问操作来控制HTML文档中的相应内容。<br>    在DOM中所有的对象被组织在一个树形结构中，其中的每个对象被称为一个节点，而整个树形结构以一个document对象为根节点，它是对整个HTML文档的抽象封装。所有的节点通过彼此之间的属性相互连接，构成<br>了整个树形结构。</p><p>Ⅰ获取元素节点：<br>①document.getElementById(“id”);        //通过id名获取单个元素，只有document有该方法，返回找到的第一个具有该id的元素节点，没有则返回null<br>②document.getElementsByTagName(“tagName”);    //通过标签名★小写★获取若干个元素，不仅document有该方法（能获取文档中所有该类型的元素），并返回一个包含这些元素的伪数组，若没有则返回空的伪数组<br>  element.getElementsByTagName(“tagName”);    //元素节点也具有该方法（能获取该节点下所有该类型的子元素）<br>③document.getElementsByName(“name”);        //通过name属性获取若干个元素，只有document有该方法，返回一个包含这些元素的伪数组，若没有则返回空的伪数组<br>④document.getElementsByClassName(“class”);    //通过类名获取若干个元素，不仅document有该方法（能获取文档中所有该class名的元素），返回一个包含这些元素的伪数组，若没有则返回空的伪数组<br>  element.getElementsByClassName(“class”);    //元素节点也具有该方法（能获取该节点下所有该class名的子元素）<br>⑤document.querySelector(“selector”);        //通过选择器获取单个元素（类似于CSS选择器——标签、类、ID、交集、并集、属性…）<br>⑥document.querySelectorAll(“selector”);    //通过选择器获取若干个元素，返回伪数组…</p><p>HTML文档的结构：如何获取html/head/title/body标签对象？<br>    ★除了通过document对象或元素对象中的节点查询方法从树形结构中获取这些节点外，还可以直接通过document对象的相应属性来快速获取这些节点对象；<br>    document.documentElement    html标签的对象；<br>    document.head;            head标签的对象；<br>    document.title;            title标签的string值，★注意不是对象★；<br>    document.body;            body标签的对象；</p><p>Ⅱ属性控制：</p><p>⒈属性划分：<br>  普通属性：id, title, src…                            //获取修改方便<br>  特殊属性：href, className, tagName(只读且全大写), innerHTML, innerText…     //获取修改麻烦，需要注意具体方式<br>  表单属性：value, type, disabled, selected, checked…                //表单控件才有，注意其赋值与对应的HTML属性之间的区别<br>  style属性：style对象                                //本身是一个行内样式的接口对象，其属性则是对应行内样式属性的接口（不仅可读——读的是行内style，还可写——修改行内style）<br>    style对象属性                                //其属性值都是string，没有显式设置时的值都是””，命名规则按照驼峰命名法（因为和css不一样，JS标识符不能用”-“）</p><p> ①value、innerHTML、innerText：<br>    value                //可读可写（string），所有带有value属性的标签都可以设置和修改的属性<br>    innerHTML            //可读可写（string），双闭合标签内部的内容(可识别子标签)<br>    innerText            //可读可写（string），双闭合标签内部的内容(不识别子标签)<br>    ★注意：老版本火狐不支持innerText，而是用textContent！！！<br>    ¤兼容¤<br>    function getText(ele){<br>        if(ele.innerText !== undefined){<br>            return ele.innerText;<br>        }else{<br>            return ele.textContent;<br>        }<br>    }<br>    function setText(ele,txt){<br>        if(ele.innerText != undefined){<br>            ele.innerText = txt;<br>        }else{<br>            ele.textContent = txt;<br>        }<br>    }</p><p> ②disabled、selected、checked：<br>    disabled            //可读可写（boolean），这些对应的HTML标签属性不依赖于其属性值，只要该属性名存在于标签中就能起作用，所以其对应的JS属性接口是boolean型，true(或能转化为true)表示存在，false（或””,null,undefined,0,NaN）不存在<br>    selected            //可读可写（boolean），注意对应的HTML属性只控制其默认是否被选中状态，而JS中该属性则对应当前是否被选中状态<br>    checked                //可读可写（boolean），注意对应的HTML属性只控制其默认是否被选中状态，而JS中该属性则对应当前是否被选中状态</p><p> ③style属性操作：和其他属性不一样的地方在于——其他属性值为字符串，而style属性值为对象；<br>         样式少的时候使用，可以设置类样式但不能获取——因为其只和行内式对应交互，而不能获取实际起作用的样式值（即最高优先级）<br>  element.style.cssName = “字符串形式的样式”;</p><p>⒉属性操作：操作HTML元素的相关属性；<br>    a.常用形式：利用HTML属性在DOM对象中的相关属性接口；<br>            DOM对象.属性;            //.后内容作为标识符解析<br>            DOM对象[属性];            //[]中内容作为表达式解析<br>    b.方法形式：    DOM对象.getAttribute(“”);    //获取HTML属性值（返回string）<br>            DOM对象.setAttribute(“”,value);    //设置HTML属性值或添加新属性及值（赋值string），可置空属性值，但无法删除<br>            DOM对象.removeAttribute(“”);    //删除HTML属性名<br>    ★注意：方法形式控制HTML元素的class属性，仍用”class”作为属性名的参数！！！<br>    ★注意：方法形式获取disable等类型的HTML属性，返回值也是string类型，没有属性值则得到的是””，没有属性名时获取null！！！<br>    ★注意：方法形式设置的自定义属性会出现在标签上，而普通形式不会出现在标签上，只是设置在了JS对象上！！！</p><p>Ⅲ访问关系：通过一个节点的某个DOM属性找另外一个节点；</p><p>⒈父节点：<br>    element.parentNode;            //兼容性非常好</p><p>⒉兄弟节点：<br>    element.previousElementSibling;        //前一个元素兄弟节点（跳过非元素的文本节点和注释），IE678不支持<br>    element.nextElementSibling;        //后一个元素兄弟节点（跳过非元素的文本节点和注释），IE678不支持<br>    element.previousSibling;        //前一个兄弟节点（包括非元素的文本节点和注释），IE678支持但指向的是前一个元素节点<br>    element.nextSibling;            //后一个兄弟节点（包括非元素的文本节点和注释），IE678支持但指向的是后一个元素节点<br>    ¤兼容¤<br>    var prev = element.previousElementSibling || element.previousSibling;    //现代浏览器使用前面的，IE678使用后面的<br>    var next = element.nextElementSibling || element.nextSibling;        //现代浏览器使用前面的，IE678使用后面的</p><p>⒊单个子节点：<br>    element.firstElementChild;        //第一个元素子节点（跳过非元素的文本节点和注释），IE678不支持<br>    element.lastElementChild;        //最后一个元素子节点（跳过非元素的文本节点和注释），IE678不支持<br>    element.firstChild;            //第一个子节点（包括非元素的文本节点和注释），IE678支持但指向的是第一个元素子节点<br>    element.lastChild;            //最后一个子节点（包括非元素的文本节点和注释），IE678支持但指向的是最后一个元素子节点<br>    ¤兼容¤<br>    var first = element.firstElementChild || element.firstChild;        //现代浏览器使用前面的，IE678使用后面的<br>    var last = element.lastElementChild || element.lastChild;        //现代浏览器使用前面的，IE678使用后面的</p><p>⒋所有子节点：<br>    element.children;            //所有元素子节点（跳过非元素的文本节点和注释），但IE678不会跳过注释节点<br>    element.childNodes;            //所有子节点（包括非元素的文本节点和注释，一般配合nodeType属性使用），W3C官方推荐</p><p>⒌节点属性：<br>  nodeType                    //节点类型：1-元素节点，2-属性节点，3-文本节点，8-注释节点，9-DOM根节点（document），11-虚节点（DocumentFragment）<br>  nodeName                    //节点名称：大写tagName-元素节点，属性名-属性节点，#text-文本节点，#comment-注释节点，#document-DOM根节点（document）<br>  nodeValue                    //节点值：null-元素节点，属性值-属性节点，文本内容-文本节点，注释内容-注释节点，null-DOM根节点（document）</p><p>Ⅳ节点操作：<br>⒈元素节点创建：<br>    document.write(“…”);<br>    element.innerHTML = …;<br>    document.createElement(“tagName”);<br>    document.createDocumentFragment();        //创建虚节点框，其在页面上不显示自身，常用于缓存批量添加的子节点，以减少页面重绘操作<br>⒉元素节点(新)添加/(旧)移动：<br>    element.appendChild(newElement);<br>    element.insertBefore(newElement, refElement);    //refElement为null或undefined则功能同appendChild方法<br>⒊元素节点删除：<br>    element.removeChild(oldChild);<br>    element.remove();                //等价于element.parentNode.removeChild(element)<br>⒋元素节点复制：<br>    element.cloneNode(deep);            //deep为true则深拷贝，false浅拷贝<br>⒌元素节点替换：<br>    element.replaceChild(newElement, oldChild);</p><p>Ⅵ事件处理：客户端JavaScript程序采用了异步事件驱动编程模型，即它们静待事件发生，然后它们响应并产生事件event。如果JS应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。</p><p>⒈事件术语：事件本身并不是一个需要定义的技术名词，简而言之，事件就是Web浏览器通知应用程序发生了什么事情的机制。事件不是JavaScript对象，不会出现在程序源代码中，只会有一些事件相关的对象出现在源代码中。</p><pre><code>①事件类型（event type）：一个用来说明发生什么类型事件的字符串，如“mousemove”、“keydown”、“load”等（不带on开头），实际上就是事件名字；②事件目标（event target）：发生事件或与之相关的对象，在客户端JavaScript应用程序中，window、document和element对象是最常见的事件目标，但某些事件是由其他类型对象触发；★注意：当讲到某一事件时，必须同时指明事件类型和目标！！！★注意：在事件对象event中，target属性指向真正引发该事件的目标对象，currentTarget属性则指向该事件当前所传播到的目标对象，其可能是真正目标的某个父元素对象！！！③事件处理程序或事件监听程序（event handler|event listener）：处理或响应事件的函数，应用程序通过指明事件类型和事件目标，在web浏览器中注册它们的事件处理程序函数；④事件对象：与特定事件相关且包含有关该事件详细信息的对象，所有的事件对象都有用来指定事件类型的type属性和指定事件真正目标的target属性（★IE678中用srcElement而非target），而且每个事件类型都为其相关        事件对象定义一组其他属性，但也有许多事件类型仅定义了像type和target这样少量的标准属性。        event.eventPhase        事件当前处于哪个传播阶段：1.捕获，2.目标，3.冒泡；        event.timeStamp        事件生成时的时间；        event.bubbles        事件是否支持冒泡：true，false；        event.button        事件被触发时哪个鼠标按钮被点击；        event.pageX            光标相对于当前整个网页的水平坐标；        event.pageY            光标相对于当前整个网页的垂直坐标；        event.screenX        光标相对于当前屏幕的水平坐标；        event.screenY        光标相对于当前屏幕的垂直坐标；        event.clientX        光标相对于当前网页在浏览器中可见区域的水平坐标；        event.clientY        光标相对于当前网页在浏览器中可见区域的垂直坐标；        event.type            事件类型；        event.target        事件的真正目标；        event.currentTarget        事件当前传播到的目标；¤兼容¤    event.target ? event.target : event.srcElement;★注意：通常浏览器中，事件对象作为参数传递给事件处理程序函数（即带实参调用），但不包括IE678版本，在这些浏览器中仅能通过全局变量event才能得到事件对象！！！★注意：谷歌既支持传递event对象作实参，也支持全局变量event；而火狐仅支持传递参数方式！⑤事件传播：浏览器决定哪个对象触发其事件处理程序的过程；        对于单个对象的特定事件必须是不能传播的，如window对象的load事件；捕获：事件传播的一种形式称为事件捕获，在容器父元素上注册的★特定★处理程序会有机会在事件传播到真实目标之前拦截或“捕获”它（★IE678不支持事件捕获），即当某文档元素上发生了某个类型的事件时，浏览器会从window对象开始依次经过该元素的所有父节点传递该事件，并触发那些注册为“捕获”的事件处理程序函数；目标：事件传播到其真正的目标对象；冒泡：当文档元素上，发生了某个类型的事件时，它们会在文档树上向上传播或称“冒泡”（bubble），即从事件真实目标开始将该事件依次传递给其所有父元素对象，触发其同类型的且没有设置为“捕获”的事件处理程序函数；★注意：在一个事件的完整传播过程当中，所有的事件处理程序函数都会收获到同一个事件对象，不过其中的某些值可能已经改变，例如currentTarget会指向当前传播到的目标对象！！！★注意：标准事件模型——捕获阶段｛从window对象开始到直接父元素，捕获阶段父元素只执行“捕获”函数｝——目标阶段｛目标阶段中，事件目标会依次执行所有其注册的该类型事件处理程序函数｝——冒泡阶段｛从直接父元素开始到window对象结束，某些事件（如文档元素的load事件）会在document处停止冒泡而不会传播到window对象，冒泡阶段父元素只执行非“捕获”函数｝！！！★注意：事件委托——利用事件传播的“冒泡”过程，在容器父元素上注册单个事件处理程序，以之代替为每个子元素分别设置各自的事件处理程序，父元素程序中可以通过收到的事件对象中事件目标target来    确认引生事件的特定子元素，并执行为其设置的相应处理程序。⑥事件取消：一些事件有与之相关的默认操作，如超链接上click事件时，浏览器默认加载新页面，而事件处理程序可以通过返回一个适当的值、调用事件对象的某个方法或设置事件对象的某个属性来阻止默认操作的发生。</code></pre><p>⒉事件类型：</p><p>★★★★事件类型总结：<br>    ◎标准事件◎<br>    事件名称        事件类型        规范                触发时机<br>      ◆鼠标|触控：<br>    click            MouseEvent        DOM L3                A pointing device button has been pressed and released on an element.<br>    dblclick        MouseEvent        DOM L3                A pointing device button is clicked twice on an element.</p><pre><code>mouseup            MouseEvent        DOM L3                A pointing device button is released over an element.mousedown        MouseEvent        DOM L3                A pointing device button (usually a mouse) is pressed on an element.mouseenter        MouseEvent        DOM L3                A pointing device is moved onto the element that has the listener attached.mouseleave        MouseEvent        DOM L3                A pointing device is moved off the element that has the listener attached.mouseout        MouseEvent        DOM L3                A pointing device is moved off the element that has the listener attached or off one of its children.mousemove        MouseEvent        DOM L3                A pointing device is moved over an element.mouseover        MouseEvent        DOM L3                A pointing device is moved onto the element that has the listener attached or onto one of its children.wheel            WheelEvent        DOM L3                A wheel button of a pointing device is rotated in any direction.touchstart        TouchEvent        Touch Events            A touch point is placed on the touch surface.touchend        TouchEvent        Touch Events            A touch point is removed from the touch surface.touchenter        TouchEvent        Touch Events Removed        A touch point is moved onto the interactive area of an element.touchleave        TouchEvent        Touch Events Removed        A touch point is moved off the interactive area of an element.touchmove        TouchEvent        Touch Events            A touch point is moved along the touch surface.touchcancel        TouchEvent        Touch Events            A touch point has been disrupted in an implementation-specific manners (too many touch points for example).dragstart        DragEvent        HTML5                The user starts dragging an element or text selection.drag            DragEvent        HTML5                An element or text selection is being dragged (every 350ms).dragend            DragEvent        HTML5                A drag operation is being ended (by releasing a mouse button or hitting the escape key).dragenter        DragEvent        HTML5                A dragged element or text selection enters a valid drop target.dragover        DragEvent        HTML5                An element or text selection is being dragged over a valid drop target (every 350ms).dragleave        DragEvent        HTML5                A dragged element or text selection leaves a valid drop target.drop            DragEvent        HTML5                An element is dropped on a valid drop target.select            UIEvent            DOM L3                Some text is being selected.☆清除鼠标拖动元素时选中的文字区域：window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();  ◆键盘：keydown            KeyboardEvent        DOM L3                A key is pressed down.keypress        KeyboardEvent        DOM L3                A key is pressed down and that key normally produces a character value (use input instead).keyup            KeyboardEvent        DOM L3                A key is released.  ◆焦点：focus            FocusEvent        DOM L3                An element has received focus (does not bubble).blur            FocusEvent        DOM L3                元素失去焦点 （不会冒泡）change            Event            DOM L2, HTML5            An element loses focus and its value changed since gaining focus.  ◆AJAX：readystatechange    Event            HTML5 and XMLHttpRequest    The readyState attribute of a document has changed.timeout            ProgressEvent        XMLHttpRequest       ◆剪切板：copy            ClipboardEvent        Clipboard            The text selection has been added to the clipboard.cut            ClipboardEvent        Clipboard            The text selection has been removed from the document and added to the clipboard.paste            ClipboardEvent        Clipboard            Data has been transfered from the system clipboard to the document.  ◆载入：load            UIEvent            DOM L3                A resource and its dependent resources have finished loading.beforeunload        BeforeUnloadEvent    HTML5                即将卸载 window，document 及其资源unload            UIEvent            DOM L3                The document or a dependent resource is being unloaded.load            ProgressEvent        Progress and XMLHttpRequest    Progression has been successful.loadstart        ProgressEvent        Progress and XMLHttpRequest    Progress has begun.loadend            ProgressEvent        Progress and XMLHttpRequest    Progress has stopped (after &quot;error&quot;, &quot;abort&quot; or &quot;load&quot; have been dispatched).abort            UIEvent            DOM L3                资源载入已被中止abort            ProgressEvent        Progress and XMLHttpRequest    Progress 被终止(不是error造成的)abort            Event            IndexedDB            事务已被中止  ◆表单：reset            Event            DOM L2,HTML5            A form is reset.submit            Event            DOM L2,HTML5            A form is submitted.input            Event            HTML5                The value of an element changes or the content of an element with the attribute contenteditable is modified.invalid            Event            HTML5                A submittable element has been checked and doesn&apos;t satisfy its constraints.  ◆窗口：resize            UIEvent            DOM L3                The document view has been resized.scroll            UIEvent            DOM L3                The document view or an element has been scrolled.  ◆动画：animationstart        AnimationEvent        CSS Animations            一个CSS 动画已开始animationend        AnimationEvent        CSS Animations            完成一个CSS 动画 animationiteration    AnimationEvent        CSS Animations            重复播放一个CSS 动画transitionend        TransitionEvent        CSS Transitions            A CSS transition has completed.  ◆多媒体：audiostart        Event            Web Speech API            用户代理开始捕捉用以语音识别的音频audioend        Event            Web Speech API            用户代理捕捉到用以语音识别的音频audioprocess        AudioProcessingEvent    Web Audio API            一个ScriptProcessorNode 的输入缓冲区可处理canplay            Event            HTML5 media            The user agent can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content.canplaythrough        Event            HTML5 media            The user agent can play the media, and estimates that enough data has been loaded to play the media up to its end without having to stop for further buffering of content.durationchange        Event            HTML5 media            The duration attribute has been updated.emptied            Event            HTML5 media            The media has become empty; for example, this event is sent if the media has already been loaded (or partially loaded), and theload() method is called to reload it.ended            Event            HTML5 media            Playback has stopped because the end of the media was reached.play            Event            HTML5 media            Playback has begun.pause            Event            HTML5 media            Playback has been paused.playing            Event            HTML5 media            Playback is ready to start after having been paused or delayed due to lack of data.ratechange        Event            HTML5 media            The playback rate has changed.seeked            Event            HTML5 media            A seek operation completed.seeking            Event            HTML5 media            A seek operation began.suspend            Event            HTML5 media            Media data loading has been suspended.timeupdate        Event            HTML5 media            The time indicated by thecurrentTime attribute has been updated.volumechange        Event            HTML5 media            The volume has changed.waiting            Event            HTML5 media            Playback has stopped because of a temporary lack of data.stalled            Event            HTML5 media            The user agent is trying to fetch media data, but data is unexpectedly not forthcoming.loadeddata        Event            HTML5 media            The first frame of the media has finished loading.loadedmetadata        Event            HTML5 media            The metadata has been loaded.  ◆网络：offline            Event            HTML5 offline            The browser has lost access to the network.online            Event            HTML5 offline            The browser has gained access to the network (but particular websites might be unreachable).  ◆其他：afterprint        Event            HTML5                相关文档已开始打印或打印预览已被关闭beforeprint        Event            HTML5                相关文档将要开始打印或准备打印预览devicelight        DeviceLightEvent    Ambient Light Events        Fresh data is available from a light sensor.devicemotion        DeviceMotionEvent    Device Orientation Events    Fresh data is available from a motion sensor.deviceorientation    DeviceOrientationEvent    Device Orientation Events    Fresh data is available from an orientation sensor.deviceproximity        DeviceProximityEvent    Proximity Events        Fresh data is available from a proximity sensor (indicates an approximated distance between the device and a nearby object).downloading        Event            Offline                The user agent has found an update and is fetching it, or is downloading the resources listed by the cache manifest for the first time.endEvent        TimeEvent        SVG                A SMIL animation element ends.SVGAbort        SVGEvent        SVG                Page loading has been stopped before the SVG was loaded.SVGError        SVGEvent        SVG                An error has occurred before theSVG was loaded.SVGLoad            SVGEvent        SVG                An SVG document has been loaded and parsed.SVGResize        SVGEvent        SVG                An SVG document is being resized.SVGScroll        SVGEvent        SVG                An SVG document is being scrolled.SVGUnload        SVGEvent        SVG                An SVG document has been removed from a window or frame.SVGZoom            SVGZoomEvent        SVG                An SVG document is being zoomed.repeatEvent        TimeEvent        SVG                A SMIL animation element is repeated.fullscreenchange    Event            Full Screen            An element was turned to fullscreen mode or back to normal mode.fullscreenerror        Event            Full Screen            It was impossible to switch to fullscreen mode for technical reasons or because the permission was denied.hashchange        HashChangeEvent        HTML5                The fragment identifier of the URL has changed (the part of the URL after the #).storage            StorageEvent        Web Storage            A storage area (localStorage orsessionStorage) has changed.pagehide        PageTransitionEvent    HTML5                A session history entry is being traversed from.pageshow        PageTransitionEvent    HTML5                A session history entry is being traversed to.popstate        PopStateEvent        HTML5                A session history entry is being navigated to (in certain cases).visibilitychange    Event                            Page visibility    The content of a tab has become visible or has been hidden.</code></pre><p>⒊事件注册：<br>    注册事件处理程序有两种基本方式：<br>    ◇第一种方式出现在Web初期，即给JS事件目标对象或HTML文档元素设置事件属性：<br>        ①设置HTML标签元素的事件属性：HTML中事件属性名是加on开头的事件名，其中不区分大小写；<br>        ②设置JavaScript元素节点对象的事件属性：JS中事件属性名是加on开头的事件名，其中区分大小写，所以必须为对应的小写；<br>          在这种方式中，可以通过设置事件属性的值为null来删除注册的事件处理程序；<br>    ★注意：虽然每个HTML标签元素的事件属性，在其对应的JS元素对象中都有一个相应的事件属性作为编程接口，但这两个属性却是完全不同的——HTML中的事件属性接受的是一个字符串程序代码（其执行环境类似于将代码放入function(event){with(document){with(this.form||{}){with(this){code}}}}，然后将此匿名函数传给其接口对象去调用），<br>        而JS中的事件属性却必须接受一个函数对象作为处理程序！！！<br>    ★注意：再次体会，编程接口的工作方式可能与其参照体有所不同！！！<br>    ★注意：设置JS对象中的事件属性，会导致覆盖掉相应的HTML元素中的相同事件属性上的设置！<br>        另外，通过JS事件属性设置的处理程序最多只能有一个，即多次重复设置会产生覆盖！！<br>    ◇第二种方式更新更通用，即将事件处理程序函数传递给目标对象的一个事件注册方法：<br>        ③通过元素节点对象调用addEventListener(事件类型,监听程序,useCapture)方法（谷歌/火狐/IE9+）：★注意★事件类型一定要是没有on开头的事件名，且其中区分大小写！！！布尔值useCapture指定<br>        该监听程序是否注册为“捕获”阶段的执行函数，默认值为false。<br>          在这种方式中，可以用removeEventListener(事件类型,监听程序,useCapture)方法来删除注册的事件处理程序；<br>    ★注意：在谷歌/火狐/IE9+中，事件监听方式与事件属性方式共享同一事件绑定队列，当通过事件属性绑定执行函数时，先去除队列中原有的该属性名绑定的函数，再添加新的绑定函数进入队列；而通过事件<br>        监听绑定执行函数时，先检查该函数是否已绑定过该事件及其是否捕获时执行，若没有绑定过或执行方式不同则添加新的绑定到队列中，若已经绑定过了且执行方式相同就跳过（即不改变原有执行顺序）。<br>        ④通过元素节点对象调用attachEvent(事件类型，监听程序)方法（IE678）：事件类型是加on开头的事件名，且区分大小写，IE678只支持目标和冒泡阶段，而没有捕获阶段；<br>          在这种方式中，可以用detachEvent(事件类型,监听程序)方法来删除注册的事件处理程序；<br>    ★注意：在IE678中，事件监听方式将绑定的事件名与执行函数放入一个栈中，这些函数都无法选择在捕获阶段执行，其执行时this绑定的是全局对象，而且允许相同的事件处理程序函数注册多次，事件发生时调用的次数即为注册过的次数；<br>        通过事件属性方式绑定的执行函数总是先于栈中函数的执行，其执行时this绑定调用函数的目标对象。<br>    ★注意：两种事件监听方式都不会覆盖事件属性方式绑定的处理程序！！！<br>    ¤兼容¤<br>        function addEvent(element, event, function){<br>            //if(element.addEventListener &amp;&amp; typeof element.addEventListener === “function”){<br>            //if(element.addEventListener != undefined){<br>            if(element.addEventListener){<br>                element.addEventListener(event, function);<br>            }else if(element.attachEvent){<br>                element.attachEvent(“on” + event, function);<br>            }else{<br>                element[“on” + event] = function;<br>            }<br>        }<br>        function removeEvent(element, event, function){<br>            //if(element.removeEventListener &amp;&amp; typeof element.removeEventListener === “function”){<br>            //if(element.removeEventListener != undefined){<br>            if(element.removeEventListener){<br>                element.removeEventListener(event, function);<br>            }else if(element.detachEvent){<br>                element.detachEvent(“on” + event, function);<br>            }else{<br>                element[“on” + event] = null;<br>            }<br>        }<br>    ★★★注意：解绑/删除事件监听方式注册的事件处理程序函数时，必须要事先保存注册时的那个函数对象到某一变量或对象的属性中，而解绑时必须使用注册时传递的同一个函数对象！！！</p><p>⒋事件调用：<br>    ①事件处理程序的参数：<br>        通常，在谷歌、火狐和IE9+中，调用事件处理程序时把事件对象作为它们的一个参数传递，由事件对象的属性提供有关事件的详细信息；<br>        然而，在IE678中，当调用注册的事件处理程序时并未传递事件对象，取而代之的是，要通过全局对象window.event来获得事件对象；<br>        另外，当通过设置HTML属性注册事件处理程序时，浏览器会把JS代码转换到如下的一个函数中，其中非IE678浏览器使用event参数来构造函数，而IE678在构造函数时没有参数；<br>            function (event){with(document){with(this.form||{}){with(this){JScode}}}}<br>            function (){with(document){with(this.form||{}){with(this){JScode}}}}<br>    ¤兼容¤<br>        function (event){event = event || window.event;…}</p><pre><code>②事件处理程序的运行环境：    通过事件属性或addEventListener方法注册的事件处理程序是在事件目标上定义的，所以它们作为这个对象的方法来调用，即程序中this指向事件目标本身；    通过attachEvent方法注册的事件处理程序是作为普通函数来调用，即其程序中this指向全局对象window（可以通过call方法转变this指向）；③事件处理程序的作用域：    事件处理程序函数的外部作用域是其定义时的作用域，而非调用时的作用域，并且它们能存取那个作用域中的任何一个本地变量；    然而，通过HTML事件属性来注册的事件处理程序是一串代码，而非函数。它们被转换到一个能存取全局变量的顶级函数中而非任何本地作用域，并且它们运行在一个修改后的作用域链中——通过HTML属性    定义的事件处理程序能好像本地变量一样使用目标对象、容器form对象（如果有）和document对象的属性。④事件处理程序的返回值：    通过JS对象事件属性或HTML事件属性注册的事件处理程序，其返回值有时是非常有意义的，通常返回值为false就是告诉浏览器不要执行这个事件相关的默认操作。例如，表单提交按钮的onclick事件若返回    false就能阻止浏览器提交表单；输入域上的onkeypress事件处理程序能通过返回false来过滤键盘输入；window对象的onbeforeunload（发生在页面卸载unload事件之前）事件处理程序的返回值若是一个字    符串，那么它将出现在确认离开当前页面的询问对话框中。★★★★注意：事件处理程序的返回值，只在通过属性注册的处理程序中才有意义，这一点非常重要！！！    通过addEventListener方法或attachEvent方法注册的事件处理程序中，则必须调用preventDefault方法或设置事件对象的returnValue属性来阻止默认操作。⑤事件取消：    取消默认操作：        通过属性注册——返回false；        通过addEventListener方法注册——调用event.preventDefault()方法；        通过attachEvent方法注册——设置event.returnValue = false；¤兼容¤    function (event){        event = event || window.event;        ...        if(event.preventDefault)event.preventDefault();        if(event.returnValue)event.returnValue = false;        return false;    }    取消事件传播：        支持addEventListener方法的浏览器：调用event.stopPropagation()方法，可以在事件传播期间的任何时间调用，它能工作在捕获阶段、目标阶段和冒泡阶段，调用该方法并不会阻止当前                          目标上还未执行的处理程序，只会阻止传播过程的下一个目标及之后的所有对象上相关程序被调用；        支持attachEvent方法的浏览器：设置event.cancelBubble属性为true，只能取消事件冒泡过程；¤兼容¤    function (event){        event = event || window.event;        ...        if(event.stopPropagation)event.stopPropagation();        if(event.cancelBubble)event.cancelBubble = true;    }</code></pre><p>Ⅴ三大系列：都是DOM中元素节点对象的属性；</p><p>⒈offset系列：<br>    ①offsetWidth/offsetHeight：获取该元素在页面中的整个盒子的宽度和或高度，值为数字类型，不带单位（width/height+padding+border）；<br>    ②offsetTop/offsetLeft：获取相对于该元素向上第一个设置了定位（非static）的父元素的坐标位置（数字类型，不带单位），如果没有父系盒子设置定位，则以整个页面为基准；<br>    ③offsetParent：获取从该元素向上找第一个设置了定位的父系元素对象，如果没有父系盒子设置定位，则该属性指向body标签的对象；</p><p>⒉scroll系列：<br>    ①scrollWidth/scrollHeight：获取该元素在页面中包括padding区域在内的宽度或高度，不受border和margin影响，但受超出内容影响（width/height+padding）；<br>    ②scrollTop/scrollLeft：body/html对象的该属性可以获取整个页面被滚动卷曲而看不到的顶部距离/左侧距离（但有兼容性问题：支持通过body还是html对象来获取不统一，谷歌有DTD用html，无DTD用body，IE只支持html），<br>                其他对象的该属性可以获取该对象中的内容区或子元素被卷曲到顶部或左侧的距离（必须在设置了滚动条的状态下才起作用，如overflow:scroll或overflow:auto）；<br>    ③window.pageXOffset/window.pageYOffset：为了解决②中的兼容性问题，W3C推荐使用这两个属性来获取整个页面被隐藏的顶部和左侧的距离（IE678不支持）；<br>    ¤兼容1¤<br>        function scroll(){<br>            return {<br>                left : window.pageXOffset || document.documentElement.scrollLeft,<br>                top : window.pageYOffset || document.documentElement.scrollTop<br>            }<br>        }<br>    ¤兼容2¤<br>        function scroll(){<br>            return {<br>                left : document.body.scrollLeft + document.documentElement.scrollLeft,<br>                top : document.body.scrollTop + document.documentElement.scrollTop<br>            }<br>        }</p><p>⒊client系列：<br>    ①clientWidth/clientHeight：html/body对象的该属性可以获取浏览器窗口中页面可视区域的宽度或高度（同样有兼容性问题：支持通过body还是html对象来获取不统一，谷歌有DTD用html，无DTD用body，IE只用html），<br>                    其他对象的该属性可以获取本元素在页面中包括padding区域在内的宽度或高度，不受border/margin或超出内容的影响（width/height+padding）；<br>    ¤兼容¤<br>        function client(){<br>            return {<br>                width: window.innerWidth || document.documentElement.clientWidth,<br>                height: window.innerHeight || document.documentElement.clientHeight<br>            }<br>        }<br>    ②clientTop/clientLeft：获取元素在页面中上border或左border的宽度；<br>    ③window.innerHeight/window.innerWidth：为了解决①中的兼容性问题，W3C推荐使用这两个属性来获取浏览器窗口中页面可视区域的宽度或高度（IE678不支持）；</p><p>⒋获取页面中标签元素的样式属性值：<br>    window.getComputedStyle方法（谷歌/火狐/IE9+）：可以精确获取元素在当前页面中所实际显示的CSS样式属性值（即当前最高优先级的属性值）；<br>        window.getComputedStyle(element[, pseudoElt]);        //element获取属性值的元素对象，pseudoElt伪元素字符串或null，返回一个包含有该元素上所有样式属性的键值对的对象，该对象不是编程接口（只读），其对应实际显示的样式值<br>    ★注意：元素节点对象的style属性也是一个包含了该元素上所有样式属性键值对的对象，不过该对象是一个编程接口（可读/写），可以用来修改元素的样式值，但其对应的只是行内样式中的属性值！！！<br>    currentStyle属性（IE678）：<br>        element.currentStyle;                    //该属性是一个对象<br>    ¤兼容¤<br>        function getCurrentStyle(element, attribute){<br>            //if(window.getComputedStyle &amp;&amp; typeof window.getComputedStyle === “funciton”){<br>            //if(window.getComputedStyle != undefined){<br>            if(window.getComputedStyle){<br>                return window.getComputedStyle(element, null)[attribute];<br>            }else{<br>                return element.currentStyle[attribute];<br>            }<br>        }</p><p>⒌事件对象中的位置属性：<br>    ①pageX/pageY：获取光标在当前整个页面中的坐标（IE678不支持，可以用在可视区域的坐标加上页面被卷曲隐藏的部分来代替）；<br>    ¤兼容¤<br>        function pageMouse(){<br>            return {<br>                pageX = event.pageX || event.clientX + document.documentElement.scrollLeft,<br>                pageY = event.pageY || event.clientY + document.documentElement.scrollTop<br>            };<br>        }<br>    ②screenX/screenY：获取光标在当前整个屏幕中的坐标；<br>    ③clientX/clientY：获取光标在当前浏览器窗口页面可视区域的坐标；<br>    ④offsetX/offsetY：获取光标在当前事件目标元素内的坐标；</p><p>ⅥJQuery类库：JQuery是一个JS的工具包(特别大，功能强)，里面封装了很多功能和方法，方便我们开发；兼容很多浏览器(IE678不用再做兼容了)；</p><p>JQuery的特点：<br>a.优点：连式编程和隐式迭代;<br>        连式编程——$(“div”).css().show().hide();<br>        隐式迭代——内部自动带有for循环；<br>b.缺点：代码冗余(很多方法实现统一功能)；</p><p>入口函数(window.onload)：<br>①$( function (){ console.log($(“div”)); });<br>②$( document ).ready( function (){ console.log($(“div”)); });<br>③$( window ).ready( function (){ console.log($(“div”)); });</p><p>④jQuery( function (){ console.log($(“div”)); });<br>⑤jQuery( document ).ready( function (){ console.log($(“div”)); });<br>⑥jQuery( window ).ready( function (){ console.log($(“div”)); });</p><p>⑦$( window ).load( function (){ console.log($(“div”)); });<br>⑧jQuery( window ).load( function (){ console.log($(“div”)); });</p><p>jQuery和$都是设在window中的属性，默认情况下两者是指向同一函数对象（非构造器，但其构造原型是返回的jQuery封装对象的实例原型）；</p><p>jQuery封装对象(简称jQuery对象)，就是一个特殊的伪数组，包含很多属性和DOM对象，实例原型为jQuery.prototype；</p><p>区分DOM对象与jQuery对象——获取方式不同，且分别含有不同的属性与方法！！！</p><p>DOM对象和jQuery对象的相互转换：<br>①DOM对象转换成jQuery对象：    $(element);<br>                $(eleArray);<br>②jQuery对象转换成DOM对象：    $(“div”)[index];<br>                $(element).get(index);</p><p>选择器：<br>①基本选择器：    id选择器    “#id”<br>        类选择器    “.class”<br>        标签选择器    “tagName”<br>        通配符选择器    “*”<br>        并集选择器    “selector1,selector2”<br>        交集选择器    “selector1selector2”<br>②层级选择器：    后代选择器    “selector1 selector2”<br>        子代选择器    “selector1&gt;selector2”<br>③过滤选择器：    索引值选择器    “:eq(…)”<br>        奇数索引选择器    “:odd”<br>        偶数索引选择器    “:even”<br>        差集选择器    “:not(selector)”</p><p>css方法：    jQuery对象.css(“border”)    获取作用在盒子上的最高权限属性值——window.getComputedStyle()<br>        jQuery对象.css(“width”,”300px”)    设置一个属性<br>        jQuery对象.css(json对象)    设置多个属性</p><p>访问关系：<br>    .find()方法——后代元素（子子孙孙）；<br>        $(“ul”).find(“li”).css(“background”,”skyblue”);<br>        $(“ul”).find().css(“background”,”skyblue”);//什么都不写，不会获取任何元素;</p><pre><code>.children()方法——直接子元素（亲儿子元素）；    $(&quot;ul&quot;).children(&quot;li&quot;).css(&quot;background&quot;,&quot;yellowgreen&quot;);    $(&quot;ul&quot;).children().css(&quot;background&quot;,&quot;yellowgreen&quot;);//不写，获取所有子元素;.parent()方法——直接父元素；    console.log($(&quot;#box&quot;).parent());//不写找亲爹;    console.log($(&quot;#box&quot;).parent(&quot;ol&quot;));//写找亲爹;    console.log($(&quot;#box&quot;).parent(&quot;ul&quot;));//写错了，找不到;.eq()方法——根据索引值找元素(返回的是jQuery对象)；    $(&quot;.box&quot;).eq(0).css(&quot;background&quot;,&quot;red&quot;);.siblings()方法——所有的兄弟节点；    $(&quot;#box&quot;).siblings(&quot;li&quot;).css(&quot;background&quot;,&quot;red&quot;);    $(&quot;#box&quot;).siblings().css(&quot;background&quot;,&quot;red&quot;);//不指定获取所有兄弟节点;.next()方法.prev()方法.frist()方法.last()方法.prevAll()方法.nextAll()方法    $(&quot;#box&quot;).nextAll(&quot;li&quot;).css(&quot;background&quot;,&quot;red&quot;);    $(&quot;#box&quot;).nextAll().css(&quot;background&quot;,&quot;red&quot;);//获取所有；.next()方法    $(&quot;#box&quot;).next(&quot;li&quot;).css(&quot;background&quot;,&quot;red&quot;);//无法跨越节点</code></pre><p>类的操作：样式少的时候用css()，样式多的时候用类操作；<br>①类的添加：addClass()，(不是addClassName())不会覆盖掉原有类名，不会重复添加；<br>    $(“li”).addClass(“aaa”);</p><p>②类的删除; removeClass()，有就删除，没有也不报错；<br>    $(“li”).removeClass(“show”);</p><p>③类的判断; hasClass()，返回一个bool值，有就是true，没有就是false，有一个有的就可以；<br>    alert($(“li”).hasClass(“bbb”));</p><p>④类的切换; toggleClass()，有变没，没变有；<br>    $(“li”).toggleClass(“bbb”);</p><p>jQuery动画：<br>①显示隐藏：<br>    show(); 显示<br>    用法1:  无参——瞬间显示[display: block;]；<br>        $(“div”).show();<br>    用法2:  1个参数，毫秒值——指定时间显示[width/height/padding/margin/opacity/overflow/display]；<br>                $(“div”).show(1000);<br>    用法3:  1个参数，字符串——指定时间显示[width/height/padding/margin/opacity/overflow/display]；<br>                /<em> slow：600ms、normal：400ms、fast：200ms </em>/<br>        $(“div”).show(“normal”);<br>    用法4:  2个参数，毫秒值和回调函数——指定时间显示，然后执行函数[width/height/padding/margin/opacity/overflow/display]；<br>        $(“div”).show(2000, function (){ alert(“完成”); });</p><pre><code>hide(); 隐藏用法1:  无参——瞬间隐藏[display: none]；    $(&quot;div&quot;).hide();用法2:  1个参数，毫秒值——指定时间隐藏[width/height/padding/margin/opacity/overflow/display]；    $(&quot;div&quot;).hide(1000);用法3:  1个参数，字符串——指定时间隐藏[width/height/padding/margin/opacity/overflow/display]；            /* slow：600ms、normal：400ms、fast：200ms */    $(&quot;div&quot;).hide(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间隐藏，然后执行函数[width/height/padding/margin/opacity/overflow/display]；    $(&quot;div&quot;).hide(2000, function (){ alert(&quot;完成&quot;); });toggle(); 切换用法1:  无参——瞬间切换[/display: block/none]；    $(&quot;div&quot;).toggle();用法2:  1个参数，毫秒值——指定时间切换[width/height/padding/margin/opacity/overflow/display]；    $(&quot;div&quot;).toggle(1000);用法3:  1个参数，字符串——指定时间切换[width/height/padding/margin/opacity/overflow/display]；            /* slow：600ms、normal：400ms、fast：200ms */    $(&quot;div&quot;).toggle(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间切换，然后执行函数[width/height/padding/margin/opacity/overflow/display]；    $(&quot;div&quot;).toggle(2000, function (){ alert(&quot;完成&quot;); });</code></pre><p>②滑入滑出：<br>    slideDown(); 滑入<br>    用法1:  无参——正常时间滑入[width/height/padding/margin/overflow/display]；<br>        $(“div”).slideDown();    //400ms；</p><pre><code>用法2:  1个参数，毫秒值——指定时间滑入[width/height/padding/margin/overflow/display]；    $(&quot;div&quot;).slideDown(1000);用法3:  1个参数，字符串——指定时间滑入[width/height/padding/margin/overflow/display]；    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).slideDown(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间滑入，然后执行函数[width/height/padding/margin/overflow/display]；    $(&quot;div&quot;).slideDown(2000, function (){ alert(&quot;完成&quot;); });slideUp(); 切换用法1:  无参——正常时间滑出[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideUp();    //400ms用法2:  1个参数，毫秒值——指定时间滑出[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideUp(1000);用法3:  1个参数，字符串——指定时间滑出[width/height/padding/margin/overflow/display]    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).slideUp(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间滑出，然后执行函数[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideUp(2000, function (){ alert(&quot;完成&quot;); });slideToggle(); 切换用法1:  无参——正常时间切换[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideToggle();    //400ms用法2:  1个参数，毫秒值——指定时间切换[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideToggle(1000);用法3:  1个参数，字符串——指定时间切换[width/height/padding/margin/overflow/display]    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).slideToggle(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间切换，然后执行函数[width/height/padding/margin/overflow/display]    $(&quot;div&quot;).slideToggle(2000, function(){ alert(&quot;完成&quot;); });</code></pre><p>③淡入淡出：<br>    fadeIn(); 淡入<br>    用法1:  无参——正常时间淡入[display/opacity]<br>        $(“div”).fadeIn();    //400ms；</p><pre><code>用法2:  1个参数，毫秒值——指定时间淡入[display/opacity]    $(&quot;div&quot;).fadeIn(1000);用法3:  1个参数，字符串——指定时间淡入[display/opacity]    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).fadeIn(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间淡入，然后执行函数[display/opacity]    $(&quot;div&quot;).fadeIn(2000, function (){ alert(&quot;完成&quot;); });fadeOut(); 切换用法1:  无参——正常时间淡出[display/opacity]    $(&quot;div&quot;).fadeOut();    //400ms用法2:  1个参数，毫秒值——指定时间淡出[display/opacity]    $(&quot;div&quot;).fadeOut(1000);用法3:  1个参数，字符串——指定时间淡出[display/opacity]    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).fadeOut(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间淡出，然后执行函数[display/opacity]    $(&quot;div&quot;).fadeOut(2000, function (){ alert(&quot;完成&quot;); });fadeToggle(); 切换用法1:  无参——正常时间切换[display/opacity]    $(&quot;div&quot;).fadeToggle();    //400ms用法2:  1个参数，毫秒值——指定时间切换[display/opacity]    $(&quot;div&quot;).fadeToggle(1000);用法3:  1个参数，字符串——指定时间切换[display/opacity]    /* slow：600ms,normal：400ms,fast：200ms */    $(&quot;div&quot;).fadeToggle(&quot;normal&quot;);用法4:  2个参数，毫秒值和回调函数——指定时间切换，然后执行函数[display/opacity]    $(&quot;div&quot;).fadeToggle(2000, function (){ alert(&quot;完成&quot;); });fadeTo(); 不透明程度;用法1:  指定时间，指定程度——指定时间切换到某个透明度[display/opacity]    $(&quot;div&quot;).fadeTo(1000,0.5);用法2:  3个参数，毫秒值和透明程度和回调函数——指定时间切换透明度，然后执行函数[display/opacity]    $(&quot;div&quot;).fadeTo(1000,0.5,function (){...});</code></pre><p>④自定义动画：<br>    animate(prop,speed,easing,callback);    四个参数：1.json对象（属性:值）；2.时间（msecond）；3.运动方程（linear/swing）；4.回调函数（this指向调用的DOM对象）；<br>★注意：animate()方法能让调用它的元素对象的特定属性从当前值连续地变化到目标状态，但不支持如 transform 、transition 和 animation 这样的属性的不同值之间过渡动画效果，但是可以使用 H5C3 中的 CSS3<br>    属性 transition 或 animation 本身配合包括 transform 在内的众多属性来完成这些动画效果，再通过设置类名或通过行内样式在 JS 中来控制效果的添加或去除！！！</p><p>停止动画：<br>    stop([type,]clearQueue,gotoEnd);    三个参数：1.停止动画的类型；2.是否清空后续动画队列（true，后续不执行；false，后续动画继续执行）；3.是否直接完成当前动画（true，当前动画立即完成；false，当前动画直接停止）；</p><pre><code>$(&quot;div&quot;).stop();        //默认是false，false$(&quot;div&quot;).stop(true,true);    //后续动画不执行,立即执行完成当前动画$(&quot;div&quot;).stop(false,true);    //后续动画会执行,立即执行完成当前动画$(&quot;div&quot;).stop(true,false);    //后续动画不执行,立即停止当前动画$(&quot;div&quot;).stop(false,false);    //后续动画会执行,立即停止当前动画</code></pre><p>DOM元素的创建：<br>①.html(“”)方法：容易覆盖内容，一定要注意+=,需重新绑定事件；<br>    $(父元素).html();            //等同于innerHTML属性值获取<br>    $(父元素).html(“<tagname></tagname>“);    //等同于innerHTML属性值赋值<br>②$(“”)函数：标签名一定要带上“&lt;&gt;”，否则是获取已存在的标签；<br>    $(“<tagname></tagname>“);        //等同于document.createElement(“tagName”)方法<br>    $(“ul”).append($(“<li>这是Li标签</li><li>这是Li标签</li>“));</p><p>DOM元素的添加：<br>①append()方法：<br>    父节点jQquery对象.append(子节点jQquery对象|子节点字符串);    //把参数作为子节点添加到父节点的最末尾;<br>    var li = $(“<li></li>“);<br>    $(“ul”).append(li);<br>    $(“ul”).append(“<li>我是jQ创建的li</li>“);</p><p>②appendTo()方法：<br>    子节点jQquery对象.appendTo(父节点jQquery对象);            //把参数作为父节点添加到该节点的最末尾;<br>    li.appendTo($(“ul”));</p><p>③prepend()方法：<br>    父节点jQquery对象.prepend(子节点jQquery对象|子节点字符串);    //把参数作为子节点添加到父节点的最前面;<br>    $(“ul”).prepend(li);<br>    $(“ul”).prepend(“<li>我是jQ创建的li1</li>“);</p><p>④prependTo()方法：<br>    子节点jQquery对象.prependTo(父节点jQquery对象);            //把参数作为父节点添加到该节点的最前面;<br>    li.prependTo($(“ul”));</p><p>⑤after()方法：<br>    参考节点jQquery对象.after(新节点jQquery对象);            //把新节点添加到参考节点之后，作为其兄弟节点;<br>    $(“.box”).after(li);</p><p>⑥before()方法：<br>    参考节点jQquery对象.before(新节点jQquery对象);            //把新节点添加到参考节点之前，作为其兄弟节点;<br>    $(“.box”).before(li);</p><p>DOM元素的清空和删除：<br>·清空：<br>①empty()方法：先解绑事件，然后再删除元素，比较彻底，推荐使用empty方法；<br>    jQuery对象.empty();<br>②html()方法：<br>    jQuery对象.html(“”);<br>·删除：<br>③remove()方法：<br>    jQuery对象.remove();                        //删除自己<br>    jQuery对象.remove(“selector”);                    //删除对应子元素</p><p>DOM元素的复制：<br>①clone()方法：<br>    jQuery对象.clone(dataAndEvent);                    //没有深层还是浅层复制之分，都是深层复制,参数用于控制是否复制事件;</p><p>jQuery对象操作：</p><p>—属性操作—<br>①attr()方法：类同于原生JS的get/setAttribute()方法，常应用于普通属性（通过属性值起作用）或自定义属性设置（可以对元素设置自定义属性作为标记使用）；<br>    特点：能获取/修改属性名对应的属性值，没有值时获取空串（表单属性存在时总获取该属性名），没有属性名时获取undefined，可以将属性置空但无法删除；<br>    jQuery对象.attr(“htmlProperty”);                //获取属性值<br>    jQuery对象.attr(“htmlProperty”, “value”);            //设置属性值<br>    清空属性：<br>    jQuery对象.attr(“htmlProperty”,””)                //清空属性，设置属性值为空串时，元素上仍有其属性名，但对于普通元素这等效于删除属性<br>    删除属性——removeAttr()方法；<br>    jQuery对象.removeAttr(“htmlProperty”);                //删除属性</p><p>②prop()方法：常应用于表单属性（其属性值是什么不重要，重要的是该属性名是否存在于元素中）；<br>    特点：表单属性存在时返回true，不存在时返回false，其他同attr方法；<br>    jQuery对象.prop(“htmlProperty”);                //获取属性值，表单属性返回boolean值，指示是否存在<br>    jQuery对象.prop(“htmlProperty”, “value”|boolean);        //设置属性值<br>    删除属性——removeProp()方法；<br>    jQuery对象.removeProp(“htmlProperty”);                //通常不使用，通过prop方法设置表单属性false即可代替</p><p>③val()方法：用于操作value属性；<br>    jQuery对象.val();                        //无参获取value值<br>    jQuery对象.val(“value”);                    //带参设置value值</p><p>—内容操作—<br>④html()方法：识别标签==innerHTML；<br>    jQuery对象.html();                        //无参获取内容，包括子标签<br>    jQuery对象.html(“<tagname></tagname>“);                //带参赋值内容，包括子元素</p><p>⑤text()方法：不识别标签==innerText；<br>    jQuery对象.text();                        //无参获取文本内容<br>    jQuery对象.text(“value”);                    //带参赋值文本内容</p><p>—尺寸操作—<br>⑥width/height()方法：对应元素内容区域的宽度/高度，不包括border和padding，值为数字，单位像素；<br>    jQuery对象.width();                        //无参获取<br>    jQuery对象.width(num);                        //带参赋值<br>★注意：.css()方法返回的是字符串（带”px”单位）！！！</p><p>—位置操作—<br>⑦offset()方法：获取或设置元素相对于文档的位置；<br>    jQuery对象.offset();                        //无参获取，返回一个json对象{top:value,left:value}，且该对象不是接口<br>    jQuery对象.offset(json对象);                    //带参赋值，参数必须是一个json对象{top:value,left:value}<br>★注意：当元素没有设置定位时对其赋值来修改位置，会自动给其添加相对定位，然后通过计算当前位置与目标位置的距离，再用以赋值！！！</p><p>⑧position()方法：获取相对于其最近的具有定位的父元素的位置，以该盒子的margin外边界左上角为准，父系盒子没有定位则参照整个页面；<br>    jQuery对象.position();                        //无参获取<br>                                    //无法赋值</p><p>⑨scrollTop()方法：被卷去的顶部距离，用的最多；<br>  scrollLeft()方法：被卷去的左侧距离；<br>    jQuery对象.scrollTop();                        //无参获取，获取值的时候底层原理：body/html.scrollTop;<br>    jQuery对象.scrollTop(num);                    //带参赋值，赋值的原理是页面设置：window.scrollTo(x,y);</p><p>jQuery事件机制：<br>—事件绑定—<br>①简单方法绑定（用事件类型的同名方法）：不会出现事件层叠，不能一次完成多类型事件绑定，没有事件委托功能；<br>    jQuery对象.eventType(fn);                            //<br>    $(“li”).click(function(){code…});                        //隐式迭代,jQuery对象中的所有元素上都绑定同一事件处理函数<br>②bind()方法绑定：不会出现事件层叠，能一次完成多类型事件绑定，没有事件委托功能；<br>    jQuery对象.bind(“eventType1[ eventType2[…]]”,fn);                //<br>    $(“li”).bind(“click mouseover”, function(){code…});                //隐式迭代<br>③delegate()方法绑定：不会出现事件层叠，能一次完成多类型事件绑定，只有事件委托功能，不能用于绑定当前元素自身的事件功能；<br>    jQuery对象.delegate(“selector”, “eventType1[ eventType2[…]]”, fn);<br>    $(“ul”).delegate(“li”, “click mouseover”, function(){code…});<br>④on()方法绑定：不会出现事件层叠，能一次完成多类型事件绑定，有事件委托功能，还可以用于绑定当前元素自身的事件功能；<br>    jQuery对象.on(“eventType1[ eventType2[…]]”[, “selector”][, data], fn);    //data实参会被传递给事件对象event中作为data属性<br>    $(“ul”).on(“click mouseover”, “li”, {name:zhangsan}, function(){code…});    //</p><p>—事件解绑—<br>★注意：jQuery库中的事件绑定有四种形式,但是对应的事件解绑只有三种形式，简单方法绑定方式没有对应的解绑方法，只能使用其他方式提供的解绑方法！！！<br>★注意：jQuery方法绑定的事件处理程序，要用jQuery提供的方式来解绑，而原生JS绑定的函数要用原生JS提供的解绑方法！！！<br>★注意：需解绑的函数必须要事先保留在某处变量或对象的属性当中——解绑必须使用同一函数对象！！！<br>⑤简单方式绑定——使用unbind()或off()方法：<br>    jQuery对象.unbind(“eventType1[ eventType2[…]]”,fn);                //可以一次解绑多种类型事件绑定的同一函数（通过jQuery绑定的事件）<br>    jQuery对象.unbind(“eventType1[ eventType2[…]]”);                //可以一次解绑多种类型事件绑定的所有函数（通过jQuery绑定的事件）<br>    jQuery对象.unbind();                                //可以一次解绑所有类型事件绑定的所有函数（通过jQuery绑定的事件）<br>    jQuery对象.off(“eventType1[ eventType2[…]]”,fn);                //可以一次解绑多种类型事件绑定的同一函数（通过jQuery绑定的事件）<br>    jQuery对象.off(“eventType1[ eventType2[…]]”);                    //可以一次解绑多种类型事件绑定的所有函数（通过jQuery绑定的事件）<br>    jQuery对象.off();                                //可以一次解绑所有类型事件绑定的所有函数（通过jQuery绑定的事件）<br>⑦bind()方法绑定——使用unbind()或off()方法：同上；<br>⑧on()方法绑定————使用off()方法：同上；<br>⑨delegate()方法绑定——使用undelegate()方法：<br>    jQuery对象.undelegate(“selector”, “eventType1[ eventType2[…]]”, fn);        //可以一次解绑所选元素所委托的多种类型事件上绑定的同一函数<br>    jQuery对象.undelegate(“selector”, “eventType1[ eventType2[…]]”);        //可以一次解绑所选元素所委托的多种类型事件上绑定的所有函数<br>                                            //无法解除全部委托</p><p>—事件触发—<br>☆注：事件触发——通过jQuery代码主动触发某些事件机制。<br>①事件方法调用：<br>    jQuery对象.eventType();                                //触发浏览器默认行为，执行该事件上所有逻辑，而不能指定只执行某特定函数逻辑<br>②trigger()方法：<br>    jQuery对象.trigger(“eventType1[ eventType2[…]]”);                //触发浏览器默认行为，执行该事件上所有逻辑，而不能指定只执行某特定函数逻辑<br>③triggerHandler()方法：<br>    jQuery对象.triggerHandler(“eventType1[ eventType2[…]]”);            //不触发浏览器默认行为，同上</p><p>—事件对象—<br>④</p><p>Ⅶ DOM方法扩展：<br>①获取元素的方法：<br>    document.querySelector(“selector”);                        //获取 第一个 符合CSS选择规则的元素<br>    document.querySelectorAll(“selector”);                        //获取 所有的 符合CSS选择规则的元素</p><p>②类名操作：<br>    element.classList.add();                            //类名添加<br>    element.classList.remove();                            //类名移除<br>    element.classList.toggle();                            //类名切换，有则删除无则添加<br>    element.classList.contains();                            //类名包含，判断元素是否包含该类名，包含返回true，否则返回false<br>◇jQuery中的类名操作：<br>    $(‘selector’).addClass(…);                            //jQuery封装的类名添加<br>    $(‘selector’).removeClass(…);                            //jQuery封装的类名移除<br>    $(‘selector’).toggleClass(…);                            //jQuery封装的类名切换<br>    $(‘selector’).hasClass(…);                            //jQuery封装的类名检查</p><p>③自定义属性操作：<br>    ·设置格式：<br>        <tagname data-*="">                            //这里的 <em> 代表自己起的名字，例如：data-name/data-family-name/data-china-family-name<br>    ☆注：最早以前，声明自定义属性是随意的，而为了规范自定义属性的声明格式，所以现在的 DOM 中提供了具体的 声明格式 以及 操作接口 ！！！<br>    ·获取data-</em>格式的属性：<br>        element.dataset.<em>;                            //如果属性中出现多个”-“连接的单词的话，要使用驼峰命名法书写，以代替”-“的连接<br>        $(‘selector’).data(‘</em>‘);                        //jQuery中封装的 data-<em> 的获取方法<br>    ·设置data-</em>格式的属性：<br>        element.dataset.* = value;</tagname></p><p>⑷BOM（Browser Object Model）浏览器对象模型：；</p><p>Ⅰ全局对象window：<br>—Location对象—        //地址栏接口<br>window.location.scheme        //通讯协议，支持不太好<br>window.location.href        //全部内容获取<br>window.location.protocol    //通讯协议<br>window.location.host        //主机地址:端口号<br>window.location.port        //端口号<br>window.location.pathname    //path兼容不太好，获取路径</p><p>页面跳转或刷新：<br>①assign()方法：改变浏览器地址栏的地址，并记录到历史中；<br>    location.assign(“<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>“);    //同下<br>    location.href = “<a href="http://www.jd.com" target="_blank" rel="noopener">http://www.jd.com</a>“;        //用的最多</p><p>②replace()方法：替换浏览器地址栏的地址，不会记录到历史中；<br>    location.replace(“<a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a>“);</p><p>③reload()方法：刷新页面；<br>    location.reload();</p><p>★★★★注意：<br>    a标签的href属性为”#”时，跳转到页面的最顶端（”#id”则跳到特定Id的元素处），不刷新页面；<br>    a标签的href属性为””时，刷新页面；<br>    a标签的href属性为”javascript:;”时，点击以后没有跳转——以下两种可以用于取消a标签的默认跳转行为；<br>    a标签的href属性为”javascript:void(0);”时，点击以后没有跳转；</p><p>—History对象—                        //历史记录接口<br>①forward()方法：跳转到历史记录中的下一个页面；<br>②back()方法：跳转到历史记录中的上一个页面；<br>③go(n)方法：跳转到历史记录中的+下/-上n个页面，或0刷新页面；</p><p>—Navigator对象—                    //系统和浏览器信息<br>①userAgent：用户代理信息——即浏览器信息；<br>②platform：操作系统信息——即windows或apple系统版本等；</p><p>—Document对象—<br>见DOM。</p><p>⑸AJAX（Asynchronous JavaScript and XML）异步的JavaScript和XML：AJAX 是一种在无需重新请求服务器并加载整个网页的情况下，通过JavaScript在后台与服务器进行少量数据交换，使得部分网页实现异步更新的技术；</p><pre><code>AJAX 不是一门新的编程语言，而是一种使用现有标准的新技术、新方法——一套新型的API，它使得在JS中也能够直接主动地发送请求到服务器，而不需要再通过浏览器的加载动作或刷新操作来发送请求——虽然</code></pre><p>  JS中可以通过利用BOM/DOM接口来控制浏览器和页面的加载和刷新动作，但是这种请求本质上仍是通过浏览器间接发送的；<br>  ☆注：让浏览器发送请求的方式——1.表单提交form+submit；2.加载带有href（资源链接使用）或src（资源加载使用）属性的标签；3.地址栏Location；</p><p>⒈AJAX的基础——XMLHttpRequest对象：请求代理对象，该类型对象用于和当前服务器进行交换数据——同域请求，所有现代浏览器均支持内置的 XMLHttpRequest 类型对象（☆注：IE5和IE6使用ActiveXObject）；</p><p>  ■XMLHttpRequest构造器创建实例对象：<br>    ◆var xhr = new XMLHttpRequest();<br>  ☆注：new ActiveXObject(“Microsoft.XMLHTTP”);        //IE5和IE6创建ActiveX对象</p><p>  ■发送请求到服务器：<br>    ◆xhr.open(method, url, async);            //method设置请求的类型[GET|POST]、url设置请求的资源路径URL以及async设置是否异步处理请求[true异步|false同步]；<br>    ★注意：XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true（没有设置该参数时默认值为true）！！！<br>        异步true        调用send()方法发送请求时，程序会在响应到达前就返回（readyState==1）；<br>        同步false        调用send()方法发送请求时，程序会在响应完成后才返回（readyState==4），整个过程中JS程序被“阻塞”；<br>    ★注意：GET请求方式下，必须通过其中的URL地址来向服务器传递参数（$_GET接收）！！！<br>    ★注意：POST请求方式下，不仅可以通过其中的URL地址来向服务器传递参数（$_GET接收），还可以在调用send()方法发送请求时，通过存储其实参值到请求体来传递参数到服务端（$_POST接收）！！！</p><pre><code>★注意：需要注意的是，通过send()方法发送的数据是有一定的类型的——即请求头中Content-Type的值，服务端会根据该MIME类型来决定请求体中内容的相应处理方式——application/x-www-form-urlencoded    将使用URL地址中参数的编码格式来解析请求体中的内容，并将成功获得的键值对传递到$_POST；text/plain;charset=UTF-8按照UTF-8字符集将请求体中的二进制内容解析为纯文本，但不传给$_POST；...等等；    所以，若想让服务端能正确地解析并使用AJAX中POST方式传递的参数，必须在open()连接后，send()发送前设置好相应的请求头Content-Type类型！！！★注意：在服务器端发送的响应报文里，响应头中Content-Type的值会告诉浏览器该响应体内容的类型，浏览器会根据该MIME类型来决定响应体内容的对应处理方式——text/htmlHTML页面；text/cssCSS样式表；    application/javascript将所有文本内容作为JS代码（JSONP：当通过script标签的src属性发送[跨域|同域]请求时，获得的application/javaScript类型文本会被作为JS代码执行）；application/json    JSON格式编码的字符串数据！！！★注意：若请求体或响应体中的数据包含中文编码，则可能需要设置对应的字符集才能正常显示，方法为在请求头或响应头的Content-Type值后面加上字符集设置&quot;;charset=UTF-8&quot;！！！◆xhr.setRequestHeader(header,value);        //设置请求头，如setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;)★注意：JavaScript程序运行在客户端浏览器中，所以只能设置请求头，而响应头只能在服务端去设置（PHP的header()方法）！！！◇xhr.responseType                //设置该值能够告诉服务器你期望的响应体格式◆xhr.send(string);                //按照设定的方式将请求发送到服务器，★string仅用于在 POST 方式下传递参数到响应体中（纯二进制数据），GET 方式下设置了也没有用</code></pre><p>  ■处理整个交互过程——readystatechange事件：每当XMLHttpRequest对象的 readyState 属性改变时，就会触发其上的 readystatechange 事件；<br>    ◆xhr.onreadystatechange = function(){};<br>    ◆xhr.addEventListener(“readystatechange”,function(){});</p><p>  ■XMLHttpRequest对象的状态——readyState属性；<br>    ◇xhr.readyState                请求状态<br>      0                        UNSENT(未打开)，open()方法还未被调用——创建对象但请求未初始化；<br>      1                        OPENED(未发送)，send()方法还未被调用——请求已初始化（同步|异步）；<br>      2                        HEADERS_RECEIVED(已获取响应头)，send()方法已经被调用，响应头和响应状态已经返回——请求发送完毕、服务器响应到达（接到了响应头）但尚未接收响应体；<br>      3                        LOADING(正在下载响应体)，响应体下载中，responseText中已经获取了部分数据——接收响应体；<br>      4                        DONE(请求完成)，整个请求过程已经完毕——响应体接收完毕，响应已完成；<br>  ★注意：当② readyState 等于 4 且① status 状态为 200 时，才表示①访问已成功且②响应已就绪！！！<br>    ◇xhr.status                    该请求的响应状态码(例如，状态码200——表示一个成功的请求)；<br>    ◇xhr.statusText                该请求的响应状态信息，包含一个状态码和原因短语(例如”200 OK”)；<br>      200                        “OK”，访问成功；<br>      404                        未找到页面；</p><p>  ■获取响应信息——响应头：<br>    ◆xhr.getAllResponseHeaders();            //获取包含所有响应头内容（键值对）的对象<br>    ◆xhr.getResponseHeader(headerStr);        //获取特定响应头的值</p><p>  ■获取响应信息——响应体：<br>    ◇xhr.responseText                //获得字符串形式的响应体数据（以json格式编码）<br>    ◇xhr.responseXML                //获得 XML  形式的响应体数据<br>  ☆注：简介 XML 和 JSON ：<br>      □XML（Extensible Markup Language）可扩展标记语言：标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言——被设计用来★传输和存储★数据，对应文件扩展名为(.xml)；</p><pre><code>  □JSON（JavaScript Object Notation）JS对象表示法：是一种轻量级的★数据交换格式★，基于 ECMAScript (W3C制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来★存储和表示★数据，对应文件扩展名为(.json)，MIME 类型是 &quot;application/json&quot; ；◇JavaScript 对象文法：在 JavaScript 语言中，一切都是对象！因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等，但是对象和数组是比较特殊且常用的两种类型：    ·对象表示为键/值对的集合；    ·键名在前，键值在后，两者间使用冒号&quot;:&quot;分隔；    ·键名不需要引号&quot;&quot;|&apos;&apos;包裹；    ·数据之间由逗号分隔；    ·花括号{}用于声明对象；    ·方括号[]用于声明数组；◇JSON 文法：而 JSON 键/值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，区别：    ·键名必须用双引号&quot;&quot;包裹；    ·键值可以是任何JSON类型的数据，如数组，对象，null，数字，字符串，逻辑布尔值；    ·每个对象皆由花括号{}包裹；    ·每个数组须有方括号[]包裹；JSON 数据：    {&quot;firstName&quot;: &quot;John&quot;}等价于这条 JavaScript 语句：    {firstName : &quot;John&quot;}★注意：JSON 是JavaScript对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串！！！◇JSON 和 JavaScript对象的互转：    ·从 JS 对象转换为 JSON 字符串——使用内置实例对象JSON的 JSON.stringify() 方法：        JSON.stringify(value[, replacer [, space]]);        //value为将要序列化成 一个JSON 字符串的值；replacer若是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理|若是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；space指定缩进用的空白字符串，用于美化输出        var json = JSON.stringify({a: &apos;Hello&apos;, b: &apos;World&apos;});     //结果是字符串 &apos;{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}&apos;    ·从 JSON 字符串转换为 JS 对象——使用JSON的 JSON.parse() 方法：        JSON.parse(text[, reviver]);                //text为要被解析成JavaScript值的字符串；reviver是一个函数function (k, v)，规定了在被返回之前原始值如何被解析改造        var obj = JSON.parse(&apos;{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}&apos;);     //结果是对象 {a: &apos;Hello&apos;, b: &apos;World&apos;}◇JSON 和 PHP 数据的转换：    ·从 PHP 数据转换为 JSON 字符串——使用内置的系统函数json_encode(php_value);    ·从 JSON 字符串转换为 PHP 数据——使用内置的系统函数json_decode(json_str[, flag]);//flag默认为false转换为PHP对象，true则转换为PHP数组</code></pre><p>  ■XHR2简介：<br>    ◆xhr.onprogress = function(){};        //新增事件（兼容性问题），readyState===3触发<br>      xhr.addEventListener(‘progress’,function(){});<br>    ◆xhr.onload = function(){};            //新增事件（兼容性问题），readyState===4触发<br>      xhr.addEventListener(‘load’,function(){});</p><p>⒉AJAX的封装：<br>    function ajax(url, method, data, callback){<br>        //url为请求的资源路径，★注意：AJAX只能进行同域请求<br>        //method为请求方式：GET|POST<br>        //data为传递给服务器的参数<br>        //callback为回调功能，当成功获取响应数据之后调用该操作，并传递响应数据作为实参</p><pre><code>    //设置参数默认值    method = method ? method : &apos;GET&apos;;    data = data ? data : {};    //格式化实参数据    method = method.toUpperCase();    var data_arr = [];    for(var k in data){        data_arr.push(k + &apos;=&apos; + data[k]);    }    data = data_arr.join(&apos;&amp;&apos;);            //发送请求    var xhr = new XMLHttpRequest();    if(method === &apos;GET&apos; &amp;&amp; data !== &apos;&apos;){        url += &apos;?&apos; + data;    }    xhr.open(method, url, true);    var send = null;    if(method === &apos;POST&apos; &amp;&amp; data !== &apos;&apos;){        send = data;        xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);        xhr.responseType = &apos;JSON&apos;;    }    xhr.send(send);    //处理响应    xhr.addEventListener(&apos;readystatechange&apos;,function(){        if(this.readyState !== 4)return;        if(this.status !== 200)return;        var data = JSON.parse(this.responseText);        callback(data);    });}//将形参设计为一个对象function ajax(parameterObj){...}ajax({    url:&apos;...&apos;,    method:&apos;...&apos;,    data:{...},    callback:function(){}});</code></pre><p>⒊jQuery封装的AJAX：jQuery底层实现了对 AJAX 请求的功能封装，并在普通请求功能的基础上增加了 AJAX事件 处理等相关的机制；</p><p>①$.ajax()|jQuery.ajax()：jQuery底层的AJAX实现，此外还有简单易用的高层实现——$.get()，$.post()等；<br>    jQuery.ajax(url,[settings]);                                    //$.ajax()返回其创建的 XMLHttpRequest 对象，大多数情况下你无需直接操作该底层函数，除非你需要操作不常用的选项，以获得更多的灵活性<br>    jQuery.ajax(url,                                        //url[string]：请求资源的 URL 地址字符串<br>    {                                                //settings[Object]：AJAX 请求设置对象，其中所有选项都是可选的；jQuery中存在一个 AJAX 全局默认设置对象，若没有提供settings参数或者某选项值，则使用全局默认设置<br>        accepts:Map,                                        //[Object]，默认值取决于数据类型，将其内容类型发送到请求头，以告诉服务器什么样的响应会被接受返回<br>          ■async:true|false,                                    //[Boolean]，默认值true，表示异步请求；若需要发送同步请求，则应设置为false<br>          ■beforeSend:function(XMLHttpRequest){this;//调用本次AJAX请求时传递的options参数},    //[Function]，无默认，发送请求前被调用，传递当前 XMLHttpRequest 对象为唯一实参，★若该函数返回false则可以取消本次ajax请求<br>        cache:true|false,                                    //[Boolean]，默认值true（dataType为script和jsonp时默认为false），设置是否缓存该页面，true缓存，false不缓存<br>          ■complete:function(XMLHttpRequest,textStatus){this;//同上},                //[Function]，无默认，请求完成后被调用，传递当前 XHR 对象和一个描述本次已完成请求的状态的字符串（”success”/“error”/…）<br>        contents:Map,                                        //[Object]，无默认，一个以”{字符串:正则表达式}”配对的对象，用来确定jQuery将如何解析响应，给定其内容类型<br>          ■contentType:”…”,                                    //[String]，默认值”application/x-www-form-urlencoded”，发送信息至服务器时内容编码类型（请求头的Content-Type）<br>        context:{…},                                        //[Object]，无默认，用于设置Ajax相关回调函数的上下文——也就是说，让回调函数内this指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的options参数）<br>        converters:Map,                                        //[Object]，默认值{“* text”: window.String, “text html”: true, “text json”: jQuery.parseJSON, “text xml”: jQuery.parseXML}，一个数据类型对数据类型转换器的对象，每个转换器的值是一个函数，返回响应的转化值<br>        crossDomain:true|false,                                    //[Boolean]，默认值false，同域请求为false，跨域请求为true，如果你想强制跨域请求（如JSONP形式）同一域，设置crossDomain为true，这使得——服务器端重定向到另一个域<br>          ■data:…,                                        //[Object|String]，无默认，发送到服务器的数据，将自动转换为请求字符串格式；GET 请求中将附加在 URL 后；查看 processData 选项说明以禁止此自动转换，必须为 Key/Value 格式（JS对象|数组或form序列化参数”key1=value1&amp;key2=value2”）；如果为数组，jQuery 将自动为不同值对应同一个名称，如 {foo:[“bar1”, “bar2”]} 转换为 “&amp;foo=bar1&amp;foo=bar2”<br>          ■dataFilter:function(data,type){return data;},                        //[Function]，无默认，给 Ajax 返回的原始数据的进行预处理的函数，应提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的dataType参数，函数返回的值将由jQuery进一步处理<br>          ■dataType:”…”,                                        //[String]，无默认，预期服务器返回的数据类型，如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息（响应头Content-Type值）来智能判断；”xml”: 返回 XML 文档，可用 jQuery 处理；”html”: 返回纯文本 HTML 信息，包含的script标签会在插入DOM时执行；”script”: 返回纯文本 JavaScript 代码，不会自动缓存结果，除非设置了”cache”参数，★注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求(因为将使用DOM的script标签来加载)；”json”: 返回 JSON 数据 ；”jsonp”: JSONP 格式，使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；”text”: 返回纯文本字符串<br>          ■error:function(XMLHttpRequest,textStatus,errorThrown){this;//同上},            //[Function]，默认值自动判断(xml 或 html)，请求失败时被调用，应有以下三个形参：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象<br>        global:true|false,                                    //[Boolean]，默认值true，是否触发全局 AJAX 事件，设置为 false 将不会触发全局 AJAX 事件（ajaxStart|ajaxStop）<br>        headers:Map,                                        //[Object]，默认值{}，一个额外的{键:值}对映射到请求一起发送，此设置被设置之前 beforeSend 函数被调用，因此，消息头中的值设置可以覆盖 beforeSend 函数范围内的任何设置<br>        ifModified:true|false,                                    //[Boolean]，默认值false，true仅在服务器数据改变时获取新数据，使用 HTTP 包 Last-Modified 头信息判断<br>        isLocal:Map,                                        //[Object]，默认取决于当前位置协议<br>          □jsonp:”…”,                                        //[String]，无默认，在一个jsonp请求中重写提供回调函数名的键名；这个值用来替代在”callback=?”这种 GET 或 POST 请求中URL参数里的 “callback” 部分，比如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器<br>          □jsonpCallback:”…”,                                    //[String]，无默认，为jsonp请求指定一个回调函数名；这个值将用来取代jQuery自动生成的随机函数名，这主要用来让jQuery生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理；你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名<br>        mimeType:”…”,                                        //[String]，无默认，一个mime类型用来覆盖XHR的 MIME类型<br>        password:”…”,                                        //[String]，无默认，用于响应HTTP访问认证请求的密码<br>        processData:true|false,                                    //[Boolean]，默认值true，默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”；如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false<br>        scriptCharset:”…”,                                    //[String]，无默认，只有当请求时dataType为”jsonp”或”script”，并且type是”GET”才会用于强制修改charset；通常只在本地和远程的内容编码不同时使用<br>        statusCode:Map,                                        //[Object]，默认值{}，每组包括一个数值型的HTTP请求状态码和对应的函数对象，当响应时会调用相应状态码的处理函数；例如{404:function(){alert(…);}}，如果响应状态是404，将触发以下警报<br>          ■success:function(data,textStatus,jqXHR){this;//同上},                    //[Function|Array]，无默认，请求成功后被调用，参数：data 由服务器返回并根据dataType参数进行处理后的数据；textStatus 描述响应状态的字符串；还有 jqXHR（在jQuery 1.4.x中为XMLHttpRequest）对象；在jQuery 1.5中，成功设置可以接受一个函数数组，其中每个函数将被依次调用<br>        traditional:true|false,                                    //[Boolean]，无默认，如果你想要用传统的方式来序列化数据，那么就设置为true（请参考工具分类下面的jQuery.param 方法）<br>        timeout:N,                                        //[Number]，无默认，设置请求超时时间（毫秒），此设置将覆盖全局设置<br>          ■type|method:”GET”|”POST”,                                //[String]，默认值为”GET”，请求方式(“POST” 或 “GET”)；★注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持！！！<br>          ■url:”url”,                                        //[String]，默认值为当前页面地址，发送请求的地址<br>        username:”…”,                                        //[String]，无默认，用于响应HTTP访问认证请求的用户名<br>          □xhr:function(){return XMLHttpRequest;},                            //[Function]，默认在IE下提供一个 ActiveXObject 而其余 XMLHttpRequest对象；该函数必须返回一个 XMLHttpRequest 对象；用于重写或者提供一个增强的 XMLHttpRequest 对象（★这个参数在jQuery 1.3以前不可用）<br>        xhrFields:Map                                        //[Object]，无默认，”文件名:文件值”，在本机设置XHR对象<br>    });</p><p>②$.ajaxSetup()|jQuery.ajaxSetup()：最简单的情况下 $.ajax() 可以不带任何参数直接使用，但必须注意的是，这需要通过 $.ajaxSetup() 函数来提前进行参数选项的全局设置；<br>    jQuery.ajaxSetup([options]);                                    //[Object]，见$.ajax()的settings设置</p><p>③$.get()|jQuery.get()：这是一个简单的 GET 请求功能以取代复杂的 $.ajax()。请求成功时（success）可调用提供的回调函数；但如果需要在出错时（error）执行某函数，则使用 $.ajax()；<br>    jQuery.get(url, [data], [callback], [type]);                            //url:请求页面的URL地址，data:待发送的 Key/Value 参数，callback:success载入成功时回调函数，type:设置返回内容的格式，如’xml’, ‘html’, ‘script’, ‘json’, ‘text’, ‘_default’</p><p>  $.post()|jQuery.post()：这是一个简单的 POST 请求功能以取代复杂 $.ajax()。请求成功时（success）可调用提供的回调函数；但如果需要在出错时（error）执行某函数，则使用 $.ajax()；<br>    jQuery.post(url, [data], [callback], [type]);                            //同上</p><p>  jQuery对象.load()：载入远程 HTML 文件代码并插入至 DOM 中，默认使用 GET 方式|传递附加参数时自动转换为 POST 方式；<br>    $(“selector”).load(url, [data], [callback]);                            //url:待装入 HTML 路径，data:发送至服务器的 key/value 数据（在jQuery 1.3中也可以接受一个字符串了），callback:载入成功时回调函</p><p>④$.getJSON()|jQuery.getJSON()：通过 HTTP 的 GET 请求载入 JSON 数据；通过使用 JSONP 形式的回调函数来加载其他网域的JSON数据，如”myurl?callback=?”，jQuery 将自动替换 ? 为正确的函数名，以执行回调函数（★注意：此行以后的代码将在这个回调函数执行前执行！！！）<br>    jQuery.getJSON(url, [data], [callback]);                            //同上，同域采用XHR，跨域JSONP</p><p>  $.getScript()|jQuery.getScript()：通过 HTTP 的 GET 请求载入并执行一个 JavaScript 文件；<br>    jQuery.getScript(url, [callback]);</p><p>⑤jQuery对象.ajaxStart(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 开始时执行函数；<br>    $(document).ajaxStart(function(){…});                                //添加 全局的AJAX 响应事件</p><p>⑥jQuery对象.ajaxSend(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 发送前执行函数；<br>    $(document).ajaxSend(function(){…});                                //添加 全局的AJAX 响应事件</p><p>⑦jQuery对象.ajaxError(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 发生错误时执行函数；<br>    $(document).ajaxError(function(){…});                                //添加 全局的AJAX 响应事件</p><p>⑧jQuery对象.ajaxSuccess(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 成功时执行函数；<br>    $(document).ajaxSuccess(function(){…});                            //添加 全局的AJAX 响应事件</p><p>⑨jQuery对象.ajaxComplete(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 完成时执行函数；<br>    $(document).ajaxComplete(function(){…});                            //添加 全局的AJAX 响应事件</p><p>⑩jQuery对象.ajaxStop(callback)：添加一个 Ajax事件 处理程序，当（该DOM子树内有一个） AJAX请求 完成时执行函数；<br>    $(document).ajaxStop(function(){…});                                //添加 全局的AJAX 响应事件</p><p>★注意：只有通过 jQuery 发送的 AJAX请求 才能触发相应的 AJAX事件，而原生 JS 中的 AJAX请求 是无法触发相关机制的！！！<br>★注意：如果要注册 全局AJAX事件 的处理函数，则必须使用 document对象 的 jQuery包装来调用注册方法 ！！！</p><p>⒋Axios封装的AJAX：Axios 基于 Promise 对象来封装异步的 HTTP 请求服务，可以用于 浏览器端 或 node.js中；<br>    ·jQuery 中除了 AJAX 外还封装了大量的 DOM 操作方法，所以 AJAX 相关代码仅占极少的一部分；<br>    ·Vue框架 采用了避免用户直接使用 DOM 操作的设计，所以并不推荐使用 jQuery 来发送 AJAX请求；</p><pre><code>■特点： ·支持在浏览器中使用 XMLHttpRequest 来发送 AJAX请求；·支持在 Node.js 中发送 Http请求；·支持 Promise API接口；·拦截 请求 和 响应 ；·转换 请求 和 响应 的传输数据；·取消请求；·自动转换 JSON 格式数据；■安装及使用：    $ npm install axios                                    //通过 NPM 下载到本地    &lt;script src=&quot;/public/js/axios.min.js&quot;&gt;&lt;/script&gt;                        //发送同域请求，在全局范围内引入一个 axios 客户端的实例对象，还可以通过其上面绑定的方法来创建出新的 axios 实例对象    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;            //发送跨域请求，同上    &lt;script&gt;        Vue.prototype.$http = axios;                            //通常将 axios 的入口函数绑定到 Vue 的构造原型上，以方便 Vue 实例对象在方法内直接调用        const vm = new Vue({            el: &apos;#app&apos;,            data: {            },            methods:{                async getInfor(){                        //使用 async 函数和 await 来封装该 异步请求操作                    var data = await this.$http.get(...);                    ...                }            }        });    &lt;/script&gt;■接口API：  ◆axios(config);                                        //创建异步请求，返回一个 Promise 对象来接收响应数据    axios(url[, config]);                                    //创建异步请求，返回一个 Promise 对象来接收响应数据    请求配置        类型        描述                                        示例      →url            String        指定用于请求的服务器的URL                            url: &apos;/user&apos;      →method            String        发送请求时使用的请求方法，默认为&apos;get&apos;                        method: &apos;get&apos;      →baseURL            String        除非设置了绝对的&apos;url&apos;，否则将会以&apos;baseURL&apos;来作为&apos;url&apos;的开头            baseURL: &apos;https://some-domain.com/api/&apos;      →transformRequest    Function    允许在将请求数据发送到服务器之前通过设置的 转换函数 依次对其进行修改         transformRequest: [ function (data, headers){ return data; },...] ☆注：数组中的最后一个函数必须返回一个字符串、Buffer、ArrayBuffer、FormData或Stream的实例，并可以修改标题对象。      →transformResponse    Function    允许在响应数据传送到 then|catch 之前通过设置的 转换函数 依次进行修改        transformResponse: [ function (data) { return data; },...]      →headers            Object        设置要发送的自定义请求头                            headers: {&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;}      →params            Object        与请求一起发送的URL参数                                params: { ID: 12345 }    paramsSerializer    Function    负责序列化`params`的可选函数                            paramsSerializer: function(params){ return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;}) }      →data            Object        作为请求体被发送的数据                                data: { firstName: &apos;Fred&apos; }      →timeout            Number        指定请求超时之前的毫秒数                            timeout: 1000      →withCredentials        Boolean        指示跨域请求时是否需要使用凭证，默认false                    withCredentials ：false    adapter            Function    允许自定义处理请求，使测试更容易                        function(config){ ... }    auth            Object        应该使用 HTTP 基础验证，并提供凭据，使用`headers`设置`Authorization`        auth: { username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; }      →responseType        String        指示服务器将响应的数据类型，默认&apos;json&apos;                        responseType: &apos;json&apos;    onUploadProgress    Function    允许在这里处理上传的进度事件                            onUploadProgress: function(progressEvent){ ... }    onDownloadProgress    Function    允许在这里处理下载的进度事件                            onDownloadProgress: function(progressEvent){ ... }      →maxContentLength    Number        允许的http响应内容的最大尺寸                            maxContentLength: 2000    validateStatus        Function    定义对于给定的 HTTP响应状态码 是 resolve 还是 reject 此Promise；        validateStatus: function(status){ return status &gt;= 200 &amp;&amp; status &lt; 300; }                        如果`validateStatus`返回`true`(或者设置为 `null` 或 `undefined`)，Promise 将被 resolve；否则，Promise 将被 reject；          →maxRedirects        Number        定义了在node.js中follow的最大重定向次数，如果设置为0，则不会跟随重定向        maxRedirects: 5    httpAgent        Object        在 node.js 中用于定义在执行 http 时使用的自定义代理                httpAgent: new http.Agent({ keepAlive: true })    httpsAgent        Object        在 node.js 中用于定义在执行 https 时使用的自定义代理                httpsAgent: new https.Agent({ keepAlive: true })    proxy            Object        定义代理服务器的主机名和端口，使用 false 来禁用代理，忽略环境变量        proxy: {...}    cancelToken        CancelToken    指定用于取消请求的 Cancel Token                            cancelToken: new CancelToken(function(cancel){})    响应数据结构        类型        描述    data            Object        服务器提供的响应数据    status            Number        服务器响应的HTTP状态码    statusText        String        服务器响应的HTTP状态信息    headers            Object        服务器响应的响应头信息（名称全部转换为小写）    config            Object        为请求提供的`axios`配置信息    request            Object        产生这个响应的请求，在node.js（重定向）中，它是最后一个ClientRequest实例；在浏览器中，一个XMLHttpRequest实例；  ◆请求方法别名：为了方便操作 axios 中还为所有支持的请求类型提供了相应的 别名 方法，同样是封装了异步请求，返回一个 Promise 对象来接收响应数据；    axios.request(config);    axios.get(url[, config]);    axios.delete(url[, config]);    axios.head(url[, config]);    axios.options(url[, config]);    axios.post(url[, data[, config]]);    axios.put(url[, data[, config]]);    axios.patch(url[, data[, config]]);  ★注意：在使用别名方法时，不需要在 config 中指定 url、 method 或 data 属性！！！  ◆并发：处理并发请求的助手函数；    axios.all(iterable);    axios.spread(callback);    axios.all([getUserAccount(), getUserPermissions()])                        //返回值组成一个 Promise 对象的数组    .then(axios.spread(function (acct, perms) {        ...                                        // 两个请求现在都执行完成    }));  ◆创建实例：使用自定义配置新建一个 axios 实例；    axios.create([config]);  ◆配置的默认值/defaults：可以指定将被用在各个请求的配置默认值；    ◇全局的 axios 默认值：通过 axios.defaults 对象来设置相应的默认值；    ◇自定义实例的默认值：通过调用 axios.create({...}) 创建实例时设置配置的默认值；    ◇配置的优先顺序：所设的配置会以一个优先顺序进行合并，这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数（后者将优先于前者）；  ◆拦截器[回调函数]：可以在请求或响应被 then 或 catch 处理前拦截它们，并进行相应的处理；  ·添加 请求|响应 中的拦截器：    axios.interceptors.request.use(function (config) {                        //设置请求被发送前的拦截函数，接收当前请求的配置选项作为参数，并返回修改后的配置对象    // 在发送请求之前做些什么    return config;    }, function (error) {                                    //设置处理请求错误前拦截函数，接收错误对象，并将其封装成 Promise 对象后返回    // 对请求错误做些什么    return Promise.reject(error);    });    axios.interceptors.response.use(function (response) {                    //设置获得响应数据前拦截函数，接收原始的响应内容，并返回修改后的结果    // 对响应数据做点什么    return response;    }, function (error) {                                    //设置处理响应错误前拦截函数，接收错误对象，并封装 Promise 返回    // 对响应错误做点什么    return Promise.reject(error);    });  ·移除拦截器：    var myInterceptor = axios.interceptors.request.use(function () {/*...*/});            //保存返回值，用以移除拦截器    axios.interceptors.request.eject(myInterceptor);  ·为自定义 axios 实例添加拦截器：    var instance = axios.create();    instance.interceptors.request.use(function () {/*...*/});</code></pre><p>⑹JSONP（JSON with Padding）|JSON包裹：JSON编码数据的一种“使用模式/提取方式”，可用于解决主流浏览器的 跨域 数据访问及数据提取问题；</p><p>★同源策略（Same Origin Policy）：是由 Netscape 提出的一个著名的安全策略，也是★浏览器★最核心也最基本的安全功能——如果缺少了同源策略，则浏览器的正常功能可能都会受到影响，甚至可以说 Web 是构建<br>                  在同源策略的基础之上，而浏览器只是针对同源策略的一种实现；<br>    ·所谓同源是指——协议、域名、端口三者都必须完全相同的情况，否则就被称为——跨源——当一个源从与该源本身所在的服务器不同的域或端口请求一个资源时，该源就会发起一个 跨域HTTP 请求；<br>    ·出于安全原因，浏览器会限制从★脚本内★发起的 跨源HTTP 请求，例如：XMLHttpRequest和Fetch API遵循同源策略——这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求的HTTP资源，除非使用CORS头文件；<br>    ·页面内的★普通标签元素★可以通过 href 或 src 属性正常发送 跨源HTTP 请求而不受 同源策略 影响；<br>    ·例如，一个浏览器的两个tab页中分别打开了来自 百度 和 谷歌 的页面时，浏览器的 百度 tab页中若要执行一个脚本请求，则会先检查这个脚本请求的是哪个页面——即检查该请求与当前页面是否同源：<br>        -只有和 百度 同源的请求才会被执行；<br>        -如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常（如下），提示拒绝访问；<br>         XMLHttpRequest cannot load …. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘…’ is therefore not allowed access.<br>    ·现在所有支持 JavaScript 的浏览器都会使用这个策略；<br>★注意：跨域并非不一定是浏览器限制了发起跨域请求，而也可能是跨域请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！！！<br>★注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例！！！</p><p>⒈JSONP原理：<br>    ·由于同源策略的限制，我们无法在脚本内利用 XHR对象 发起 跨域 请求来获得某些其他服务器上的数据（这是浏览器本身的一种安全机制，除非服务器端设置了CORS[兼容性]，否则就会阻止 跨域请求）；<br>    ·但是可以利用其他非脚本方式——如带href、src属性的标签——发送的 跨域请求 来获得这些数据，问题只在于获取方式——★如何将数据传递到脚本内★；<br>    ·因为不是利用传统的 XHR对象 来获取的数据，所以脚本内并没有相关的 接口 可以直接获取服务器端传递的响应内容；<br>    ·在JSONP方式中，主要利用 JavaScript代码 本身的执行来将数据获取至脚本中：<br>        ①利用script标签元素来发起 跨域请求——设置script标签的 src 属性来请求 非同源 服务器上的动态页面；<br>        ②通过这种方式获得的响应内容会被作为 JavaScript代码 而在浏览器端执行；<br>        ③服务器端需要将数据组织成 JSON格式 来传输，这样在浏览器执行响应内容时，这些数据就会被作为JS中的数组或对象来处理；<br>        ④服务器端再将这些 JSON格式 的数据以一个 函数调用 的形式包裹起来，就可以在作为JS代码执行之时，将这些数据以 实参对象 的形式传递至此执行函数之中；<br>        ⑤所以，需要先在JS中设计一个 全局函数 （window.jsonp(data)）以作为接收响应数据的“包裹”，并在发送 跨域请求 时传递该函数的 全局名称（url?callback=jsonp）；<br>        ⑥服务器端获取该函数名$_GET[‘callback’]并用以包裹 JSON数据，再将这些内容作为 JS代码 全部响应给浏览器去执行（Content-Type:application/javascript）；</p><p>⒉JSONP封装：<br>    function jsonp(url, data, callback){<br>        //参数格式化<br>        var para = [];<br>        for(var k in data){<br>            para.push(k + ‘=’ + data[k]);<br>        }<br>        para = para.join(‘&amp;’);</p><pre><code>    var padding = &apos;jsonp&apos; + Math.random().toString().slice(2) + +(new Date());    //生成随机的函数名    var script = document.createElement(&apos;script&apos;);    script.src = url + &apos;?&apos; + para + &apos;&amp;callback=&apos; + padding;    window[padding] = function(data){        callback(data);        document.body.removeChild(script);                delete window[padding];    };    document.body.appendChild(script);                        //当script标签被加载到页面上时，就会发送出该跨域请求        }服务器端：$data = json_encode(...);$callback = $_GET[&apos;callback&apos;];echo &quot;$callback($data);&quot;;</code></pre><p>⒊jQuery封装的JSONP：<br>    ·同样利用$.ajax()方法，只要设置参数选项 dataType 为 ‘jsonp’ 即可（dataType设置通常用来告诉jQuery内部如何处理从服务器端获得的原始数据responseText，如设置’json’则会自动调用JSON.parse方法处理该数据后传递给success回调函数）；<br>    ·其他工作jQuery内部自动完成——例如，创建script标签及属性设置、随机名的全局函数；</p><p>⒋Vue-resource封装的JSONP：为 vue.js 提供了使用 XMLHttpRequest 或 JSONP 方式进行 Web请求 和 处理响应 的服务；</p><pre><code>■特点：    ·vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多；    ·和 vue.js 一样，vue-resource 除了不支持 IE9 以下的浏览器，其他主流的浏览器都支持；    ·支持 Promise API 和 URI Templates；    ·支持拦截器；■安装：    $ npm install vue-resource                        //通过 NPM 安装到本地    &lt;script src=&quot;/public/js/vue.js&quot;&gt;&lt;/script&gt;                //首先需要引入 vue.js    &lt;script src=&quot;/public/js/vue-resource.js&quot;&gt;&lt;/script&gt;            //通过 同域请求 引入    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-resource@1.3.5&quot;&gt;&lt;/script&gt;    //通过 跨域请求 引入★注意：注意加载顺序，该插件需要依赖 vue.js ！！！■使用：    ·通过 全局 的 Vue.http 来调用 API；    ·通过 Vue实例 的 this.$http 调用 API；★注意：所有请求方法的调用都会返回一个 Promise 对象来处理响应，其成功或失败时都会接收到一个封装好的 response 对象，此外，Vue实例 将会被自动绑定到所有函数回调的 this 中！！！■API接口：·请求方法：    get(url, [options]);                //6种标准的HTTP方法    head(url, [options]);                    delete(url, [options]);                    post(url, [body], [options]);                put(url, [body], [options]);                patch(url, [body], [options]);                jsonp(url, [options]);                //jsonp跨域请求方法·Options 对象：                        参数            类型            描述    url            string            请求的URL    method            string            请求的HTTP方法，如&apos;GET&apos;、&apos;POST&apos;或其他 HTTP 方法    body            Object, FormDatastring    请求体内容    params            Object            请求的URL参数对象    headers            Object            请求头数据    timeout            number            单位为毫秒的请求超时时间 (0 表示无超时时间)    before            function(request)    请求发送前的处理函数，类似于 jQuery 的 beforeSend 函数    progress        function(event)        ProgressEvent回调处理函数    credientials        boolean            表示跨域请求时是否需要使用凭证    emulateHTTP        boolean            发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的X-HTTP-Method-Override    emulateJSON        boolean            将request body以application/x-www-form-urlencoded content type发送·response 对象：    方法            类型            描述    text()            string            以 string 形式返回 response body    json()            Object            以 JSON对象 形式返回 response body    blob()            Blob            以 二进制 形式返回 response body    属性            类型            描述    ok            boolean            响应的HTTP状态码在200~299之间时，该属性为true    status            number            响应的HTTP状态码    statusText        string            响应的状态文本    headers            Object            响应头■拦截器Inteceptor：使用 拦截器 可以在 请求发送前 和 收到响应后 做一些处理；    Vue.http.interceptors.push((request, next) =&gt; {        // ...        // 请求发送前的处理逻辑        // ...        next((response) =&gt; {            // ...            // 请求发送后的处理逻辑            // ...            // 根据请求的状态，response参数会自动返回给 successCallback 或 errorCallback            return response;        });    });</code></pre><p>⑺CORS（Cross-Origin Resource Sharing）跨域资源共享：跨域资源共享(CORS)机制允许 Web 应用★服务器★进行跨域访问控制，从而使跨域数据传输得以安全进行；<br>                             浏览器支持在 API 容器中（例如：XMLHttpRequest 或 Fetch）使用 CORS，以降低跨域 HTTP 请求所带来的风险。<br>    常用方式：<br>    添加固定响应头：<br>    Access-Control-Allow-Origin: *                            //★告知浏览器★允许所有源发送的跨域请求<br>    Access-Control-Allow-Origin: <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a>                    //★告知浏览器★允许特定源发送的跨域请求<br>    判断+添加响应头：<br>    if(in_array(url, allow_origins)){                        //先判断该发起源是否在被允许跨域的范围内，若存在则设置相应的响应头<br>        header(‘Access-Control-Allow-Origin: url’);<br>    }</p><p>  COSS（Cross-Origin Sharing Standard）跨域资源共享标准：<br>    ◆COSS 新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些<br>      MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（Preflight Request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请<br>      求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）；<br>        ■HTTP 响应首部字段<br>          ◇Access-Control-Allow-Origin——响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：<br>            Access-Control-Allow-Origin: <origin> | <em>            //<origin> 参数的值指定了允许访问该资源的外域 URI；对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符“</origin></em>”，表示允许来自所有域的请求<br>            Access-Control-Allow-Origin: <a href="http://mozilla.com" target="_blank" rel="noopener">http://mozilla.com</a>            //示例：将允许来自 <a href="http://mozilla.com" target="_blank" rel="noopener">http://mozilla.com</a> 的请求<br>          ★注意：如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin ——这将告诉客户端，服务器对不同的源站返回不同的内容！！</origin></p><pre><code>      ◇Access-Control-Expose-Headers：★注意★在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头——Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头！！！        Access-Control-Expose-Headers                    //让服务器把允许浏览器访问的头放入该白名单        Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header            //这样浏览器就能够通过 getResponseHeader 访问 X-My-Custom-Header 和 X-Another-Custom-Header 响应头了！      ◇Access-Control-Max-Age：Access-Control-Max-Age 头指定了 preflight 请求的结果能够被缓存多久；        Access-Control-Max-Age: &lt;delta-seconds&gt;                //delta-seconds 参数表示 preflight 请求的结果在多少秒内有效。      ◇Access-Control-Allow-Credentials：Access-Control-Allow-Credentials 头指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容；当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用credentials；      ★注意：简单 GET 请求不会被预检。如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页！！！        Access-Control-Allow-Credentials: true                //上文已经讨论了附带身份凭证的请求      ◇Access-Control-Allow-Methods：Access-Control-Allow-Methods 首部字段用于预检请求的响应，其指明了实际请求所允许使用的 HTTP 方法；        Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*      ◇Access-Control-Allow-Headers：Access-Control-Allow-Headers 首部字段用于预检请求的响应，其指明了实际请求中允许携带的首部字段；        Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*    ■HTTP 请求首部字段    ★注意：这些首部字段无须手动设置。——当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪！！！      ◇Origin：Origin 首部字段表明预检请求或实际请求的源站；        Origin: &lt;origin&gt;                        //origin 参数的值为源站 URI，它不包含任何路径信息，只是服务器名称    ★注意：有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时！！！    ★注意：不管是否为跨域请求，ORIGIN 字段总是被发送！！！      ◇Access-Control-Request-Method：Access-Control-Request-Method 首部字段用于预检请求，其作用是，将实际请求所使用的 HTTP 方法告诉服务器；        Access-Control-Request-Method: &lt;method&gt;      ◇Access-Control-Request-Headers：Access-Control-Request-Headers 首部字段用于预检请求，其作用是，将实际请求所携带的首部字段告诉服务器；        Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*◆某些请求不会触发 CORS 预检请求，这样的请求称为“简单请求”（请注意，该术语并不属于 Fetch 规范——其中定义了 CORS），若请求满足所有下述条件，则该请求可视为“简单请求”：    使用下列方法之一：        GET        HEAD        POST    Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：        Accept        Accept-Language        Content-Language        Content-Type （需要注意额外的限制）        DPR        Downlink        Save-Data        Viewport-Width        Width    Content-Type 的值仅限于下列三者之一：        text/plain        multipart/form-data        application/x-www-form-urlencoded◆COSS 允许在下列场景中使用跨域 HTTP 请求——    ·前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求；    ·Web 字体 (CSS 中通过 @font-face 使用跨域字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用；    ·WebGL 贴图；    ·使用 drawImage 将 Images/video 画面绘制到 canvas；    ·样式表（使用 CSSOM）；    ·Scripts (未处理的异常)；</code></pre><p>⑻H5C3（HTML5 &amp; CSS3） 新特性|API：</p><p>⒈网络状态检测：<br>    新增 浏览器|window 事件：<br>    online        在线事件，当浏览器从离线状态转入在线状态时触发该事件（包括进入局域网等非互联网络）；<br>    offline        离线事件，当浏览器从在线状态转入离线状态时触发该事件（包括离开局域网等非互联网络）；<br>    window.ononline = function(event){…};<br>    window.addEventListener(‘online’, function(event){…});<br>    window.onoffline = function(event){…};<br>    window.addEventListener(‘offline’, function(event){…});</p><p>⒉多媒体控件API[video|audio]：<br>  ■JS属性：<br>    ·duration        返回当前 音频/视频 的时间长度（以秒计）；<br>    ·paused        返回 音频/视频 播放是否已暂停；<br>    ·currentTime        设置或返回 音频/视频 中的当前播放位置（时间，以秒计）；<br>    ·ended            返回 音频/视频 的播放是否已经结束；</p><p>  ■JS事件：<br>    ·canplay        当文件准备就绪并可以播放时触发该事件（缓冲已足够开始时）；<br>★注意：如果在 window.onload 时才设置 canplay 事件的处理函数是不会直接执行的，原因是 canplay 的含义是“是否能播放”，其触发条件是——视频有总时间的变化；<br>    当 video元素 刚开始加载的时候其 duration 为 NaN，而当请求到服务器的视频资源之后，duration 则变成此视频文件的总时间，此时就会触发一次 canplay 事件；<br>    但是如果在 window.onload 时才设置 canplay 的处理函数，若此时资源加载已经完成过了，就自然不会有总时间的变化或触发 canplay 事件！！！<br>    ·timeupdate        当播放位置 currentTime 改变时触发该事件（如正常播放过程中，或当用户使用跳转或快进操作修改当前播放位置时）；<br>    ·ended            当被播放的媒介已到达其结尾时触发该事件（可发送类似“感谢观看”之类的消息）；</p><p>  ■JS方法：<br>    ·play()        开始播放；<br>    ·pause()        暂停播放；<br>    ·requestFullScreen()    全屏播放（有兼容问题），如果当前未全屏则发出请求进入全屏（异步，所以可以和退出全屏同时调用，以切换全屏状态）；<br>      webkitRequestFullScreen()    （私有方法）；<br>    ·exitFullScreen()    退出全屏（有兼容问题），如果当前已全屏则发出请求退出全屏（异步，所以可以和进入全屏同时调用，以切换全屏状态）；<br>      webkitExitFullScreen()    （私有方法）；</p><p>  □其他：<br>    ◆视频全屏时去除掉默认的控制条：<br>    video::-webkit-media-controls-enclosure {<br>        /<em> 禁用播放器控制栏的样式 </em>/<br>        display: none !important;<br>    }<br>    ◆视频全屏时显示自定义的控制条：<br>    z-index: [2147483647,+∞);<br>★注意：在 CSS 中设置属性时，可以使用 calc() 来进行简单的四则运算，并用其结果来设置属性值——margin-top:calc((30px - 10px)/2);</p><p>⒊WebStorage：所谓的 WebStorage 指的是 客户端存储，在这里特指的是 客户端浏览器 存储，比如在网站上自动登陆这些功能，其实就是把一些少量的数据存储在浏览器等客户端中，这样可以减少没必要的请求到服务器，<br>          降低服务器的压力，给用户提供更好的体验；</p><p>◎WebStorage的方式◎<br>  ■cookie：<br>    ·广泛使用，存储量4kb左右；<br>    ·会在浏览器和服务器间传递，一般由服务器端创建，可以设置存储时间(默认和session一样)；<br>    ·cookie不容易操作，jquery.cookie.js插件；</p><p>  ■sessionStorage：<br>    □特点：<br>    ·H5新增，存储量5M左右；<br>    ·只会在浏览器存储数据（浏览器的内存中），只会由浏览器端创建；<br>    ·存储时间是打开浏览器开始——关闭浏览器消失；<br>    ·方法简洁明了，容易操作；<br>    □方法：<br>    ·window.sessionStorage.setItem(key,value);        添加数据；<br>    ·window.sessionStorage.getItem(key);            获取数据；<br>    ·window.sessionStorage.removeItem(key);        移除数据；<br>    ·window.sessionStorage.clear();            清除数据；<br>    ·window.sessionStorage.key(n从0开始);            获取key；<br>    □应用场景：存储一些少量临时的数据(比较少用)；</p><p>★注意：sessionStorage 与 session 不同：<br>    ◇session 是服务器端的数据存储机制，其数据直接存储在服务器的 内存 或 session 文件中，客户端无法直接获取这些信息；而 sessionStorage 则是 浏览器 里的一种新型数据存储机制，其数据直接存储<br>    在 客户端浏览器 中，可以被用户直接获取；<br>    ◇session 中存储的数据可以长久地存放在服务器上；而 sessionStorage 中存储的数据则会在 当前会话 结束时被释放；</p><p>  ■localStorage：<br>    □特点：<br>    ·H5新增，存储量5M左右；<br>    ·只会在浏览器存储数据(存储在硬盘中)，只会由浏览器端创建；<br>    ·永久存储除非手动删除；<br>    ·方法简介明了，容易操作；<br>    □方法：<br>    ·window.localStorage.setItem(key,value);        添加数据；<br>    ·window.localStorage.getItem(key);            获取数据；<br>    ·window.localStorage.removeItem(key);            移除数据；<br>    ·window.localStorage.clear();                清除数据；<br>    ·window.localStorage.key(n从0开始);            获取key；<br>★注意：WebStorage中只能存储普通字符串（常用json格式）！！！</p><p>⒋HTML 拖放接口（Drag and Drop API）：<br>  ■拖拽元素：被鼠标点击并 拖拽 移动的元素；<br>  ★注意：除了<img>和<a>标签之外，其他所有标签若想要成为可被拖拽的元素，都必须要给该标签设置属性 draggable = “true”；<br>    ◆拖拽事件：<br>    ·dragstart：当用户开始拖动一个“有效的” 元素 或者“可选择的” 文本 的时候，该元素上的 dragstart 事件就会被触发；<br>    ·drag：当用户完成 dragstart 之后，并持续地拖动该 元素|选择文本 的过程中，该元素上的 drag 事件会一直不停地被触发；<br>    ·dragend：当用户结束拖动一个被拖拽 元素|文本 的时候——鼠标弹起释放，该元素上的 dragend 事件就会被触发；</a></p><p>  ■目标元素：拖拽元素被拖拽到的 目标位置 上的元素；<br>    ◆拖拽事件：<br>    ·dragenter：当用户拖动一个 元素|文本|文件 的状态下，（鼠标）进入该目标元素边缘范围的时候，该目标元素上的 dragenter 事件就会被触发；<br>    ·dragover：当用户拖动一个 元素|文本|文件 的状态下，（鼠标）在该目标元素的范围内悬停，该目标元素上的 dragover 事件就会 不断地 被触发；<br>          window.addEventListener(“dragover”, function (event) {<br>            event.preventDefault();<br>            …<br>         }<br>  ★注意：浏览器的 dragover 事件流中都有一个默认行为——在每次 dragover 事件流传播结束后，若有释放拖拽文件到任意元素上时，都会先在浏览器中打开所释放的文件，因而无法触发该元素上的drop事件；<br>      若在某次 dragover 事件流过程中有 任意元素 在自身的处理函数中阻止了此次的默认行为时（即执行了阻止方法），都能在该次 dragover 事件流结束后释放拖拽文件时禁止直接打开行为——即没有跳转，故能够触发被释放文件的元素上的 drop 事件！！<br>  ☆注意：dragenter|dragover|dragleave|drop 都会冒泡，所以只需要在顶层的 window 中阻止每次 dragover 的默认行为即可，不需要在每个目标元素上分别去阻止！！！<br>    ·dragleave：当用户拖动一个 元素|文本|文件 的状态下，（鼠标）离开该目标元素边缘范围的时候，该目标元素上的 dragleave 事件就会被触发；<br>    ◆释放事件：<br>    ·drop：当用户拖动一个 元素|文本|文件 ，并将其释放到一个 有效的 目标元素时，该目标元素上的 drop 事件就会被触发；<br>          targetArea.addEventListener(“drop”, function (event) {<br>            event.preventDefault();<br>            …<br>          }<br>  ★注意：浏览器的 drop 事件流中同样拥有一个默认行为——在每次 drop 事件流结束后，浏览器会打开所释放的文件——发生页面跳转，所以需要再次阻止一次默认行为！！！</p><p>  ■拖拽事件对象：<br>    ◆dataTransfer属性：DataTransfer类型对象，用于保存拖放操作期间正在拖动的数据及拖动事件的状态，例如拖动的类型，拖动的数据以及每个拖动项目的类型；<br>    ·event.dataTransfer.dropEffect                获取或设置当前选定的拖放操作的类型，并能控制在拖放操作期间给用户的“光标”反馈，该值必须是none|copy|link|move；<br>    ·event.dataTransfer.effectAllowed            定义所有被允许的操作类型，该值必须是none|copy|copyLink|copyMove|link|linkMove|move|all|uninitialized；<br>    ★注意：除了 dragstart 事件外，在其他事件中设置 effectAllowed 属性的值将不会有任何作用，所以该属性必须在 dragstart 事件发生时被设置好！！！<br>    ·event.dataTransfer.files                包含数据传输中可用的所有本地文件的列表，如果拖动操作不涉及拖动文件，则此属性为空列表；<br>    ·event.dataTransfer.items                一个 DataTransferItemList 类型对象，它是所有（DataTransferItem类型）拖拽数据的列表；<br>    ·event.dataTransfer.types                一个 string 数组，提供在 dragstart 事件中 setData() 方法设置的传递数据的格式 type ；<br>    ·event.dataTransfer.setData(type,data)            设置一个给定类型 type 的数据 data ，如果该类型的数据不存在，则在最后添加，以使类型列表中的最后一项成为新的格式；如果该类型的数据已经存在，则将现有数据替换到相同的位置；<br>    ·event.dataTransfer.getData(type)            检索给定类型 type 的对应数据，如果该类型的数据不存在或者数据传输不包含数据，则返回空字符串””；<br>    ·event.dataTransfer.clearData([type])            删除与给定类型 type 相关的数据，类型参数是可选的——如果类型 type 为 “” 空或 未指定 ，则删除与所有类型关联的数据；如果指定类型的数据不存在，或者数据传输不包含数据，则此方法将不起作用；<br>    ·event.dataTransfer.setDragImage(img,Xoffset,Yoffset)    发生拖动时，会从拖动目标（dragstart事件的触发元素）生成半透明图像，并在拖动过程中跟随鼠标指针；这个图像是自动创建的，所以你不需要自己创建它，但是，如果需要自定义图像，则可以使用 DataTransfer.setDragImage() 方法来设置要使用的自定义图像；</p><p>⒌文件读取 API：<br>  ■FileReader 对象：FileReader 类型的实例对象允许 Web应用程序 异步 读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，可使用 File 或用 Blob 对象指定要读取的文件或数据；<br>    ◆构造函数：<br>    var fr = new FileReader();<br>    ◆FileReader 实例对象的属性及方法：<br>    ·FileReader.prototype.error                一个 DOMException 对象，代表在读取文件中出现的错误；<br>    ·FileReader.prototype.readyState            一个表示 FileReader 状态的数字，0 EMPTY 尚未加载任何数据，1 LOADING 数据正在加载，2 DONE 整个读取请求已完成；<br>    ·FileReader.prototype.result                文件的内容，该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作；<br>    ·FileReader.prototype.onabort                abort事件的处理程序，每当读取操作中止时，都会触发此事件；<br>    ·FileReader.prototype.onerror                error事件的处理程序，每次读取操作遇到错误时都会触发此事件；<br>    ·FileReader.prototype.onload                load事件的处理程序，每次读取操作成功完成时触发该事件；<br>    ·FileReader.prototype.onloadstart            loadstart事件的处理程序，每次阅读开始时都会触发此事件；<br>    ·FileReader.prototype.onloadend            loadend事件的处理程序，每次读取操作完成（成功或失败）都会触发此事件；<br>    ·FileReader.prototype.onprogress            progress事件的处理程序，阅读Blob内容时触发此事件；<br>    ·FileReader.prototype.abort()                中止读取操作，函数返回后，readyState会变为DONE；<br>    ·FileReader.prototype.readAsArrayBuffer(file)        开始读取指定Blob的内容，一旦完成，result属性包含一个ArrayBuffer表示文件的数据；<br>    ·FileReader.prototype.readAsBinaryString(file)        开始读取指定Blob的内容，一旦完成，result属性包含文件中的原始二进制数据作为字符串；<br>    ·FileReader.prototype.readAsDataURL(file)        开始读取指定Blob的内容，一旦完成，result属性包含一个代表文件数据的data:URL；<br>    ·FileReader.prototype.readAsText(file)            开始读取指定Blob的内容，一旦完成，该result属性包含文件的内容作为文本字符串；<br>  ★注意：以上读取的文件对象可以从用户选择上传文件所使用的 <input> 元素的 files 属性（ FileList 类型）中获取，或从拖放操作中的 DataTransfer 对象的 files 属性或从 mozGetAsFile() API上的 返回的对象中获得 HTMLCanvasElement！！！<br>    ◆使用 FileReader 的实例对象读取文件的方法（异步）：<br>    ·准备读图片：<br>    fr.readAsDataURL(file);                //result属性中将包含一个data:URL格式的字符串以表示所读取文件的内容；<br>    ·准备读文本：<br>    fr.readAsText(file);                //result属性中将包含一个字符串以表示所读取的文件内容；<br>    ·等待读取操作完成(异步事件)：<br>    fr.onload = function(event){…}        //当读取操作成功完成时调用；<br>    ·通过event.result属性获取文件内容：<br>    console.log(this.result);            //如果调用readAsText()方法，获取的是——一段纯文本字符串；<br>    console.log(this.result);            //如果调用readAsDataURL()方法，获取的是——一段base64编码的URL，该字符串可以直接当作url使用，并且其中包含了图片的全部编码信息；</p><p>⒍地理定位 API：<br>  ■Geolocation ：可以使得 Web 应用程序获得用户提供的地理位置信息；<br>  ☆注：地理定位是隐私信息，所以获取地理定位信息的时候，浏览器会询问你是否允许——如果不允许，那么就禁止，否则允许；<br>      ◇地理定位方式：<br>        ·GPS定位        特别精确，但是花的时间比较长；<br>        ·手机信号(4G)定位    非常精确，安卓可以，iOS禁止权限；<br>        ·Wifi定位        比较精确，在无网络地区比较难以实现；<br>        ·浏览器定位        非常不精确；<br>        ·IP定位        最不精确；<br>      ◆获取一次地理位置的方法(回调)：<br>    window.navigator.geolocation.getCurrentPosition(成功时的回调,失败时的回调,参数设置);<br>    window.navigator.geolocation.getCurrentPosition(function success(position){<br>            //position.coords{<br>            //latitude        纬度，例如latitude:23.13188<br>            //longitude        经度，例如longitude:113.421895<br>            //altitude        高度(海拔)<br>            //accuracy        (位置)精确度<br>            //altitude Accuracy    (海拔高度)精确度<br>            //heading        行进方向<br>            //speed            地面速度<br>            //}<br>    }, function fail(error){<br>            // erroe.code:<br>            // 0            不包括其他错误编号中的错误<br>            // 1            用户拒绝浏览器获取位置信息<br>            // 2            尝试获取用户信息，但失败了<br>            // 3            设置了timeout值，获取位置超时了<br>    }, options);<br>            //{<br>            //enableHighAcuracy    更精确的查找，默认false<br>            //timeout        获取位置允许最长时间，默认infinity，单位是毫秒<br>            //}<br>      ◆实时获取地理位置的方法(回调)：<br>    window.navigator.geolocation.watchPosition(成功时的回调,失败时的回调,参数设置);<br>    var watchID = window.navigator.geolocation.watchPosition(function(){},function(){},options);<br>    navigator.geolocation.clearWatch(watchID);</p><p>⒎Canvas 元素：<canvas> 元素在 HTML5 中被标准化，不过 IE9 之前的浏览器并不支持 <canvas> 元素；<br>    ·<canvas>元素自身是没有任何外观的，但是它在文档中创建了一个画板，同时还提供了很多强大的绘制客户端 JavaScript 的API；<br>    ·<canvas>元素和 SVG 之间一个重要的区别是——使用 canvas 来绘制图形是通过调用它提供的方法，而使用 SVG 绘制图形是通过构建一棵 XML 元素树来实现的；<br>    ·<canvas>元素的绘制 API 是基于 JavaScript 的，<canvas> 本身不能绘图，只能使用 JavaScript 来完成绘图；</canvas></canvas></canvas></canvas></canvas></canvas></p><p>  ■布置画布元素：<br>    <canvas width="600" height="400"> 您的浏览器版本不支持Canvas,请升级您的浏览器</canvas><br>    //如果浏览器不支持 canvas 标签，那么就会将其解释为 div 标签，因此常常在canvas中嵌入文本,以提示用户去升级浏览器<br>    //canvas元素的默认 HTML 宽高属性为：width = “300”，height = “150”<br>    //canvas元素是根据其 HTML 标签中的 width 和 height 属性来决定其中的逻辑像素点个数<br>    //CSS中虽然可以改变 canvas 元素的大小，但是却无法改变其中的像素个数——即使用CSS设置canvas的宽高会造成其中像素点的放大或缩小以及图像扭曲<br>    //所以不要使用CSS的方式设置宽高，应该使用HTML属性width|height</p><p>  ■画布栅格及坐标空间：canvas元素默认被网格所覆盖，通常来说网格中的一个单元相当于canvas元素中的一像素；<br>            栅格的原点为左上角(0,0)，所有元素的位置都相对于原点定位(x,y)；</p><p>  ■画布绘制 API：大部分的绘制 API 都不是在 <canvas> 元素自身的对象上定义的，而是定义在一个“绘制上下文”对象上；<br>    ◆CanvasRenderingContext2D 类型上下文：<br>        var context = canvas.getContext(‘2d’);                        //获得一个CanvasRenderingContext2D 类型的渲染对象，使用该对象上的方法便可以在画布上绘制二维图形</canvas></p><pre><code>·绘制路径：图形的基本元素是路径——路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合；一个路径(Path)，甚至一个子路径(线Line、弧Arc等)，都是闭合的；        使用路径绘制图形需要一些特定的步骤：        1.首先，你需要创建路径起始点；        2.然后你使用画图命令去画出路径；        3.之后你把路径封闭；        4.一旦路径生成，你就能通过描边或填充路径区域来渲染图形；    context.beginPath();                                //新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径    context.closePath();                                //闭合路径之后图形绘制命令又重新指向到上下文中    context.stroke();                                //通过线条来绘制图形轮廓    context.fill();                                    //通过填充路径的内容区域生成实心的图形★注意：本质上，路径是由很多子路径构成，而这些子路径都是在一个列表中——所有的子路径（线、弧形等等）构成图形；    而每次这个beginPath()方法被调用之后，子路径列表就会清空重置，然后就可以重新绘制新的图形！！！★注意：当你调用fill()函数时，所有没有闭合的形状都会自动被当作已闭合（即连接当前位置到最初起点），所以不需要调用closePath()函数，但是调用stroke()时不会自动闭合！！！·移动笔触：    context.moveTo(x, y);                                //将笔触移动到指定的坐标x以及y上，这个函数实际上并不能画出任何东西·绘制直线：    context.lineTo(x, y);                                //绘制一条从当前位置到指定x以及y位置的直线·绘制圆弧|圆：    context.arc(x, y, radius, startAngle, endAngle, anticlockwise);            //画一个以(x,y)为圆心、以 radius 为半径、从 startAngle 开始到 endAngle 结束的圆弧|圆，并按照 anticlockwise 给定的方向（默认为顺时针）来生成（默认自动连接当前位置与该圆弧的起点）    context.arcTo(x1,y1,x2,y2,radium);                        //根据给定的控制点（当前位置和P1、P1和P2）连接两条直线作为切线，以半径 radium 画一段圆弧，该圆弧从一个切点到另一个切点（默认自动连接当前位置与该圆弧的第一个切点）★注意：arc()函数中的角度单位是 弧度，而不是度数——角度与弧度制转换的 JS 表达式：radians=(Math.PI/180)*degree！！！·绘制矩形（需路径）；    context.rect(x, y, width, height);                        //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形★注意：当该方法执行的时候，moveTo()方法自动设置坐标参数(0,0)。也就是说，当前笔触自动重置回默认坐标！！！·绘制原生矩形（不需路径）：    context.fillRect(x, y, width, height);                        //绘制一个填充的矩形    context.strokeRect(x, y, width, height);                    //绘制一个矩形的边框    context.clearRect(x, y, width, height);                        //清除指定矩形区域，让清除部分完全透明□Path2D 对象：Path2D()方法会返回一个新初始化的 Path2D对象，用来缓存或记录绘画命令；           可以将某一个路径作为参数传递，以创建一个它的副本；或者将一个包含SVG path数据的字符串作为变量来进行初始化；           所有的路径方法比如moveTo, rect, arc或quadraticCurveTo等，都可以在Path2D中使用；    var path2D = new Path2D();                            //空的Path对象    var path2D = new Path2D(path);                            //克隆Path对象    var path2D = new Path2D(string);                        //从SVG建立Path对象    path2D.addPath(path [, transform])​;                        //添加了一条路径到当前路径（可能添加了一个变换矩阵）</code></pre><p>  ■添加样式和颜色：<br>    ◆色彩 Colors：<br>        context.fillStyle = color || linearGradient || radialGradient;            //设置图形的填充颜色，可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象，默认情况下，线条和填充颜色都是黑色#000000<br>        context.strokeStyle = color|| linearGradient || radialGradient;            //设置图形轮廓的颜色，可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象，默认情况下，线条和填充颜色都是黑色#000000</p><pre><code>·透明度 Alpha：    globalAlpha = transparencyValue;                        //该属性将影响到 canvas 里所有图形的透明度，有效的值范围是(0.0)完全透明到(1.0)完全不透明，默认是 1.0·渐变 Gradients：    var linearGradient = context.createLinearGradient(x1, y1, x2, y2);        //createLinearGradient()方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)，起点与终点两端外的部分是纯色（与该渐变方向垂直的线上都是同一颜色）    linearGradient.addColorStop(position, color);                    //addColorStop()方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置，color 参数必须是一个有效的 CSS 颜色值    var radialGradient = context.createRadialGradient(x1, y1, r1, x2, y2, r2);    //createRadialGradient()方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆，分别表示渐变的起点线与终点线（类似于线性渐变，范围外的部分是纯色）    radialGradient.addColorStop(position, color);                    //同上◆线形 Line styles：    context.lineWidth = value;                            //设置线条宽度，默认值是1.0，线宽是指给定路径的中心到两边的粗细——换句话说就是在路径的两边各绘制线宽的一半    context.lineCap = &quot;butt&quot; || &quot;round&quot; || &quot;square&quot;;                //设置线条末端样式，默认是&quot;butt&quot;——与辅助线齐平，&quot;round&quot;——端点处加上了半径为一半线宽的半圆，&quot;square&quot;——端点处加上了等宽且高度为一半线宽的方块     context.lineJoin = &quot;round&quot; || &quot;bevel&quot; || &quot;miter&quot;;                //设定线条与线条间接合处的样式，默认是&quot;miter&quot;——线段会在连接处外侧延伸直至交于一点，延伸效果受到 miterLimit 属性的制约，&quot;round&quot;——边角处被磨圆了，圆的半径等于线宽，&quot;bevel&quot;——边角处被磨平了    context.miterLimit = value;                            //miterLimit属性 是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了&quot;bevel&quot;    context.getLineDash();                                //    context.setLineDash([line,gap,line,gap,...]);                    //setLineDash()方法接受一个数组，来指定线段与间隙的交替距离，对超出长度的线段部分重复使用该数组——第一次使用时数组首个元素表示的是线段长度，而当数组元素为奇数个时，对于超出部分而言数组的第一个元素表示的是间隙长度    context.lineDashOffset = value;                            //lineDashOffset 属性设置起始偏移量</code></pre><p>  ■绘制文本：<br>    ◆绘制方法：<br>        context.fillText(text, x, y [, maxWidth]);                    //在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的<br>        context.strokeText(text, x, y [, maxWidth]);                    //在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的<br>    ◆设置文本样式：<br>        context.font = value;                                //当前我们用来绘制文本的样式，这个字符串使用和 CSS font 属性相同的语法，默认的字体是 10px sans-serif<br>        context.textAlign = “start”||”end”||”left”||”right”||”center”;            //文本对齐选项，默认值是 start<br>        context.textBaseLine = “top”||”hanging”||”middle”||”alphabetic”||”ideographic”||”bottom”;//基线对齐选项，默认值是 alphabetic<br>        context.direction = “ltr”||”rtl”||”inherit”;                    //文本方向，默认值是 inherit<br>    □先进的文本测量：<br>        context.measureText(text);                            //将返回一个 TextMetrics对象 的宽度、所在像素等，这些体现文本特性的属性</p><p>  ■绘制图片：<br>    ◆获得需要绘制的图片（参数）：<br>      Canvas的 API 可以使用下面这些类型中的一种作为图片的源：这些源统一由 CanvasImageSource 类型来引用；<br>        HTMLImageElement    这些图片是由Image()函数构造出来的，或者任何的<img>元素；<br>        HTMLVideoElement    用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像；<br>        HTMLCanvasElement    可以使用另一个 <canvas> 元素作为你的图片源；<br>        ImageBitmap        这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成；<br>    ·使用相同页面内的图片：    document.images | document.getElementsByTagName() | document.getElementById()；<br>    ·使用其它域名下的图片：    在 HTMLImageElement 上使用 crossOrigin 属性，可以请求加载其它域名上的图片；<br>    ·使用其它 canvas 元素：    和引用页面内的图片类似地，引入已经准备好的 canvas；<br>    ·由零开始创建图像：        使用 Image() 构造函数，创建一个新的 HTMLImageElement 对象，★注意要用 load 事件来保证不会在加载完毕之前使用这个图片；<br>    ·通过 data:url 方式嵌入图像：    Data urls 允许用一串 Base64 编码的字符串的方式来定义一个图片；<br>    ·使用视频帧：            使用 <video> 中的视频帧（即便视频是不可见的）；</video></canvas></video></p><pre><code>◆绘制图片：    context.drawImage(image, x, y);                            // image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标    context.drawImage(image, x, y, width, height);                    // width 和 height，这两个参数用来控制当向 canvas 画入时应该缩放的大小    context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);    // 前4个参数是定义切片在图像源上的位置和大小，后4个参数则是定义图像源切片在 canvas 画布上的位置和大小</code></pre><p>  ■变形：<br>    ◆状态的保存和恢复 Saving and restoring state：<br>    ·Canvas 的状态就是当前画面应用的所有样式和变形的一个快照；<br>    ·一个完整的绘画状态包括：<br>        →当前应用的变形（移动，旋转和缩放）；<br>        →strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值；<br>        →当前的裁切路径（clipping path）；<br>    ·Canvas 的状态存储在 栈 中，每当 save() 方法被调用后，当前的状态就被推送到栈中保存；每一次调用 restore() 方法，上一个保存的状态就从 栈 中弹出，所有设定都恢复；</p><pre><code>◆移动 Translating：    context.translate(x, y);                            //translate()方法用来移动 canvas 和它的原点到一个不同的位置◆旋转 Rotating：    context.rotate(angle);                                //rotate()方法用于以原点为中心旋转 canvas，旋转的角度(angle)是以canvas的原点为中心，x轴正向为起点，顺时针方向为正方向的，以弧度为单位的值◆缩放 Scaling：    context.scale(x, y);                                //scale()方法用来增减图形在 canvas 中的像素数目，对形状或位图进行缩小或者放大，x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值——值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有                                            //默认情况下，canvas 的 1 单位就是 1 个像素，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍◆变形 Transforms：                                                                           ┏ m11 m21 dx ┓    context.transform(m11, m12, m21, m22, dx, dy);                    //transform()方法将当前的变形矩阵乘上一个基于自身参数的矩阵，用下面的矩阵：┃ m12 m22 dy ┃；                                                                                   ┗  0   0  1  ┛</code></pre><p>  ■非零环绕原则：判断一个点是在所绘制的图形内部，还是在图形外部——内部的点才可以通过fill()方法填充指定颜色；</p><pre><code>◆在图形学中判断一个点是否在多边形内：    ·若多边形不是自相交的，那么可以简单的判断这个点在多边形内部还是外部；    ·若多边形是自相交的，那么就需要根据非零环绕数规则和奇-偶规则判断；◆判断多边形是否是自相交的——多边形在平面内除顶点外还有其他公共点：    ·不自交的多边形：多边形仅在顶点处连接，而在平面内没有其他公共点，此时可以直接划分内-外部分；    ·自相交的多边形：多边形在平面内除顶点外还有其他公共点，此时划分内-外部分需要采用以下的方法；◆内-外测试：    ·奇-偶规则(Odd-even Rule)：奇数表示在多边形内，偶数表示在多边形外；        从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点；    ·非零环绕数规则(Nonzero Winding Number Rule)：若环绕数为0表示在多边形外，非零表示在多边形内；        1.首先使多边形的边变为矢量，将环绕数初始化为零；        2.再从任意位置p作一条射线，当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1：        3.处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点；</code></pre><p>㈢移动WEB开发：</p><p>⑴移动端设备概述：<br>  设备参数：<br>    ■触摸屏类型：XXX 多点触控（区别：PC端只有一点——光标）；<br>    ■主屏尺寸：屏幕对角线的长度，常用单位：1英寸|1in|1inch[英制] = 2.54cm；<br>    ■主屏分辨率[物理|设备分辨率]：屏幕上总的物理像素点个数——通常用长宽方向上的像素点个数之积 widthPX×heightPX 来表示，是屏幕设备的固有属性之一，单位：物理像素（1 物理像素 代表了屏幕上的 1 个 实际发光单元/发光点）；<br>        ◆获取屏幕分辨率：<br>        ·window.screen.width;<br>        ·window.screen.height;<br>    □逻辑分辨率：屏幕在显示数据内容时所表示出的“逻辑上”的颜色点个数——通常用与物理分辨率相同的形式表示，是由操作系统来进行控制的，单位：逻辑像素（1 逻辑像素 代表了屏幕上的 1 个 颜色数据单元/颜色点）；<br>      例如：在 PC端 操作系统中，可以修改屏幕分辨率（★移动端不可以）——实质上只是修改了逻辑分辨率，而降低该分辨率时其实就是用更多个“物理”上的像素（发光点）来显示一个“逻辑”上的像素（颜色数据）；<br>        ·用多个“物理”像素来表示一个“逻辑”数据，所显示的该图像会比默认情况下显示地更大，但却会造成图像的——模糊！！！<br>        ·用一个“物理”像素来表示多个“逻辑”数据，所显示的该图像会比默认情况下显示地更小，虽然部分颜色数据丢失了，但图像整体仍然是——清晰！！！<br>    ★长度单位：在移动端软件的开发过程中所使用的所有长度单位共分为如下两大类——<br>        ·绝对长度单位——不会随着使用环境的改变而变化，如cm，inch，dp（安卓app开发），pt（苹果app开发），[逻辑]px（移动WEB开发）等；<br>        ·相对长度单位——随着使用的地方不同，该单位对应的实际大小会发生变化，如%，em，rem，[物理]px（对应设备分辨率的物理像素中 1px 是相对长度单位，根据屏幕PPI的不同而不同）等；<br>    ★注意：移动端 WEB 应用开发过程中 CSS 布局所使用的 px 长度单位对应的是 [逻辑] 像素点——设备独立像素！！！<br>        该 [逻辑] 像素点对应的 [物理] 像素点根据设备的不同而不同，可能 1px &lt; 1px，1px = 1px，1px &gt; 1px！！！<br>    ■屏幕像素密度[PPI|PixelPerInch]：屏幕对角线平行方向单位英寸上的物理像素点个数——PPI = (²√(widthPixel)²+(heightPixel)²)/主屏尺寸，单位：ppi；<br>        密度等级：<br>        ◆ldpi : mdpi : hdpi : xhdpi : xxhdpi = 0.75 : 1 : 1.5 : 2 : 3 = 120 : 160 : 240 : 320 : 480;</p><p>⑵设备独立像素[DP|PT|PX]：安卓移动开发[dp]|苹果IOS移动开发[pt]|移动WEB开发[px]中常用的一种绝对长度单位—— [逻辑] 像素，可以在屏幕像素密度 PPI 不同的设备上让图片显示为相同的实际大小，这是由于<br>        该单位的长度会根据操作系统所提供的 ppi 数值来换算为实际显示的 [物理]像素 px，在高清屏幕上换算的 px 像素点数多，低清晰度的屏幕上换算的 px 像素点少，而最终实际显示的尺寸则完全相同；<br>        ◆1dp 表示在屏幕像素点密度为 160ppi 时[物理] 1px 的长度—— 1dp = (屏幕ppi / 160)px；<br>        ·px [pixel]：像素，电子屏幕上组成一幅图画或照片的最基本物理单元；<br>        ·pt [point]：点，印刷行业或 PS 制图中常用的单位，打印或画布分辨率为 72ppi|72dpi 时 1px 的长度——1pt= (DPI / 72) px（当 72ppi 时，1pt=1px，当分辨率为 144ppi 时，1pt=2px）；<br>        ·ppi[pixel per inch]：每英寸像素数，该值越高，则屏幕显示越细腻（显示图片使用，dpi=ppi）；<br>        ·dpi[dot per inch]：每英寸打印点数，该值越高，则打印图片越细腻（打印图片使用，dpi=ppi）；<br>        ·dp [dip，density-independent pixel]：设备独立像素，是安卓开发用的长度单位；<br>        ·sp [scale-independent pixel]：安卓开发用的字体大小单位；<br>  ★注意：使用 设备独立像素 dp|pt|px 进行布局时，虽然能使相同的图片显示为相同的大小，但假设某图片大小与其逻辑尺寸相同，在低分辨率屏幕（1dp=1px）上正好能清晰显示该图片，而到了高分辨率屏幕（1dp=2px）<br>      上则会显得图像模糊——因为用了多于[逻辑]像素点的[物理]像素来显示该图片，所以开发中通常会使用 二倍图/三倍图（即要把图片制作成其 [逻辑] 尺寸的 2 倍）来进行使用，目的是让图片既能<br>      在高分屏上清晰显示，而且在低分屏上通过一个[物理]像素表示多个[逻辑]色值时也并不会使图像变模糊！！！<br>        ◆获取设备独立像素比[dp/px]：<br>        ·window.devicePixelRatio;</p><p>⑶视口（viewport）：</p><pre><code>■视口概念：视口——是用来约束网页中的最顶级块元素 html 的，它决定了 html 元素的大小（即设置html的width为100%时，就是取的视口宽度）；·视窗布局视口(layout viewport)：设置网页布局区域的大小(以CSS像素为单位)——html的大小；·理想视口(ideal viewport)：是指设备的屏幕区域——屏幕大小；·移动设备上浏览器会默认设置一个 layout viewport，并且这个值会大于 ideal viewport，于是就出现了滚动条；·某厂商认为将网页完整显示给用户才最合理，而不该出现滚动条，所以就将 layout viewport 进行了缩放，使其恰好完整显示在 ideal viewport(屏幕)里，而其缩放比例为 ideal viewport/layout viewport；■设置视口：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,height=N,initial-scale=1.0,maximum-scale=N,minimum-scale=N,user-scalable=yes|no&quot;&gt;·width        设置 layout viewport 的宽度(带单位)，为一个正整数或字符串&quot;device-width&quot;</code></pre><p>；<br>    ·height    设置 layout viewport 的高度(带单位)，这个属性并不重要，很少使用</p><p>；<br>    ·initial-scale    设置页面的初始缩放值(倍数)，为一个数字</p><p>；<br>    ·maximum-scale    允许用户的最大缩放值(倍数)，为一个数字</p><p>；<br>    ·minimum-scale    允许用户的最小缩放值(倍数)，为一个数字</p><p>；<br>    ·user-scalable    否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许；</p><pre><code>■视口作用：·在 PC设备 上，viewport的大小取决于浏览器窗口的大小，并以CSS像素做为度量单位；·在 移动端 上，viewport的大小不再受限于浏览器的窗口，而是允许开发人员自由设置，不过浏览器会设置一个默认大小的viewport，为了能够正常显示那些专为PC设计的网页，一般这个值的大小会大于屏幕本身的尺寸；·所以，在开发移动端专属的WEB应用时，如果需要适配屏幕宽度，则必须主动设置 视口宽度width 为 设备宽度device-width；</code></pre><p>⑷移动端布局：<br>  ■像素布局：</p><p>  ■百分比布局：</p><p>  ■rem布局：</p><p>  ■响应式布局：</p><p>⑸移动端事件：现在随着移动设备的出现，鼠标事件不能够满足多指触控的事件需求，再加上 click 点击事件在移动端存在延迟，因此在移动端出现了移动端事件——TouchEvent；<br>          TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件，这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少等等。<br>  ■touchEvent 类型：<br>    ·touchstart            当用户在触摸平面上放置了一个触点时触发；<br>    ·touchmove            当用户在触摸平面上移动触点时触发；<br>    ·touchend            当一个触点被用户从触摸平面上移除（当用户将一个手指离开触摸平面）时触发；</p><p>  ■touchEvent 事件对象：<br>    ·event.touches            屏幕上所有 touch触点 的伪数组(touchList)；<br>    ·event.targetTouches        绑定事件的元素上所有 touch触点 的伪数组(touchList)；<br>    ·event.changedTouches        相对于上一次状态发生了改变（进入目标元素、离开目标元素、在目标元素上发生了移动）的触摸点的集合；</p><p>  ★注意：在 touchend 事件里面，只能通过 changedTouches 获取离开目标元素的手指触点！！！<br>      ·最后有可能有一个离开了屏幕，只会在 changedTouches 中存在一个触点的数据；<br>      ·最后有可能有两个同时离开了屏幕，就会在 changedTouches 中存在两个触点的数据…；</p><p>  ■touch 对象：<br>    ·touch.clientX/clientY        相对于浏览器可视区域(屏幕)的坐标，想要获取正确的结果必须写全 viewport 的设置（width+initial-scale+maximum-scale+minimum-scale+user-scalable）；<br>    ·touch.pageX/pageY        相对于页面的坐标，页面有多大，坐标的最大值就有多大，但是想要看到这个结果——必须写全viewport的设置（width+initial-scale+maximum-scale+minimum-scale+user-scalable）；<br>        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"><br>    ·touch.screenX/screenY        相对于屏幕的坐标（谷歌下是相对于屏幕|火狐下是和clientX/Y是一样的）；</p><p>  □click延迟：click事件在移动手机开发中有 约300ms 的延迟，因为在手机出现的早期，浏览器系统有放大和缩放功能，用户在屏幕上点击两次之后，系统会触发放大或者缩放功能，因此系统做了一个处理，当触摸一次后，<br>           会在之后的 300ms 这段时间内判断有没有触摸第二次——如果触摸了第二次的话，说明是触发放大或缩放功能；否则的话是click事件；<br>           因此当click时候，所有用户必须等待 约300ms 后才会触发click事件，所以当在移动端使用 click事件 的时候，会感觉到有300ms的迟钝；<br>           准确来讲，click 的延时不是精确的300ms，而只是一个习惯性的名称——因为用户通过正常的点击，click事件大概在 300ms 之后的时候触发(一般情况下，大概在200-300ms左右)。</p><p>⑹Zepto类库：Zepto 是一个轻量级的针对现代高级浏览器的 JavaScript 库， 它与 jQuery 有着类似的 API，所以可以简单地认为 Zepto(移动端) === jQuery(PC端)！！！<br>     ★注意：Zepto 的设计目的是提供 jQuery 的类似的API，但并不是 100% 全覆盖 jQuery；<br>         Zepto 的设计目的是有一个 5-10k 的通用库、能下载并快速执行、并有一个熟悉通用的API，所以才能把精力放到应用开发上！！！</p><p>  ■Zepto 模块：<br>    Module        Default        Description<br>    zepto           ✔        核心模块，包含许多方法；<br>    event           ✔        默认模块，通过on() &amp; off()处理事件；<br>    ajax           ✔        默认模块，XMLHttpRequest 和 JSONP 实用功能；<br>    form           ✔        默认模块，序列化 &amp; 提交web表单；<br>    ie           ✔        默认模块，增加支持桌面的Internet Explorer 10+和Windows Phone 8；<br>    detect                提供 $.os和 $.browser消息；<br>    fx                The animate()方法；<br>    fx_methods            以动画形式的 show, hide, toggle, 和 fade*()方法；<br>    assets                实验性支持从DOM中移除image元素后清理iOS的内存；<br>    data                一个全面的 data()方法, 能够在内存中存储任意对象；<br>    deferred            提供 $.Deferredpromises API. 依赖”callbacks” 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调；<br>    callbacks            为”deferred”模块提供 $.Callbacks；<br>    selector            实验性的支持 jQuery CSS 表达式 实用功能，比如 $(‘div:first’)和 el.is(‘:visible’)；<br>    touch                在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的<code>touch</code>(iOS, Android)和<code>pointer</code>事件(Windows Phone)；<br>    gesture                在触摸设备上触发 pinch 手势事件；<br>    stack                提供 andSelf&amp; end()链式调用方法；<br>    ios3                String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x；<br>  ★注意：Zepto 的一些 可选功能 是专门针对 移动端 浏览器的，因为它的最初目标是在 移动端 提供一个精简的类似 jQuery 的 JavaScript 库！！！<br>      Zepto 希望在所有的现代浏览器中作为一种基础环境来使用，故 Zepto 不支持旧版本的 Internet Explorer 浏览器(IE&lt;10)！！！</p><p>  ■自定义Zepto：官方网站提供了 Zepto 的默认发行版的下载，这在刚开始是很好的选择。但是，在某些时候，如果需要添加一些可选模块，并删除一些不需要的默认模块，以尽可能减小尺寸，那时便需要检查 Zepto 的源代码并使用 Build 命令；<br>    ·首先需要在系统上安装 Node.js；</p>]]></content>
    
    <summary type="html">
    
      JavaScript学习笔记
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Emmet语法大全</title>
    <link href="http://yoursite.com/2014/02/28/Emmet%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2014/02/28/Emmet语法大全/</id>
    <published>2014-02-28T06:10:20.000Z</published>
    <updated>2018-02-16T14:58:05.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h1><p><strong>Emmet</strong> 是 <strong>Sublime</strong> 里的一个插件，用来将简写的代码快速转换为标准结构，其前身是大名鼎鼎的 <strong>Zen coding</strong> ，它使用仿 <strong>CSS选择器</strong> 的语法来生成代码，大大提高了 <strong>HTML</strong> 及 <strong>CSS</strong> 代码编写的速度；</p><hr><h2 id="1-页面初始化："><a href="#1-页面初始化：" class="headerlink" title="1.页面初始化："></a>1.页面初始化：</h2><ul><li><p>Html:xt + [Ctrl+e]：生成XHTML标准的结构代码，x表示Xhtml，t表示Transitional，即Xhtml的过渡型规范；    </p><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></p></li><li><p>Html:xs + [Ctrl+e]：生成XHTML标准的结构代码，x表示Xhtml，t表示Strict，即Xhtml的严格型规范；</p><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p></li></ul><ul><li><p>Html:4t + [Ctrl+e]：生成HTML4标准的结构代码，4表示html4，t表示Transitional，即html4的过渡型规范；</p><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p><ul><li>Html:4s + [Ctrl+e]：生成HTML4标准的结构代码，4表示html4，t表示Strict，即html4的严格型规范；</li></ul><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></p><p><strong><em>★注意：还可用  [Tab] 来代替  [Ctrl+e] 的组合键！！！</em></strong></p></li><li><p>Html:5|! + [Tab]：生成HTML5标准的结构代码；</p><p>&lt;!DOCTYPE html&gt;</p></li></ul><hr><h2 id="2-HTML："><a href="#2-HTML：" class="headerlink" title="2.HTML："></a>2.HTML：</h2><h3 id="①结构-："><a href="#①结构-：" class="headerlink" title="①结构 ! ："></a>①结构 ! ：</h3><pre><code>! + Tab                            快速生成HTML5标准的结构代码；</code></pre><h3 id="②标签、-类、-ID："><a href="#②标签、-类、-ID：" class="headerlink" title="②标签、.类、#ID："></a>②标签、.类、#ID：</h3><pre><code>标签名.类名1.类名2 + Tab            快速生成带有指定类名的标签；标签名#ID名 + Tab                    快速生成带有指定ID名的标签；.类名|#ID名 + Tab                    快速生成带有指定类名或ID名的隐式div标签；</code></pre><h3 id="③兄弟-："><a href="#③兄弟-：" class="headerlink" title="③兄弟 + ："></a>③兄弟 + ：</h3><pre><code>标签名+标签名+... + Tab                快速生成并列关系的兄弟标签；</code></pre><h3 id="④子代-gt-："><a href="#④子代-gt-：" class="headerlink" title="④子代 &gt; ："></a>④子代 &gt; ：</h3><pre><code>标签名&gt;子标签&gt;后代标签... + Tab            快速生成嵌套结构的父子标签；</code></pre><h3 id="⑤上级-："><a href="#⑤上级-：" class="headerlink" title="⑤上级 ^ ："></a>⑤上级 ^ ：</h3><pre><code>标签名&gt;子标签&gt;后代标签^子标签 + Tab            快速生成紧邻标签上一级的同级标签；标签名&gt;子标签&gt;后代标签^^同级标签 + Tab        快速生成紧邻标签上上一级的同级标签；</code></pre><h3 id="⑥分组-："><a href="#⑥分组-：" class="headerlink" title="⑥分组 () ："></a>⑥分组 () ：</h3><pre><code>标签名&gt;(子标签&gt;后代标签)+子标签&gt;后代标签 + Tab    快速生成一组标签块，语法上可看作为一个标签；</code></pre><h3 id="⑦乘法-："><a href="#⑦乘法-：" class="headerlink" title="⑦乘法 * ："></a>⑦乘法 * ：</h3><pre><code>标签名*个数 + Tab                    快速生成固定数量的同级标签；</code></pre><h3 id="⑧属性-："><a href="#⑧属性-：" class="headerlink" title="⑧属性 [] ："></a>⑧属性 [] ：</h3><pre><code>标签名[属性] + Tab                    快速生成带指定属性的对应标签；标签名[属性=属性值] + Tab                快速生成带指定属性及属性值的对应标签；    标签名[属性1=属性值1 属性2=属性值2] + Tab    快速生成带指定属性及属性值的对应标签；</code></pre><h3 id="⑨文本-："><a href="#⑨文本-：" class="headerlink" title="⑨文本 {} ："></a>⑨文本 {} ：</h3><pre><code>标签名{内容} + Tab                    快速生成带指定文本内容的对应标签；标签名&gt;{内容}+子标签+{内容} + Tab        快速生成带指定文本及子元素的对应标签；</code></pre><h3 id="⑩自增-常和-的配合使用-："><a href="#⑩自增-常和-的配合使用-：" class="headerlink" title="⑩自增 $ (常和 * 的配合使用)："></a>⑩自增 $ (常和 * 的配合使用)：</h3><pre><code>标签名$*个数 + Tab                    快速生成具有连续标签名(1开始)的同级标签；标签名.类名$*个数 + Tab                快速生成具有连续类名(1开始)的同级标签；标签名#ID名$*个数 + Tab                快速生成具有连续ID名(1开始)的同级标签；标签名[属性=属性值$]*个数 + Tab        快速生成具有连续属性值(1开始)的同级标签；标签名{文本内容$}*个数 + Tab            快速生成具有连续文本内容(1开始)的同级标签；标签名.类名$$$*个数 + Tab            快速生成具有连续类名(001-999)的同级标签；标签名.类名$@-*个数 + Tab            快速生成具有连续类名(递减,1结束)的同级标签；标签名.类名$@N*个数 + Tab            快速生成具有连续类名(N开始)的同级标签；</code></pre><p><strong><em>☆条件注释：cc:|cc:ie6！！！</em></strong></p><hr><h2 id="3-元素："><a href="#3-元素：" class="headerlink" title="3.元素："></a>3.元素：</h2><p><strong><em>★注意：所有未知的缩写都会转换成自定义标签，例如foo → <foo></foo>！！！</em></strong></p><h4 id="a标签："><a href="#a标签：" class="headerlink" title="a标签："></a>a标签：</h4><p>缩写：a</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：a:link<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：a:mail<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="abbr标签："><a href="#abbr标签：" class="headerlink" title="abbr标签："></a>abbr标签：</h4><p>缩写：abbr</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="acronym标签："><a href="#acronym标签：" class="headerlink" title="acronym标签："></a>acronym标签：</h4><p>缩写：acronym</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">acronym</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="base标签："><a href="#base标签：" class="headerlink" title="base标签："></a>base标签：</h4><p>缩写：base</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="basefont标签："><a href="#basefont标签：" class="headerlink" title="basefont标签："></a>basefont标签：</h4><p>缩写：basefont</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">basefont</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="br标签："><a href="#br标签：" class="headerlink" title="br标签："></a>br标签：</h4><p>缩写：br</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="frame标签："><a href="#frame标签：" class="headerlink" title="frame标签："></a>frame标签：</h4><p>缩写：frame</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frame</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="hr标签："><a href="#hr标签：" class="headerlink" title="hr标签："></a>hr标签：</h4><p>缩写：hr</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="bdo标签："><a href="#bdo标签：" class="headerlink" title="bdo标签："></a>bdo标签：</h4><p>缩写：bdo</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：bdo:r<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">"rtl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：bdo:l<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="col标签："><a href="#col标签：" class="headerlink" title="col标签："></a>col标签：</h4><p>缩写：col</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">col</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="link标签："><a href="#link标签：" class="headerlink" title="link标签："></a>link标签：</h4><p>缩写：link</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：link:css<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：link:print<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：link:favicon<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：link:touch<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"favicon.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：link:rss<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">type</span>=<span class="string">"application/rss+xml"</span> <span class="attr">title</span>=<span class="string">"RSS"</span> <span class="attr">href</span>=<span class="string">"rss.xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：link:atom<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">type</span>=<span class="string">"application/atom+xml"</span> <span class="attr">title</span>=<span class="string">"Atom"</span> <span class="attr">href</span>=<span class="string">"atom.xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="meta标签："><a href="#meta标签：" class="headerlink" title="meta标签："></a>meta标签：</h4><p>缩写：meta</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：meta:utf<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：meta:win<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=windows-1251"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：meta:vp<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：meta:compat<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="style标签："><a href="#style标签：" class="headerlink" title="style标签："></a>style标签：</h4><p>缩写：style</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="script标签："><a href="#script标签：" class="headerlink" title="script标签："></a>script标签：</h4><p>缩写：script</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：script:src<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="img标签："><a href="#img标签：" class="headerlink" title="img标签："></a>img标签：</h4><p>缩写：img</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="iframe标签："><a href="#iframe标签：" class="headerlink" title="iframe标签："></a>iframe标签：</h4><p>缩写：iframe</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="embed标签："><a href="#embed标签：" class="headerlink" title="embed标签："></a>embed标签：</h4><p>缩写：embed</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="object标签："><a href="#object标签：" class="headerlink" title="object标签："></a>object标签：</h4><p>缩写：object</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="param标签："><a href="#param标签：" class="headerlink" title="param标签："></a>param标签：</h4><p>缩写：param</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="map标签："><a href="#map标签：" class="headerlink" title="map标签："></a>map标签：</h4><p>缩写：map</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="area标签："><a href="#area标签：" class="headerlink" title="area标签："></a>area标签：</h4><p>缩写：area</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">""</span> <span class="attr">coords</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：area:d<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"default"</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：area:c<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：area:r<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：area:p<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"poly"</span> <span class="attr">coords</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="form标签："><a href="#form标签：" class="headerlink" title="form标签："></a>form标签：</h4><p>缩写：form</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：form:get<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：form:post<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="label标签："><a href="#label标签：" class="headerlink" title="label标签："></a>label标签：</h4><p>缩写：label</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="input标签："><a href="#input标签：" class="headerlink" title="input标签："></a>input标签：</h4><p>缩写：input</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：inp<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:hidden<br>别名：input[type=hidden name]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:h<br>别名：input:hidden<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:text, input:t<br>别名：inp<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:search<br>别名：inp[type=search]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:email<br>别名：inp[type=email]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:url<br>别名：inp[type=url]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:password<br>别名：inp[type=password]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:p<br>别名：input:password<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:datetime<br>别名：inp[type=datetime]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:date<br>别名：inp[type=date]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:datetime-local<br>别名：inp[type=datetime-local]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:month<br>别名：inp[type=month]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"month"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:week<br>别名：inp[type=week]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:time<br>别名：inp[type=time]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:number<br>别名：inp[type=number]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:color<br>别名：inp[type=color]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:checkbox<br>别名：inp[type=checkbox]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:c<br>别名：input:checkbox<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:radio<br>别名：inp[type=radio]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:r<br>别名：input:radio<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:range<br>别名：inp[type=range]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:file<br>别名：inp[type=file]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:f<br>别名：input:file<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:submit<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:s<br>别名：input:submit<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:image<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:i<br>别名：input:image<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:button<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:b<br>别名：input:button<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：input:reset<br>别名：input:button[type=reset]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="isindex标签："><a href="#isindex标签：" class="headerlink" title="isindex标签："></a>isindex标签：</h4><p>缩写：isindex</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">isindex</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="select标签："><a href="#select标签：" class="headerlink" title="select标签："></a>select标签：</h4><p>缩写：select</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="option标签："><a href="#option标签：" class="headerlink" title="option标签："></a>option标签：</h4><p>缩写：option</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="textarea标签："><a href="#textarea标签：" class="headerlink" title="textarea标签："></a>textarea标签：</h4><p>缩写：textarea</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="menu标签："><a href="#menu标签：" class="headerlink" title="menu标签："></a>menu标签：</h4><p>缩写：menu:context<br>别名：menu[type=context]&gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"context"</span>&gt;</span><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：menu:c<br>别名：menu:context<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"context"</span>&gt;</span><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：menu:toolbar<br>别名：menu[type=toolbar]&gt;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"toolbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：menu:t<br>别名：menu:toolbar<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"toolbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="video标签："><a href="#video标签：" class="headerlink" title="video标签："></a>video标签：</h4><p>缩写：video</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="audio标签："><a href="#audio标签：" class="headerlink" title="audio标签："></a>audio标签：</h4><p>缩写：audio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="html标签："><a href="#html标签：" class="headerlink" title="html标签："></a>html标签：</h4><p>缩写：html:xml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="keygen标签："><a href="#keygen标签：" class="headerlink" title="keygen标签："></a>keygen标签：</h4><p>缩写：keygen</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keygen</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="command标签："><a href="#command标签：" class="headerlink" title="command标签："></a>command标签：</h4><p>缩写：command</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">command</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="blockquote标签："><a href="#blockquote标签：" class="headerlink" title="blockquote标签："></a>blockquote标签：</h4><p>缩写：bq<br>别名：blockquote</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="acronym标签：-1"><a href="#acronym标签：-1" class="headerlink" title="acronym标签："></a>acronym标签：</h4><p>缩写：acr<br>别名：acronym</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">acronym</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="figure标签："><a href="#figure标签：" class="headerlink" title="figure标签："></a>figure标签：</h4><p>缩写：fig<br>别名：figure</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="figcaption标签："><a href="#figcaption标签：" class="headerlink" title="figcaption标签："></a>figcaption标签：</h4><p>缩写：figc<br>别名：figcaption</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span><span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="iframe标签：-1"><a href="#iframe标签：-1" class="headerlink" title="iframe标签："></a>iframe标签：</h4><p>缩写：ifr<br>别名：iframe</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="embed标签：-1"><a href="#embed标签：-1" class="headerlink" title="embed标签："></a>embed标签：</h4><p>缩写：emb<br>别名：embed</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="object标签：-1"><a href="#object标签：-1" class="headerlink" title="object标签："></a>object标签：</h4><p>缩写：obj<br>别名：object</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="source标签："><a href="#source标签：" class="headerlink" title="source标签："></a>source标签：</h4><p>缩写：src<br>别名：source</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="caption标签："><a href="#caption标签：" class="headerlink" title="caption标签："></a>caption标签：</h4><p>缩写：cap<br>别名：caption</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">caption</span>&gt;</span><span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="colgroup标签："><a href="#colgroup标签：" class="headerlink" title="colgroup标签："></a>colgroup标签：</h4><p>缩写：colg<br>别名：colgroup</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">colgroup</span>&gt;</span><span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="fieldset标签："><a href="#fieldset标签：" class="headerlink" title="fieldset标签："></a>fieldset标签：</h4><p>缩写：fst, fset<br>别名：fieldset</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="button标签："><a href="#button标签：" class="headerlink" title="button标签："></a>button标签：</h4><p>缩写：btn<br>别名：button</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缩写：btn:b<br>别名：button[type=button]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：btn:r<br>别名：button[type=reset]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缩写：btn:s<br>别名：button[type=submit]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="4-CSS："><a href="#4-CSS：" class="headerlink" title="4.CSS："></a>4.CSS：</h2><h3 id="①属性："><a href="#①属性：" class="headerlink" title="①属性："></a>①属性：</h3><pre><code>首字母组合|模糊缩写 + Tab    快速生成属性；缩写+缩写 + Tab            生成多个属性；</code></pre><h3 id="②单位："><a href="#②单位：" class="headerlink" title="②单位："></a>②单位：</h3><pre><code>空                表示px；p                表示%；e                表示em；x                表示ex；</code></pre><h3 id="③额外选项-："><a href="#③额外选项-：" class="headerlink" title="③额外选项 + ："></a>③额外选项 + ：</h3><p>缩写：@f+</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;  </span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">'FontName'</span>;  </span><br><span class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'FileName.eot'</span>);  </span><br><span class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'FileName.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),  </span><br><span class="line">     <span class="built_in">url</span>(<span class="string">'FileName.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),  </span><br><span class="line">     <span class="built_in">url</span>(<span class="string">'FileName.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),  </span><br><span class="line">     <span class="built_in">url</span>(<span class="string">'FileName.svg#FontName'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);  </span><br><span class="line"><span class="attribute">font-style</span>: normal;  </span><br><span class="line"><span class="attribute">font-weight</span>: normal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④（供应商）私有前缀："><a href="#④（供应商）私有前缀：" class="headerlink" title="④（供应商）私有前缀："></a>④（供应商）私有前缀：</h3><pre><code>-                分别生成带有四个供应商前缀的属性；-w-                生成-webkit-；-m-                生成-moz-；-s-                生成-ms-；-o-                生成-o-；-wm-                分别生成-webkit-和-moz-前缀的属性，等等...</code></pre><h3 id="⑤渐变："><a href="#⑤渐变：" class="headerlink" title="⑤渐变："></a>⑤渐变：</h3><pre><code>lg(left,red,green) + Tab    生成线性渐变</code></pre>]]></content>
    
    <summary type="html">
    
      Emmet语法及示例
    
    </summary>
    
      <category term="general" scheme="http://yoursite.com/categories/general/"/>
    
    
      <category term="Emmet" scheme="http://yoursite.com/tags/Emmet/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记 五</title>
    <link href="http://yoursite.com/2014/02/27/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/"/>
    <id>http://yoursite.com/2014/02/27/CSS学习笔记05/</id>
    <published>2014-02-27T02:50:36.000Z</published>
    <updated>2018-02-16T16:18:06.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记-·-五"><a href="#CSS学习笔记-·-五" class="headerlink" title="CSS学习笔记 · 五"></a>CSS学习笔记 · 五</h1><p>⒆删除冗余CSS的方法：  ■chrome浏览器 F12|审查元素 控制台的 Audits：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·Audits 会检测出页面中没有用到的CSS，需要手动删除这些多余的CSS；</span><br><span class="line">·Audits 检测出的是多余无用的CSS块，而不是某一行CSS；</span><br></pre></td></tr></table></figure><p>  ■CSS usage插件：</p>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记 四</title>
    <link href="http://yoursite.com/2014/02/26/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
    <id>http://yoursite.com/2014/02/26/CSS学习笔记04/</id>
    <published>2014-02-26T02:40:36.000Z</published>
    <updated>2018-02-16T16:17:59.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记-·-四"><a href="#CSS学习笔记-·-四" class="headerlink" title="CSS学习笔记 · 四"></a>CSS学习笔记 · 四</h1><p>⑺CSS属性：</p><p>①尺寸属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">width属性：默认值是auto（浏览器根据元素display类型决定），不继承，用于设置元素的宽度（通常指盒子模型中内容部分宽度——★前提是box-sizing值为content-box）；</span><br><span class="line">    结构： width: value;</span><br><span class="line">        width: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        auto    默认值，浏览器根据元素display类型决定；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素宽度的百分比。</span><br><span class="line">min-width属性：默认值取决于浏览器，不继承，用于设置元素宽度的最小值，当子元素的宽度跟随父元素一同变小时（继承或百分比%），可以通过设置min-width来作为宽度的下限；</span><br><span class="line">    结构： min-width: value;</span><br><span class="line">        min-width: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素当前宽度的百分比。</span><br><span class="line">max-width属性：默认值是none，不继承，用于设置元素宽度的最大值，当子元素的宽度跟随父元素一同变大时（继承或百分比%），可以通过设置max-width来作为宽度的上限；</span><br><span class="line">    结构： max-width: value;</span><br><span class="line">        max-width: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        none    默认值，对元素的最大宽度没有限制；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素当前宽度的百分比。</span><br><span class="line"></span><br><span class="line">height属性：默认值是auto（浏览器根据元素display类型决定），不继承，用于设置元素的高度（通常指盒子模型中内容部分高度——★前提是box-sizing值为content-box）；</span><br><span class="line">    结构： height: value;</span><br><span class="line">        height: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        auto    默认值，浏览器根据元素display类型决定；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素高度的百分比。</span><br><span class="line">min-height属性：默认值是0，不继承，用于设置元素高度的最小值，当子元素的高度跟随父元素一同变小时（百分比%），可以通过设置min-height来作为高度的下限；</span><br><span class="line">    结构： min-height: value;</span><br><span class="line">        min-height: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        0   默认值；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素当前高度的百分比。</span><br><span class="line">max-height属性：默认值是none，不继承，用于设置元素高度的最大值，当子元素的高度跟随父元素一同变大时（百分比%），可以通过设置max-height来作为高度的上限；</span><br><span class="line">    结构： max-height: value;</span><br><span class="line">        max-height: 100px;</span><br><span class="line">    属性值类型：</span><br><span class="line">        none    默认值，对元素的最大高度没有限制；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于父元素当前高度的百分比。</span><br></pre></td></tr></table></figure><p>★★★★注意：html标签与body标签都是块级元素，而实际上html以浏览器窗口为父元素！！！可以设置html与body的宽高为100%，从而得到一个随着浏览器窗口大小改变而改变的盒子！！！</p><p>②内边距属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">padding属性：简写属性（按上右下左顺序认定，至少有padding-top值），默认值是0，不继承，用于在一个声明中设置当前元素内容区与四个边框之间的距离，即四个内边距。</span><br><span class="line">    结构： padding: padding-top padding-right padding-bottom padding-left;</span><br><span class="line">        padding: 10px;</span><br><span class="line">    ☆注：如果省略padding-left，则其与padding-right相同（上+左右+下）；如果再省略padding-bottom，则其与padding-top相同（上下+左右）；如果再省略padding-right，则其与padding-top相同（上下左右）。</span><br><span class="line">    属性值类型：</span><br><span class="line">        0   默认值；</span><br><span class="line">        auto    浏览器自动计算；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于★父元素的宽度的百分比。</span><br><span class="line">    子/分属性：</span><br><span class="line">    padding-top：默认值是0，不继承，设置上内边距；</span><br><span class="line">    padding-right：默认值是0，不继承，设置右内边距；</span><br><span class="line">    padding-bottom：默认值是0，不继承，设置下内边距；</span><br><span class="line">    padding-left：默认值是0，不继承，设置左内边距；</span><br></pre></td></tr></table></figure><p>★★★★注意：计算盒子的大小，盒子的高度=上边框border-top的宽度+上内边距padding-top的宽度+元素内容高度height+下内边距padding-bottom的宽度+下边框border-bottom的宽度；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        盒子的宽度=左边框border-left的宽度+左内边距padding-left的宽度+元素内容宽度width+右内边距padding-right的宽度+右边框border-right的宽度；</span><br><span class="line">所以给元素设置border或padding后往往会使整个盒子的宽高增加，需要在内容的宽高上做出对应的调整，以便使整个盒子的宽高不发生改变。</span><br></pre></td></tr></table></figure><p>★★★★例外：设置padding不会改变盒子大小的情况——父子元素皆为块级元素，且子元素的宽度没有设置，即默认继承自父元素时，给子元素设置左右padding，子元素盒子的大小不发生改变，实际上内容部分的大小变了。</p><p>③边框属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">border属性：简写属性（无必需，★缺省项设置默认值），无默认，不继承，用于在一个声明中设置所有边具有相同的边框宽度、边框样式和边框颜色；</span><br><span class="line">    结构： border: border-width border-style border-color;</span><br><span class="line">        border: 10px solid red; </span><br><span class="line">    子属性：</span><br><span class="line">    border-width：简写属性（按上右下左顺序认定，至少*-top-*），默认值是medium，不继承，用于在一个声明中设置四个边框的宽度；</span><br><span class="line">        结构： border-width: border-top-width border-right-width border-bottom-width border-left-width;</span><br><span class="line">            border-width: 20px 10px;</span><br><span class="line">        ☆注：如果省略*-left-*，则其与*-right-*相同（上+右左+下）；若再省略*-bottom-*，则其与*-top-*相同（上下+右左）；若再省略*-right-*，则其与*-top-*相同（上下左右）。</span><br><span class="line">        属性值类型：</span><br><span class="line">            thin/medium/thick   细/中/粗；</span><br><span class="line">            length          带CSS单位的具体数值宽度。</span><br><span class="line">    border-style：简写属性（按上右下左顺序认定，至少*-top-*），默认值是none，不继承，用于在一个声明中设置四个边框的样式；</span><br><span class="line">        结构： border-style: border-top-style border-right-style border-bottom-style border-left-style;</span><br><span class="line">            border-style: solid dotted dashed double;</span><br><span class="line">        ☆注：如果省略*-left-*，则其与*-right-*相同（上+右左+下）；若再省略*-bottom-*，则其与*-top-*相同（上下+右左）；若再省略*-right-*，则其与*-top-*相同（上下左右）。</span><br><span class="line">        属性值类型：</span><br><span class="line">            none                无边框；</span><br><span class="line">            dotted/dashed/solid/double  点状/虚线/实线/双线；</span><br><span class="line">    border-color：简写属性（按上右下左顺序认定，至少*-top-*），默认值是currentColor（即color属性的值），不继承，用于在一个声明中设置四个边框的颜色；</span><br><span class="line">        结构： border-color: border-top-color border-right-color border-bottom-color border-left-color;</span><br><span class="line">            border-color: red;</span><br><span class="line">        ☆注：如果省略*-left-*，则其与*-right-*相同（上+右左+下）；若再省略*-bottom-*，则其与*-top-*相同（上下+右左）；若再省略*-right-*，则其与*-top-*相同（上下左右）。</span><br><span class="line">        属性值类型： </span><br><span class="line">            transparent     透明；</span><br><span class="line">            color_name  具体的颜色英文名，比如 red；</span><br><span class="line">            hex_number  十六进制值颜色 #rrggbb（其中rr表示红：0-255，gg表示绿：0-255，bb表示蓝：0-255，相同可简写为1位），比如#ff0000写为#f00； </span><br><span class="line">            rgb_number  rgb代码颜色 rgb(r,g,b)（其中r、g、b取0-255或百分比%），比如 rgb(255,0,0)；</span><br><span class="line">            rgba_number rgba代码颜色 rgba(r,g,b,a)（其中alpha是透明度，取0-1之间小数），比如 rgba(255,0,0,0.1)。 </span><br><span class="line">        ★拓展：</span><br><span class="line">        opacity属性：设置整个元素的透明度；</span><br><span class="line">            opacity:0.4;</span><br><span class="line">            filter:alpha(opacity=40);/* 针对 IE8 以及更早的版本 */</span><br><span class="line">            opacity:1.0;</span><br><span class="line">            filter:alpha(opacity=100);</span><br><span class="line"></span><br><span class="line">    分属性：</span><br><span class="line">    border-top：简写属性（无必需，★缺省项设置默认值），无默认，不继承，用于在一个声明中设置上边框的宽度、样式和颜色；</span><br><span class="line">        结构： border-top: border-top-width border-top-style border-top-color;</span><br><span class="line">            border-top: 10px solid red;</span><br><span class="line">        子属性：</span><br><span class="line">        border-top-width：上边框宽度；</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    border-right：...；</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    border-bottom：...；</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    border-left：...；</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">outline属性：简写属性（无必需，★缺省项设置默认值），默认值是invert none medium，不继承，用于在一个声明中设置所有的轮廓线属性——轮廓线颜色、轮廓线样式、轮廓线宽度；</span><br><span class="line">     ☆注释：outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。轮廓线不会占据空间，也不一定是矩形。</span><br><span class="line">    结构： outline: outline-color outline-style outline-width;</span><br><span class="line">        outline: #0FF dotted thin;</span><br><span class="line">    子属性：</span><br><span class="line">    outline-color：默认值是invert，不继承，设置一个元素整个轮廓中可见部分的颜色；</span><br><span class="line">        属性值类型：</span><br><span class="line">            invert      默认值，执行颜色反转（即逆向的颜色），可使轮廓在不同的背景颜色中都是可见；</span><br><span class="line">            颜色相关...；</span><br><span class="line">    outline-style：默认值是none，不继承，设置元素的整个轮廓的样式；</span><br><span class="line">        属性值类型：同border-style类型；</span><br><span class="line">    outline-width：默认值是medium，不继承，设置元素整个轮廓的宽度；</span><br><span class="line">        属性值类型：同border-width类型；</span><br><span class="line">    ★注释：请始终在outline-color和outline-width属性之前声明 outline-style 属性，元素只有获得轮廓以后才能改变其轮廓的颜色和宽度！！</span><br><span class="line"></span><br><span class="line">border-radius属性：简写属性（按上左、上右、下右、下左水平/...垂直顺序认定，至少*-top-left-*水平半径），默认值是0，不继承，用于在一个声明中设置所有四个border-*-*-radius属性，；</span><br><span class="line">    结构： border-radius: border-top-left-radius水平半径 [*-top-right-*] [*-bottom-right-*] [*-bottom-left-*]/border-top-left-radius垂直半径 [*-top-right-*] [*-bottom-right-*] [*-bottom-left-*];</span><br><span class="line">        border-radius: 10px 20px/30px;</span><br><span class="line">    ☆注：如果省略bottom-left，则与top-right相同；如果省略bottom-right，则与top-left相同；如果省略top-right，则与top-left相同。若垂直半径全没有则分别与其水平半径相同。</span><br><span class="line">    属性值类型：</span><br><span class="line">        length      带CSS单位的具体长度；</span><br><span class="line">        %       水平方向以边框宽度为基准，垂直以边框高度为基准。 </span><br><span class="line">    子属性：</span><br><span class="line">    border-top-left-radius：默认值是0，不继承，设置左上边框四分之一椭圆角的水平半径和垂直半径，0时代表直角；</span><br><span class="line">        结构： border-top-left-radius: horizontal vertical;</span><br><span class="line">    border-top-right-radius：...；</span><br><span class="line">    border-bottom-left-radius：...；</span><br><span class="line">    border-bottom-right-radius：...；</span><br><span class="line"></span><br><span class="line">★★★★用border配合border-radius可以画出：</span><br><span class="line">    空心形状[含padding、content区域]：</span><br><span class="line">    圆角框、正圆框、椭圆框、半圆框、扇形框；</span><br><span class="line">    实心形状[只含border，其他为0]：</span><br><span class="line">    直线、各种方形、正圆形、椭圆形、扇形、多色拼盘[圆/方]；</span><br><span class="line">    任意的三角形：该边框的宽度既为三角形的高，而三角形底边宽度被高垂足分割而成的两份，则分别为相邻的两边的宽度；</span><br><span class="line"></span><br><span class="line">box-shadow属性：默认值是none，不继承，用于向整个盒子添加一个或多个阴影（阴影在背景后面且不会透过盒子显示，因为在盒子范围内的阴影部分被剪切掉了不显示）；</span><br><span class="line">    结构： box-shadow: h-shadow v-shadow blue spread color inset[, 第二组阴影设置][...];</span><br><span class="line">        box-shadow: 10px 10px 5px #888888;</span><br><span class="line">    属性值构成：</span><br><span class="line">        h-shadow    水平偏移，必须；</span><br><span class="line">        v-shadow    垂直偏移，必须；</span><br><span class="line">        blur        模糊度；</span><br><span class="line">        spread      阴影扩展尺寸；</span><br><span class="line">        color       阴影颜色；</span><br><span class="line">        inset       ★将外部阴影改为内部阴影，超出盒子范围的部分被剪掉不显示；</span><br><span class="line">    ★★★注意：阴影和轮廓线一样不占位置！！</span><br></pre></td></tr></table></figure><p>④外边距属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">margin属性：简写属性（按上右下左顺序认定，至少有margin-top值），默认值是0，不继承，用于在一个声明中设置当前元素的边框与周围临近的其他元素（包括父元素）边框之间的距离，即元素的四个外边距；</span><br><span class="line">    结构： margin: margin-top margin-right margin-bottom margin-left;</span><br><span class="line">        margin: 19px;</span><br><span class="line">    ☆注：如果省略margin-left，则其与margin-right相同（上+左右+下）；如果再省略margin-bottom，则其与margin-top相同（上下+左右）；如果再省略margin-right，则其与margin-top相同（上下左右）。</span><br><span class="line">    属性值类型：</span><br><span class="line">        0   默认值；</span><br><span class="line">        auto    浏览器自动计算；</span><br><span class="line">        length  带CSS单位的具体数值；</span><br><span class="line">        %   基于★父元素的宽度的百分比。</span><br><span class="line">分属性：</span><br><span class="line">margin-top：设置上外边距；</span><br><span class="line">margin-right：设置右外边距；</span><br><span class="line">margin-bottom：设置下外边距；</span><br><span class="line">margin-left：设置左外边距；</span><br></pre></td></tr></table></figure><p>★★★★注意：margin可以为负值，此时margin的边界进入盒子内部，由于定位过程中是以margin的边界为基准，所以可以使得盒子向通常的反方向移动！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">★★注意：块级元素的垂直相邻外边距会合并（取较大的）。而★行内元素实际上不占上下外边距/内边距，且行内元素的左右外边距也不会合并。同样地，行内块、浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心！！！</span><br></pre></td></tr></table></figure><p>  常用用法：设置容器的左右margin都为auto，可以让容器在父容器内水平居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin:0 auto;</span><br></pre></td></tr></table></figure><p>★区别：让容器在父容器内水平/垂直居中（用margin:auto auto）和让文本内容在容器内水平/垂直居中（用text-align:center和line-height:内容高度★注：纯文本内容只占一行才可能垂直居中，还有若包含行内子元素还要考虑其高度及垂直对齐方式！）  <style></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">    height:100px;</span><br><span class="line">    line-height:100px;</span><br><span class="line">&#125;</span><br><span class="line">.son&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:50px;</span><br><span class="line">    line-height:50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  </style>  …  <div class="father"></div></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;son&quot;&gt;这是内容&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>    结果：文本内容“这是内容”在子div中水平垂直方向都居中，但子div并未在父div内水平或垂直方向居中——text-align只作用于容器内的文本内容以及行内/行内块级子元素，设置每一行内容的水平对齐方式，当  这一行没有被内容排满时才能看出来效果，而line-height只能影响一行中文本内容所占据的高度，实际上一行所占据的总高度还要看该行内排布的行内/行内块级子元素的高度以及垂直对齐方式vertical-align，因  而两者都不能影响块级子容器的位置，若要让块级子容器div居中只能通过margin属性。★注意：虽然margin的默认值是0，但是大多数浏览器本身会有设置一些样式（user agent stylesheet），所以造成某些元素会带有margin，如body带有8px的margin！！</p><p>★注意：某些标签带有浏览器默认的margin或padding值，所以进行页面布局时可以通过通配符选择器事先清除所有的默认设置，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">·body标签带有默认的8px的margin；</span><br><span class="line">·p标签带有默认的1em的上下margin；</span><br><span class="line">·h标签也默认带有默认的上下margin；</span><br><span class="line">·ul标签带有默认的上下margin和左padding；</span><br><span class="line">*&#123;margin:0;padding:0;&#125;</span><br></pre></td></tr></table></figure><p>★margin的两种特殊现象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">·外边距的合并现象（兄弟关系）：垂直相邻的两块级元素，其上下margin会合并起来取其中较大的值（也可以说小的margin“塌陷”进了大的margin之中）；★注：行内元素不占上下margin（对于行内元素上下margin和上下padding都是无效的），浮动时的元素（等同于行内块级元素）不合并；</span><br><span class="line">·外边距的塌陷现象（父子关系）：父子包含的两块级元素，在父元素没有设置border和padding的情况下（至少要top没有才能使上margin直接相邻），给子元素设置margin-top会导致与父元素的margin-top（即使其值为0）塌陷在一起，所以最终会取两者之间最大的margin-top值。而且由于两个margin-top塌陷在了一起，所以父子元素就不能因为子元素的margin-top而分离开。</span><br><span class="line">  解决办法：</span><br><span class="line">    ⒈为父元素设置border或padding（至少要有top，让两个margin无法直接相邻）；</span><br><span class="line">    ⒉为父元素设置overflow:hidden，可以触发元素的bfc——给元素在文档流中设定独立的一块区域；注：overflow属性是设置内容超出元素框时如何显示；</span><br><span class="line">    ⒊让父元素或子元素脱离标准流（浮动、绝对定位、固定定位，即浮动/绝对/固定元素margin不合并）。</span><br></pre></td></tr></table></figure><p>★★★★注意：也有说以上两种都叫margin的“塌陷现象”，而且只有“垂直方向”上“直接相邻”的“块级元素”的“外边距”才会有塌陷——即小的margin“塌陷”进入大的margin之中！！！</p><p>⑤背景属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">background属性：简写属性（没有必需子属性，★子属性不显式设置则设为其默认值），无默认，不继承，用于在一个声明中设置背景颜色、背景图片、背景图片重复方式以及背景图片位置等背景属性；</span><br><span class="line">    结构： background: [background-color] background-image background-repeat background-position[, 第二组背景设置][, 第三组背景设置][...];</span><br><span class="line">        background: red url(...) no-repeat left top;</span><br><span class="line">        background: url(...) no-repeat left top, url(...) no-repeat left bottom, blue url(...) no-repeat right top;</span><br><span class="line">    ★★★★注意：可以给一个元素设置多重背景图片，但却不能设置多重背景颜色，只有最后一组背景设置中可以设置背景颜色（☆前面设置了会报错）！！！</span><br><span class="line">              多重设置是指在同一个声明中同时设置多个背景图片，若不在同一个声明中的设置，则只会相互★层叠★而不会同时显示！！！</span><br><span class="line">              元素的整个背景绘制区域是受background-clip属性控制，默认是border-box元素的边框盒子大小（即全部尺寸），包括内边距和边框在内，但不包括外边距！！！</span><br><span class="line">              元素的背景图片不同于背景颜色（占满整个绘制区），它需要由background-origin对应的基准位置和background-position对应的偏移位置这两个属性来确认位置，默认情况下相对于</span><br><span class="line">              padding-box来定位的！！！</span><br><span class="line">    子属性：</span><br><span class="line">    background-color：默认值transparent，不继承，用来设置背景颜色（绘制在background-clip对应的整个背景区域，位于背景图片之下）；</span><br><span class="line">        结构： background-color: red;</span><br><span class="line">        属性值类型：</span><br><span class="line">            transparent 默认值，透明背景；</span><br><span class="line">            其他颜色相关；</span><br><span class="line">    background-image：默认值是none，不继承，用来设置背景图片（由*-origin和*-position确认第一幅基础背景图片的位置，*-size设置显示大小，*-repeat设置重复方式，覆盖在背景色之上）；</span><br><span class="line">        属性值类型：</span><br><span class="line">            none            默认值，不显示背景图片；</span><br><span class="line">            url(&apos;URL&apos;)      图像的路径；</span><br><span class="line">            linear-gradient(参数) 线性渐变；</span><br><span class="line">            radial-gradient(参数) 径向渐变；</span><br><span class="line">    ★★★★线性渐变：</span><br><span class="line">            linear-gradient(方向d, 起始颜色 [起始位置], 终止颜色 [终止位置])</span><br><span class="line">            ①默认的渐变图片绘制范围为background-origin对应的背景图片基准区域；</span><br><span class="line">            ②如果通过background-size设置了每张背景图片的范围大小，则以此作为每个渐变背景图片的绘制范围；</span><br><span class="line">            ③可以不用设置渐变的起始和终止位置，此时以0%位置为起点，100%位置为终点；</span><br><span class="line">            linear-gradient(方向d, 颜色1 起始位置1, 颜色2 起始位置2, 颜色3 起始位置3,...,颜色n 起始位置n)</span><br><span class="line">            ①在方向d上，起始位置1之前的颜色为纯的颜色1，起始位置n之后的颜色为纯的颜色n；</span><br><span class="line">            ②以起始位置1为开始，起始位置2为终止，第一组线性渐变由颜色1逐渐过渡至颜色2；</span><br><span class="line">            ③以起始位置2为开始，起始位置3为终止，第二组由颜色2逐渐过渡至颜色3；</span><br><span class="line">            ④以此类推……；</span><br><span class="line">            参数值类型：</span><br><span class="line">                方向d     关键字to top|right|bottom|left或者数字度数deg（以垂直向上为0deg，顺时针增加角度）；</span><br><span class="line">                起始位置    百分比%，以渐变图片绘制区域大小为基准；</span><br><span class="line">    ★★★★径向渐变：radial-gradient(渐变半径 at 渐变中心, 起始颜色, 终止颜色)</span><br><span class="line">            ①绘制范围同线性渐变；</span><br><span class="line">            参数值类型：</span><br><span class="line">                渐变半径    数字长度length；</span><br><span class="line">                渐变中心    关键字top|center|bottom left|center|right，无关顺序，只设置一个则另一个默认设置center；</span><br><span class="line">                        或者具体数字长度h_length v_length，第一个水平偏移，第二个垂直偏移，缺省默认50%；</span><br><span class="line">                        或者百分比%，以渐变绘制范围为基准。</span><br><span class="line">                </span><br><span class="line">    background-repeat：默认值是repeat，不继承，用来设置重复方式（需要有背景图片存在）；</span><br><span class="line">        属性值类型：</span><br><span class="line">            no-repeat/repeat/repeat-x/repeat-y；</span><br><span class="line">    background-position：默认值0% 0%，不继承，用来设置背景图片的起始位置（需要有背景图片存在）；</span><br><span class="line">        ★★★★注意：这里实际是设置偏移距离（实际效果根据基准而定），而background-origin里设置的就是基准位置！！！</span><br><span class="line">        属性值结构及类型：</span><br><span class="line">            position position               英文left/center/right top/center/bottom，无关前后顺序，只设一个则另一个默认center；</span><br><span class="line">            x% y%                       x是水平方向（以宽度为基准），y是垂直方向（以高度为基准），少一个默认50%；</span><br><span class="line">            xpos ypos                   带CSS单位的具体长度值，只设一个则另一个默认50%；</span><br><span class="line">        ☆以上属性值类型可以混用：</span><br><span class="line">            left 92px;</span><br><span class="line">            50% -100px;</span><br><span class="line">            120px top;</span><br><span class="line"></span><br><span class="line">    background-size：默认值是auto，不继承，用来设置一张背景图片的尺寸；</span><br><span class="line">        属性值结构及类型：</span><br><span class="line">            auto            默认值，根据图片本身大小来设置；</span><br><span class="line">            b_width b_height    带CSS单位具体长度，（通常）只设一个宽度则另一个高度默认auto（即按比例缩放，若两个都设可能导致失真）；</span><br><span class="line">            % %         以元素宽/高度的百分比来设置图片宽/高，（通常）只设置宽度则另一个默认auto（即按比例缩放，若两个都设可能导致失真）；    </span><br><span class="line">            cover           表示在完全覆盖背景范围的前提下尽可能多的显示图片，但不一定完全显示出来，不满足条件时按原始缩放比去缩放图片；</span><br><span class="line">            contain         表示完全显示背景图片的前提下尽可能多的覆盖背景范围，但不要求一定完全覆盖，不满足条件时按原始缩放比去缩放图片；</span><br><span class="line"></span><br><span class="line">    background-origin：默认值是padding-box，不继承，用来规定background-position属性相对于什么位置为基准来进行定位；</span><br><span class="line">        ★★★★注意：这里是设置背景图片的基准位置，而background-position设置的是基于此的偏移距离！！！</span><br><span class="line">            ★★注意：如果背景图像的background-attachment属性为&quot;fixed&quot;，则该属性没有效果！！</span><br><span class="line">        属性值类型： </span><br><span class="line">            content-box 背景图像相对于内容框来定位；</span><br><span class="line">            padding-box 默认值，背景图像相对于内边距框来定位； </span><br><span class="line">            border-box  背景图像相对于边框盒来定位。</span><br><span class="line"></span><br><span class="line">    background-clip：默认值是border-box，不继承，用来设置整个背景（包括背景颜色和图片）的绘制区域，超出该区域的部分不显示；</span><br><span class="line">        属性值类型：</span><br><span class="line">            border-box  默认值，背景被裁剪到边框盒；</span><br><span class="line">            padding-box 背景被裁剪到内边距框； </span><br><span class="line">            content-box 背景被裁剪到内容框 。</span><br><span class="line"></span><br><span class="line">    background-attachment：默认值是scroll，不继承，用来设置背景图像是相对浏览器固定还是相对于该元素固定；</span><br><span class="line">        属性值类型：</span><br><span class="line">            scroll      默认值，背景图像会随着页面其余部分的滚动而移动——相对于该元素固定； </span><br><span class="line">            fixed       当页面的其余部分滚动时，背景图像不会移动——相对浏览器固定。</span><br></pre></td></tr></table></figure><p>★★★★注意：给body设置背景时，该背景并不以body为基准，而是以整个浏览器窗口为基准，作为整个浏览器窗口的背景！！！奇怪！！</p><p>⑥字体属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">font属性：简写属性（★至少要指定字体大小和类型，且书写顺序不能乱，未设置的属性采用默认值），无默认，可继承属性，用于在一个声明中设置字体样式、异体、粗细、大小/行高和类型等所有字体属性；</span><br><span class="line">    结构： font: font-style font-variant font-weight font-size/line-height font-family;</span><br><span class="line">        font: italic normal bold 10px/2em &quot;黑体&quot;;</span><br><span class="line">    子属性：</span><br><span class="line">    font-style：默认值是normal，可继承属性，设置字体的样式；</span><br><span class="line">        属性值类型：</span><br><span class="line">            normal      默认值，标准体；</span><br><span class="line">            italic      斜体；</span><br><span class="line">    font-variant：默认值是normal，可继承属性，设置字体的异体；</span><br><span class="line">        属性值类型：</span><br><span class="line">            normal      正常标准体；</span><br><span class="line">            small-caps  小型大写体；</span><br><span class="line">    font-weight：默认值normal，可继承属性，设置字体的粗细；</span><br><span class="line">        属性值类型：</span><br><span class="line">            100-900     整百数值；</span><br><span class="line">            lighter     更细；</span><br><span class="line">            normal(400) 默认值，标准；</span><br><span class="line">            bold(700)   粗体；</span><br><span class="line">            bolder      更粗。</span><br><span class="line">        ☆注：是否有对应的粗细变化依赖于字体类型中所包含的粗细样式有多少！</span><br><span class="line">    font-size/line-height：</span><br><span class="line">        font-size：默认值是medium，可继承属性，设置字体的大小（即字符框的大小）；</span><br><span class="line">            属性值类型：</span><br><span class="line">                length  具体数字长度（单位px像素/pt磅等）；</span><br><span class="line">                %   基于父元素；</span><br><span class="line">                small   小；</span><br><span class="line">                medium  默认值；</span><br><span class="line">                large   大；</span><br><span class="line">        line-height：默认值是normal，可继承属性，设置文本行的高度；</span><br><span class="line">        ★★★★注意：一个文本行所占的高度，既不一定是文字字体的高度，也不一定等于这一行单元所有内容所占据的实际总高度！</span><br><span class="line">                该属性会影响行框的布局，在应用到一个块级元素时，它定义了该元素中基线之间的最小距离而不是最大距离。line-height与font-size的计算值之差（在CSS中成为“行间距”）</span><br><span class="line">                分为两半，分别加到一个文本行内容的顶部和底部，而可以包含这些内容的最小框就是行框——文本行。</span><br><span class="line">            属性值类型：</span><br><span class="line">                normal  默认值，通常根据当前字体大小设置一个略大的行高；</span><br><span class="line">                length  带CSS单位的具体数字长度（px像素/em当前字体单位宽度等）；</span><br><span class="line">                %   基于当前字体尺寸；</span><br><span class="line">                number  纯数字，与当前字体尺寸相乘得到行间距。</span><br><span class="line">        ★★★★注意：纯数字与带em或%的数值长度在继承时的区别！！！</span><br><span class="line">        ★★★★注意：带em或%的属性值都是以当前元素的字体大小为基准，所以继承时是先将当前行高结果计算出来，然后继承给子元素该结果，而不是继承原数值；</span><br><span class="line">                  当属性值是纯数字时，虽然同样是以当前字体大小为基准，但却是直接将该纯数字继承给子元素，所以子元素中的行高需要以子元素的字体为基准重新计算！！！</span><br><span class="line">            作用：设置行高等于容器高度可以使文本垂直居中。</span><br><span class="line">            ★注意：单独设置行高时，必须要在font属性之下或之中（若有font），因为font属性中有默认设置的line-height！</span><br><span class="line"></span><br><span class="line">    font-family：无默认值，可继承属性，设置字体的类型；</span><br><span class="line">        结构： font-family: family1[,family2][,family3][...];</span><br><span class="line">        ★注意：可以同时设置多种字体类型，作为一个回退系统来保存——如果浏览器不支持第一个字体，则会尝试下一个！</span><br><span class="line">        属性值类型：</span><br><span class="line">            汉字名称    如宋体、微软雅黑、黑体等，必须加&quot;&quot;括起来；</span><br><span class="line">            英文名称    每种字体都有英文名，可以不加&quot;&quot;；</span><br><span class="line">            编码      字体都有对应编码。</span><br></pre></td></tr></table></figure><p>★★★★详解：文本行不同于行单元！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.文本行用来存放文本内容，其高度仅由line-height属性决定。默认情况下浏览器会根据当前文字字体大小设置一个合适的行高（通常要比文字高一点且上下等间距），且文本在文本行内基本垂直居中显示</span><br><span class="line">（因文字是放在文本框的基线上，文本框就是文字图片的外边框，本质是文本图片在文本行内垂直居中）；但有设置或继承行高的情况下，文字大小（实际上即文本框大小）就不一定小于行高，文字大于行高</span><br><span class="line">  时便会超出文本行显示（仍然居中），此时要注意垂直相邻的文本行的文字内容便会相互遮盖（如果文本行是紧密相邻的）；行内/行内块级元素以及浮动元素在同一行单元显示时会占据文本行的宽度，但</span><br><span class="line">  不影响文本行高度。</span><br><span class="line">2.行内元素的高度仅由内容决定——准确地说此处受文本行以及文本框共同影响，当文字大小高于行高时，行内元素高度还包括文字字体超出文本行的那一部分，简单地说行内元素的高度由行单元和文字超出</span><br><span class="line">  部分共同决定；块级元素和行内块级元素的默认高度也由内容决定——但此处高度仅受文本行的高度影响，超出文本行的文本字体不再算入在内，简单地说块及行内块的默认高度仅由行单元总高度决定。</span><br><span class="line">3.行单元是HTML元素默认按行排列时的结构单元，其中块级元素完全占据一个行单元，此时该行内不能存在其他文本行、行内或行内块级元素等，而该行单元的高度仅由该块元素决定（盒子高度+上下外边距）；</span><br><span class="line">  而行内/行内块级元素、浮动元素以及文本内容则可以在同一行单元内排布，此时行单元的高度是根据文本行高度、行内子元素文本行高度和行内块级子元素盒子加外边距高度及其垂直对齐方式vertical-align</span><br><span class="line">  共同决定，但不受文字大小、浮动元素直接影响。</span><br><span class="line">★注意：行内、行内块以及浮动元素排布时一定存在一个文本行（即使父元素内没有文字），其中行内元素固定是将其中线对齐该文本行的中线，而行内块级元素的垂直对齐方式受到其vertical-align属性的控制，</span><br><span class="line">    浮动元素则固定是top将其顶端与该行最高元素的顶端对齐！！！</span><br><span class="line"></span><br><span class="line">line-height行高模型：文本内容的相邻两行间基线到基线的最小距离=上间隔+文本框高度+下间隔=文本行的高度；</span><br><span class="line">    上间距     填充距离        ┓</span><br><span class="line">    顶线      文本框的上边线 ┓   ┃</span><br><span class="line">    中线      文本框的中线  ┃字体 ┃文本行</span><br><span class="line">    基线      文本框的基准线 ┃大小 ┃高度 ┓</span><br><span class="line">    底线      文本框的下边线 ┛   ┃   ┃</span><br><span class="line">    下间距     填充距离        ┛   ┃</span><br><span class="line">    上间距     填充距离        ┓   ┃行高line-height定义</span><br><span class="line">    顶线      文本框的上边线 ┓   ┃   ┃</span><br><span class="line">    中线      文本字体的中线 ┃字体 ┃文本行┃</span><br><span class="line">    基线      文本字体的基准线┃大小 ┃高度 ┛</span><br><span class="line">    底线      文本框的下边线 ┛   ┃</span><br><span class="line">    下间距     填充距离        ┛</span><br></pre></td></tr></table></figure><p>⑦文本属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">color属性：无默认，可继承属性，设置元素的前景（即文本及修饰线、边框currentColor默认颜色）颜色；</span><br><span class="line">direction属性：默认值是ltr，可继承属性，设置文本的方向/书写方向；</span><br><span class="line">    属性值类型：</span><br><span class="line">        ltr 默认值，从左到右；</span><br><span class="line">        rtl 从右到左。</span><br><span class="line">letter-spacing属性：默认值是normal（即0），可继承属性，设置字符间距；</span><br><span class="line">    属性值类型：</span><br><span class="line">        normal 默认值，规定字符间没有额外的空间； </span><br><span class="line">        length 定义字符间的固定空间（允许使用负值）。</span><br><span class="line">line-height属性：见上；</span><br><span class="line">    用法：行高等于容器height高度（盒子模型中内容高度）则可以使文本（在盒子模型的内容部分）垂直居中；</span><br><span class="line">text-align属性：默认值是left（ltr）/right（rtl），可继承属性，设置文本（及容器行内/行内块子元素）的水平对齐方式；</span><br><span class="line">    属性值类型：</span><br><span class="line">        left    左对齐；</span><br><span class="line">        right   右对齐；</span><br><span class="line">        center  水平居中；</span><br><span class="line">        justify 两端对齐。</span><br><span class="line">★★注意：text-align属性只影响容器内的文本内容以及行内或行内块级子元素，line-height只影响一行内的文本内容占据的行高度，对于块级子元素的位置都没有作用！！！</span><br><span class="line">      text-align属性是 justify 时，表示每一行的内容按照 基准宽度 两端对齐，且中间平均分布；</span><br><span class="line">      所以，通常需要在每一行的底部添加一个 100% 宽度的 隐形 行内块级元素，来使每一行的所有文字都在该容器内两端对齐，中间均分；</span><br><span class="line">        text-align: justify;</span><br><span class="line">        &amp;:after &#123;</span><br><span class="line">            content:&quot;&quot;;</span><br><span class="line">            display:inline-block;</span><br><span class="line">            width:100%;</span><br><span class="line">            height:0;</span><br><span class="line">            line-height:0;</span><br><span class="line">            visibility:hidden;</span><br><span class="line">        &#125;</span><br><span class="line">text-indent属性：默认值是0，可继承属性，设置文本的首行缩进长度（可以为负，悬挂缩进，通过设置padding显示）；</span><br><span class="line">    属性值类型：</span><br><span class="line">        0   默认值；</span><br><span class="line">        length  具体数值长度（CSS单位常用em）；</span><br><span class="line">        %   基于父元素宽度。</span><br><span class="line">text-decoration属性：默认值是none，可继承属性，设置文本的装饰效果；</span><br><span class="line">    属性值类型：</span><br><span class="line">        none        无装饰；</span><br><span class="line">        underline   下划线；</span><br><span class="line">        overline    上划线；</span><br><span class="line">        line-through    删除线；</span><br><span class="line">text-shadow属性：默认值是none，可继承属性，用来给文字添加一重或多重的阴影效果；</span><br><span class="line">    结构： text-shadow: h-shadow v-shadow blur color[, 第二组设置][...];</span><br><span class="line">                 水平偏移 垂直偏移 模糊度 颜色</span><br><span class="line">    ★注意：其中阴影偏移位置是必须的，还可以同时设置多个阴影，多个设置之间用逗号隔开！</span><br><span class="line">    用法：可以利用文字阴影产生凹凸的立体文字效果，1px向上向左的白色阴影+1px向下向右的黑色阴影=凸起效果，1px向下向右的白色阴影+1px向上向左的黑色阴影=凹陷效果；</span><br></pre></td></tr></table></figure><p>★★★★超出文本隐藏并显示”…”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">■单行显示：</span><br><span class="line">&#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow:ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">■多行显示(最后一行的末尾隐藏)：</span><br><span class="line">&#123;</span><br><span class="line">    -webkit-line-clamp: 2;              //必须属性，用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性</span><br><span class="line">    -webkit-box-orient: vertical;           //必须属性，设置或检索伸缩盒对象的子元素的排列方式</span><br><span class="line">    display: -webkit-box;               //必须属性，将对象作为弹性伸缩盒子模型显示</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    word-break: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑧列表属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">list-style属性：简写属性（没有必需子属性，★子属性不显式设置则设为其默认值），默认值是disc outside none，可继承属性，用于在一个声明中设置所有的列表属性；</span><br><span class="line">    结构： list-style: list-style-type list-style-position list-style-image;</span><br><span class="line">    ★★★★注意：它只能应用到所有display为list-item的元素——即li标签元素，所以在普通的HTML和XHTML中只能用于li元素，不过实际上它可以应用到任何元素，并由li元素继承；</span><br><span class="line">    子属性：</span><br><span class="line">    list-style-type：默认值是disc，可继承属性，设置列表项标记的类型；</span><br><span class="line">        属性值类型：</span><br><span class="line">            none    无；</span><br><span class="line">            disc    默认值，实心圆；</span><br><span class="line">            circle  空心圆；</span><br><span class="line">            square  实心方块；</span><br><span class="line">            decimal 数字。</span><br><span class="line">    list-style-position：默认值是outside，可继承属性，设置列表项标记相对于列表项内容的位置；</span><br><span class="line">        属性值类型：</span><br><span class="line">            outside 默认值，保持标记位于文本的左侧，列表项目标记放置在文本以外，且环绕文本不根据标记对齐 ；</span><br><span class="line">            inside  列表项目标记放置在文本以内，且环绕文本根据标记对齐。 </span><br><span class="line">    list-style-image：默认值是none，可继承属性，设置图像来替换列表项的标记；</span><br><span class="line">        属性值类型：</span><br><span class="line">            none    默认值，无图片显示；</span><br><span class="line">            url()   图片的URL路径；</span><br></pre></td></tr></table></figure><p>⑨表格属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">border-collapse属性：默认值是separate，可继承属性，用于设置表格的边框（包括内部的th和td）是否被合并为一个单一的边框；</span><br><span class="line">    属性值类型：</span><br><span class="line">        separate    默认值，边框会被分开；</span><br><span class="line">        collapse    边框会合并为一个单一的边框；</span><br><span class="line">    ★★★注意：当设置边框模型为合并collapse时，会忽略border-spacing和empty-cells属性！！！</span><br><span class="line">border-spacing：无默认，可继承属性，用于设置表格中相邻单元格边框之间的距离（仅用于separate边框分离模式）；</span><br><span class="line">    属性值类型：</span><br><span class="line">        length      单一数值长度；</span><br><span class="line">        length length   两个数值长度（分别表示水平与垂直间距）；</span><br><span class="line">caption-side：默认值是top，可继承属性，用于设置表格标题位置；</span><br><span class="line">    属性值类型：</span><br><span class="line">        top     表格之上；</span><br><span class="line">        bottom      表格之下。</span><br><span class="line">empty-cells：默认值是show，可继承属性，用于设置表格上的空单元格的边框和背景是否显示（仅用于separate边框分离模式）；</span><br><span class="line">    属性值类型：</span><br><span class="line">        hide        不在空单元格周围绘制边框；</span><br><span class="line">        show        默认值，在空单元格周围绘制边框。</span><br></pre></td></tr></table></figure><p>⑩用户界面属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box-sizing属性：默认值是content-box，不继承，用于设置元素的宽高所代表的范围；</span><br><span class="line">    属性值类型：</span><br><span class="line">        content-box 默认值，这是由CSS2.1规定的宽度高度行为——宽度和高度分别应用到元素的内容框，并在★宽度和高度之外★绘制元素的内边距和边框；</span><br><span class="line">        border-box  元素设定的宽度和高度决定了元素的边框盒，为元素指定的任何内边距和边框都将在已设定的★宽度和高度内★进行绘制。通过从已设定的宽度和高度分别减去边框和内边</span><br><span class="line">                距才能得到内容的宽度和高度。</span><br></pre></td></tr></table></figure><p>⑻CSS浮动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网页标准流：元素在浏览器中的默认显示方式；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float属性：默认值是none，不继承，用于设置元素在哪个方向浮动，最初是为了解决文字环绕图片而产生，不过任何元素都可以浮动；</span><br><span class="line">结构：float: left|right|none;</span><br><span class="line">属性值类型：</span><br><span class="line">none默认值，表示元素不浮动，显示在标准流中的原位置；</span><br><span class="line">left向做浮动；</span><br><span class="line">right向右浮动。</span><br><span class="line"></span><br><span class="line">★特点：⒈浮动可以实现模式转换；</span><br><span class="line">设置元素的float属性非none时，则该元素等价为inline-block行内块级元素使用（此时忽视给该元素设置的display属性值，而所设置的宽高属性将起作用），它会与前后直接相邻的行内或行内块级元</span><br><span class="line">素以及文本内容一起按行排布。</span><br><span class="line">⒉浮动的元素脱离标准流——在标准流中不占位置（★★★★准确讲是不占体积，即不占高度，但占宽度）；</span><br><span class="line">①浮动元素在一行内只占据宽度，其所在行单元占据的实际高度与该行内的所有浮动元素无关，不受其高度影响，而浮动元素的垂直对齐方式固定为top顶端与行内最高元素顶端对齐；</span><br><span class="line">②这些浮动元素之前的同级块级元素（如果有）的位置不会受到影响（★注：块级元素独占一整行而不论其宽度大小，而独占的高度也不受line-height影响）；</span><br><span class="line">  不过这些元素之后的块级元素则会无视浮动元素设置的高度及体积存在（★即浮动元素在标准流中的体积被视为0）来排布，因而这些块级元素可能会被浮动元素所覆盖；</span><br><span class="line">  但这些块级元素并不会忽视与浮动元素同行的那些非浮动内容的体积，更不会被这些非浮动元素覆盖，即如果浮动元素的同行有其他非浮动内容，则后面的块级元素就不能忽视该行的存在，</span><br><span class="line">  因为这一行单元在标准流中仍具有高度，只是该行单元的总高度与浮动元素无关；</span><br><span class="line">③行内或行内块级元素以及文本内容则不能忽视浮动元素，因为浮动元素会在其所覆盖的行内占据宽度，而不论这些元素与浮动元素是否属于同一行或是否在同一级，他们都不会被浮动元素</span><br><span class="line">  所覆盖，而只会被浮动元素“挤走”——在排布这些非块级元素时，首先排布确定所有浮动元素的位置及体积，同一行内浮动方向相同的按原本的先后次序排列，若一行排布不下则换行排布，</span><br><span class="line">  然后在每一行没有被浮动元素占据的剩余位置来依次安排其他非浮动内容，若排布不下就换下一行排布，直到某一行能够排布为止（此时可能已越界排布）；</span><br></pre></td></tr></table></figure><p>★★★★清除浮动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clear属性：默认值是none，不继承，用于设置该元素上不允许通过（即显示或覆盖）哪一种浮动元素，若有对应的这些浮动元素便（增加清除区域高度）向下移动到刚好使其不通过的位置；</span><br><span class="line">结构：clear:both;</span><br><span class="line">属性值类型：</span><br><span class="line">none不清除浮动；</span><br><span class="line">left清除左浮动；</span><br><span class="line">right清除右浮动；</span><br><span class="line">both清除所有浮动；</span><br><span class="line"></span><br><span class="line">★浮动元素会造成的麻烦：在父元素没有设置高度的情况下，其高度会根据内容所占据的高度来决定，然而当其中的某子元素被设置浮动时体积会被标准流视作是0，这便可能导致无法撑起父元素的高度值，使得该子</span><br><span class="line">元素溢出到父元素之外显示（浮动元素不影响该行占据的实际高度，同时自然也无法撑起体积），尤其是当父容器中只包含了浮动元素，那其高度便为0。</span><br><span class="line">★解决办法：⒈额外标签法（父同级）——在该父元素下面加上一个设置了清除左右浮动的块级元素（其高度可以为0，宽度默认），由于左右浮动的元素无法在其上显示（通过或覆盖），因而它便可作为一条（隐形的）</span><br><span class="line">界限，使得该父元素内的浮动子元素无法越过此“界限”显示，进而消除了对后面元素的影响。</span><br><span class="line">缺点：父元素仍然没有高度。</span><br><span class="line">⒉额外标签法（子同级）——在其子元素下面加上一个设置清除左右浮动的块级子元素（其高度可以为0，宽度默认），由于左右浮动的元素无法在其上显示（通过或覆盖），因而它便可作为一条（隐形的）</span><br><span class="line">界限，使得该父元素内的浮动子元素无法越过此“界限”显示，同时在实现浮动清除时所增加的“清除区域”又会撑起父元素的高度。</span><br><span class="line">优点：父元素拥有高度。</span><br><span class="line">缺点：需要额外的标签。</span><br><span class="line">⒊设置overflow——给父元素设置&quot;overflow:hidden;&quot;。</span><br><span class="line">优点：父元素拥有高度且不需要额外的标签。</span><br><span class="line">缺点：超出父元素所在区域的部分会被隐藏。</span><br><span class="line">⒋设置伪元素（子同级）——设置父元素的:after伪元素为块级元素并清除左右浮动，content内容为&quot;&quot;（★必须要有，否则没作用），高度和行高为0，并设置visibility为hidden，为兼容IE6设置父元素“*zoom:1”，将其作为隐藏的浮动“界限”。</span><br><span class="line">.clearfix::after &#123;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">line-height: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">display: block;</span><br><span class="line">clear: both;</span><br><span class="line">visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">优点：父元素拥有高度且不需要额外的标签。</span><br></pre></td></tr></table></figure><p>⑼CSS初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先将页面中标签默认的样式（内外边距、文字大小、文字颜色、文字字体...）恢复到原始的状态；</span><br><span class="line">将页面中标签的样式设置为统一的样式；</span><br><span class="line"></span><br><span class="line">1.清除要使用的标签中浏览器默认设置的margin和padding；</span><br><span class="line">2.清除img标签的边框（IE6中默认设置有边框）；</span><br><span class="line">3.清除ul和ol中每行前的标记，设置list-style为none；</span><br><span class="line">4.设置body的属性；</span><br></pre></td></tr></table></figure><p>网页导航：★注意：使用a标签直接制作网页导航时的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⒈导航元素之间应该是列表中不同列表项的关系，如果想要将这种关系通过html语义化表现出来，就必须使用ul标签，然后将超链接放在li标签里面；</span><br><span class="line">⒉如果不用其他的标签包裹这些超链接，那么将来浏览器将这些a标签中的文字当作全部一起显示，SEO就会认为这个页面进行了关键字的堆砌，将此作为作弊页面列入黑名单。</span><br><span class="line">所以必须使用ul标签中的li标签将a中的内容包裹起来！</span><br></pre></td></tr></table></figure><p>⑽CSS定位：通过设置position及配套属性来定位元素的位置；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">position属性：默认值是static，不继承，用来设置元素的定位类型；</span><br><span class="line">属性值类型：</span><br><span class="line">static静态定位元素，元素出现在标准流中的原位置，此时忽略top、bottom、left、right或者z-index声明；</span><br><span class="line">absolute绝对定位元素，它相对于第一个不是static定位的父元素进行定位（★注：body元素默认不是static定位，★还必需要配合top|bottom（对应垂直方向）、left|right（对应水平方向）一同使用，若没有设置控制水平/垂直方向位置的属性，元素就仍在原水平/垂直位置），使用top、bottom、left、right和z-index属性进行规定；</span><br><span class="line">fixed固定定位元素，它相对于浏览器窗口进行定位（无论怎么滚动都不会改变位置），使用...进行规定；</span><br><span class="line">relative相对定位元素，它相对于其在标准流中的正常位置进行定位，...；</span><br><span class="line">★★★★特点：</span><br><span class="line">绝对定位/固定定位：</span><br><span class="line">1.设置absolute或fixed时元素会脱离标准流，不占位置（★★★★即不占体积，与float不同的是，此时既不占高度也不占宽度，意味着不能挤走行内、文本等内容，也不能形成文字环绕！！！）；</span><br><span class="line">2.当元素脱离标准流时，如设置浮动、绝对定位、固定定位，隐含对该元素进行模式转换，等价于inline-block行内块使用，且忽视display属性的设置；</span><br><span class="line">3.使用清除浮动不能清除定位产生的脱标元素。</span><br><span class="line">相对定位：</span><br><span class="line">1.设置relative时元素不会脱离标准流，仍然占据原来位置！</span><br><span class="line">2.没有模式转换；</span><br><span class="line">★注意：标准流块元素居中显示——</span><br><span class="line">margin: 0 auto;只能让标准流的盒子居中，auto对脱标元素不管用；</span><br><span class="line">绝对定位（脱标）的元素居中显示？</span><br><span class="line">left: 50%;相对父元素的宽度移动一半；</span><br><span class="line">margin-left: -100px;反向移动元素自己宽度一半。</span><br><span class="line"></span><br><span class="line">top属性：默认值是auto，不继承，用来设置该元素的上外边距边界与基准对象的上边界（即上内边距框边界）的距离，正值向下，可以为负；</span><br><span class="line">属性值类型：</span><br><span class="line">auto默认值，通过浏览器计算上边缘的位置；</span><br><span class="line">%以基准元素高度的百分比设置位置，可使用负值；</span><br><span class="line">length以具体的长度值设置元素位置，可使用负值。 </span><br><span class="line">left属性：默认值是auto，不继承，用来设置该元素的左外边距边界与基准对象的左边界（即左内边距框边界）的距离，正值向右，可以为负；</span><br><span class="line">属性值类型：</span><br><span class="line">auto默认值，通过浏览器计算上边缘的位置；</span><br><span class="line">%以基准元素宽度的百分比设置位置，可使用负值；</span><br><span class="line">length以具体的长度值设置元素位置，可使用负值。</span><br><span class="line">right属性：默认值是auto，不继承，用来设置该元素的右外边距边界与基准对象的右边界（即右内边距框边界）的距离，当设置了left时该设置被忽略，正值向左，可以为负；</span><br><span class="line">属性值类型：</span><br><span class="line">auto默认值，通过浏览器计算上边缘的位置；</span><br><span class="line">%以基准元素宽度的百分比设置位置，可使用负值；</span><br><span class="line">length以具体的长度值设置元素位置，可使用负值。</span><br><span class="line">bottom属性：默认值是auto，不继承，用来设置该元素的下外边距边界与基准对象的下边界（即下内边距框边界）的距离，当设置了top时该设置被忽略，正值向上，可以为负；</span><br><span class="line">属性值类型：</span><br><span class="line">auto默认值，通过浏览器计算上边缘的位置；</span><br><span class="line">%以基准元素高度的百分比设置位置，可使用负值；</span><br><span class="line">length以具体的长度值设置元素位置，可使用负值。</span><br><span class="line"></span><br><span class="line">z-index属性：默认值是auto，不继承，用来设置元素的堆叠顺序，必须是整数值，值越大离用户越近、越靠上，可以为负，仅用于非static定位元素；</span><br><span class="line">属性值类型：</span><br><span class="line">auto默认值，相当于序号0但又与0不同；</span><br><span class="line">number纯数字堆叠序号；</span><br><span class="line">★★★★注意：</span><br><span class="line">1.z-index属性只能作用于非static定位的元素，对于static定位的元素设置了也无效；</span><br><span class="line">2.static定位的元素其（在所属的独立层级区域中）实际层级相当于0-△（△表示无穷小），即在auto或者0之下，但又在负值之上；</span><br><span class="line">3.给某个元素设置纯数字堆叠序号时，它的所有子元素相对于该元素之外的其他元素来说，其层级永远与该父元素相同，而不管其本身的层级值大小——即若父元素在某些外部元素之下（上），则其子元素无论设置多高（低）的层级都不可能跑到这些元素上（下）面；</span><br><span class="line">  而在该父元素的内部，其所有的子元素都比该父元素的层级高，而不论其设置的层级值大小——即该父元素构成了一个★独立的层级区域：对外部来说其所包含的所有子元素与其层级相同；对内部来说该父元素的层级相当于-∞；</span><br><span class="line">4.给元素设置层级auto时，相当于在其所在的层级区域内给该元素设置层级为0，但并不会如设置纯数字0一样影响其子元素层级，即不形成新的子层级区域；</span><br><span class="line">5.确认两个元素的堆叠次序时不能仅看它们的z-index值：</span><br><span class="line">首先要找到它们所属的最近的★共同层级区域；</span><br><span class="line">然后从该共同层级区域开始分别去找这两个元素，在所经过路径上如果有遇到子层级区域（即有非static定位的父元素设置了纯数字层级序号），则遇到的第一个子层级区域的层级值，就决定了两者间的层叠关系；</span><br><span class="line">如果没有遇到子层级区域（即经过的父元素static定位或层级auto），其自身的z-index值才会起作用；</span><br><span class="line">6.当对比的层级值相同时，结构上在后的元素靠上。</span><br><span class="line"></span><br><span class="line">★注意：网页布局尽量规避脱标流——优先考虑标准流进行网页布局；</span><br><span class="line">  然后考虑使用浮动（块级元素在一行上显示）；</span><br><span class="line">  最后考虑使用定位（元素压着另外一个元素）；</span><br><span class="line">  如果只是要实现模式转换，必须使用dispaly。</span><br><span class="line"></span><br><span class="line">vertical-align属性：默认值是baseline，不继承，用来设置该行内块级元素在一行中与其他内容的垂直对齐方式；</span><br><span class="line">属性值类型：</span><br><span class="line">baseline行内块基线对齐父元素该行基线；</span><br><span class="line">sub对齐文本下标；</span><br><span class="line">super对齐文本上标；</span><br><span class="line">top行内块顶端与行中最高元素顶端对齐；</span><br><span class="line">text-top行内块顶端与父元素文本顶端对齐；</span><br><span class="line">middle行内块整体中线与文本中线对齐；</span><br><span class="line">bottom行内块底端与行内最低元素底端；</span><br><span class="line">text-bottom行内块底端与父文本底端；</span><br><span class="line">length带CSS单位的具体数值长度（可以为负，表示向基线下移）；</span><br><span class="line">%以line-height为基准（可以为负，表示向基线下移）。</span><br><span class="line">★★★★注意：</span><br><span class="line">1.该属性只能作用于行内块元素和table标签（以及display:table的元素），而不能作用于行内元素；</span><br><span class="line">2.该属性要设置给需要对齐的行内块元素，而不是其父元素；</span><br><span class="line">3.区别于text-align——设置给父元素，控制其里面的所有行内、行内块子元素以及文本水平对齐方式。</span><br><span class="line"></span><br><span class="line">元素的隐藏方式：</span><br><span class="line">overflow属性：默认值是visible，不继承，用来设置内容溢出该元素框时如何显示；</span><br><span class="line">属性值类型：</span><br><span class="line">visible超出部分仍可见；</span><br><span class="line">hidden修剪不可见；</span><br><span class="line">scroll修剪并一直提供水平和垂直滚动；</span><br><span class="line">auto剪切并自动判断是否提供滚动条，不超不供，超出提供。</span><br><span class="line">☆使用：overflow:hidden还有多种用途——解决（外边距）合并|塌陷问题，清除浮动等，通过给透明的(background-color:transparent)父盒子设置 overflow:hidden 属性可以剪切其中的子元素图像，</span><br><span class="line">再配合如 transition 、animation 属性或 animate()方法等动画方式，便可以制作出各部分连续显现的图像！</span><br><span class="line"></span><br><span class="line">visibility属性：默认值是visible，可继承属性，用来设置该元素是否可见，属性值可以是visible/hidden/collapse；</span><br><span class="line">属性值类型：</span><br><span class="line">visible元素是可见的；</span><br><span class="line">hidden元素是不可见的，★但仍然占据原位置；</span><br><span class="line">collapse当用于表格元素时，可删除一行或一列，即该元素不占位置，不影响表格布局；</span><br><span class="line">用于其他元素上时等同于hidden。</span><br><span class="line"></span><br><span class="line">display属性：默认值inline，不继承，用来设置该元素生成时的显示框的类型；</span><br><span class="line">属性值类型：</span><br><span class="line">none该元素不会被显示，★同时不占位置；</span><br><span class="line">block生成块级元素；</span><br><span class="line">inline生成行内元素；</span><br><span class="line">inline-block生成行内块级元素；</span><br><span class="line">list-item等。</span><br></pre></td></tr></table></figure><p>⑾CSS内容移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在使用a标签制作网页logo时，通常采用将logo图片作为a标签的背景图片的方法。</span><br><span class="line">★其中推荐：</span><br><span class="line">在logo超链接中要设置文字内容——目的是利于SEO优化，指明超链接的目标；</span><br><span class="line">同时还要将该文字移除——目的是强化用户体验，利于网页美观。</span><br><span class="line">★移除方法：</span><br><span class="line">★★将首行缩进text-indent设置为“足够大”的负值，以使文字移出浏览器显示范围，如-9999px|-999em等；</span><br><span class="line">将文字颜色color设置为transparent透明；</span><br><span class="line">将文字大小font-size设置为最小值0px；</span><br></pre></td></tr></table></figure><p>⑿CSS Spirit雪碧图/精灵图：将多张小的图片放在一张大的图片上使用；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的：减少浏览器访问页面时发送的请求个数，以减轻服务器处理请求的压力，提高页面加载速度。</span><br><span class="line">使用：1.确定我们想要的那一部分图片在精灵图中的大小及相对位置；</span><br><span class="line">2.显示该部分图片的容器的宽高必须与该部分图片的大小完全一致；</span><br><span class="line">3.将整张精灵图设为容器的背景色，并通过调整背景图片显示位置属性background-position，使得只有想要的部分显示出来——将相对位置取负值。</span><br></pre></td></tr></table></figure><p>⒀CSS滑动门：有时需要给某些盒子设置特殊的图片背景，并且这些盒子的整个背景图片宽度会随着其中文字内容的多少自动适应，这种方法被称为滑动门技术；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本方法：1.由于需要随着文字内容的多少，让盒子宽度自动适应，所以盒子不能设定确定的宽度，而是由内容本身把宽度撑起来；</span><br><span class="line">  2.将该盒子划分为至少有两层的嵌套关系，内层子元素包含文字且宽度自适应，并由内层子元素把外层父元素的宽度撑起来；</span><br><span class="line">  3.由于背景图片需要随着盒子的宽度不同自动适应，所以必须把整个背景图片分割成若干份，如左+中+右|左+中右|左中+右等；</span><br><span class="line">  4.划分的背景块中若包含需随文字多少而自适应变化的区域（即‘中’区域），则应该设定为内层子元素的背景，并通过平铺或者利用背景图超出部分会被自动剪切掉，使该部分背景始终跟随文字多少变化；</span><br><span class="line">  5.而不需要随着文字多少而变化的背景块，则可以放在外层父元素中。</span><br></pre></td></tr></table></figure><p>⒁Webfont与Iconfont：</p><p>Ⅰ.Webfont使得开发人员可以在自己的网页上指定特殊的字体并使用，而用户端即使没有安装该字体也依然能够得到该字体效果；★<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a>★</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">第一步：使用font-face声明字体；</span><br><span class="line">@font-face &#123;</span><br><span class="line">font-family: &quot;font_name&quot;;</span><br><span class="line">src: url(&quot;fontfile_url&quot;) format(&quot;fontfile_type&quot;),...;</span><br><span class="line">&#125;</span><br><span class="line">@font-face &#123;</span><br><span class="line">font-family: &apos;webfont&apos;;</span><br><span class="line">src: url(&apos;webfont.eot&apos;); /* IE9*/</span><br><span class="line">src: url(&apos;webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */</span><br><span class="line">     url(&apos;webfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */</span><br><span class="line">     url(&apos;webfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/</span><br><span class="line">     url(&apos;webfont.svg#webfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */</span><br><span class="line">｝</span><br><span class="line">第二步：定义使用webfont的样式；</span><br><span class="line">.web-font&#123;</span><br><span class="line">font-family:&quot;webfont&quot; !important;</span><br><span class="line">font-size:16px;</span><br><span class="line">font-style:normal;</span><br><span class="line">-webkit-font-smoothing: antialiased;</span><br><span class="line">-webkit-text-stroke-width: 0.2px;</span><br><span class="line">-moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br><span class="line">第三步：为文字加上对应的样式；</span><br><span class="line">&lt;i class=&quot;web-font&quot;&gt;孔子曰：中午不睡，下午崩溃!孟子曰：孔子说的对!&lt;/i&gt;</span><br><span class="line">★总结：本质上就是通过特定的语法格式，自定义一种字体类型并声明存储该字体信息的文件的URL路径、参数及格式，而这些字体文件中就封装着大量字符编码所对应的字体信息，当客户端访问使</span><br><span class="line">用了该字体的网页时，会根据定义中所提供的路径在网络上去寻找并下载具体字体文件，从而在本地没有安装对应字体的情况下，从字体文件中获得该字体样式效果。</span><br><span class="line">★注意：只有在下载的字体文件中包含有某字符编码对应的特定字体样式信息时，才能将该字符的特定字体实际显示出来，而大部分字体文件中通常封装了常用的3000多个汉字的对应字体！！！</span><br><span class="line">★字体文件格式简介：不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。</span><br><span class="line">1、TureType(.ttf)格式</span><br><span class="line">.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；</span><br><span class="line">2、OpenType(.otf)格式</span><br><span class="line">.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；</span><br><span class="line">3、Web Open Font Format(.woff)格式</span><br><span class="line">woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；</span><br><span class="line">4、Embedded Open Type(.eot)格式</span><br><span class="line">.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；</span><br><span class="line">5、SVG(.svg)格式</span><br><span class="line">.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；</span><br><span class="line">☆SVG可缩放矢量图形（Scalable Vector Graphics）：是使用 XML 来描述二维图形和绘图程序的语言；</span><br><span class="line">·SVG 可被非常多的工具读取和修改（比如记事本）；</span><br><span class="line">·SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强；</span><br><span class="line">·SVG 是可伸缩的；</span><br><span class="line">·SVG 图像可在任何的分辨率下被高质量地打印；</span><br><span class="line">·SVG 可在图像质量不下降的情况下被放大；</span><br><span class="line">·SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）；</span><br><span class="line">·SVG 可以与 Java 技术一起运行；</span><br><span class="line">·SVG 是开放的标准；</span><br><span class="line">·SVG 文件是纯粹的 XML。</span><br></pre></td></tr></table></figure><p>Ⅱ.Iconfont：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">■Unicode方法引用：</span><br><span class="line">第一步：拷贝项目下面生成的font-face；</span><br><span class="line">@font-face &#123;</span><br><span class="line">font-family: &apos;iconfont&apos;;</span><br><span class="line">src: url(&apos;iconfont.eot&apos;);</span><br><span class="line">src: url(&apos;iconfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">url(&apos;iconfont.woff&apos;) format(&apos;woff&apos;),</span><br><span class="line">url(&apos;iconfont.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">url(&apos;iconfont.svg#iconfont&apos;) format(&apos;svg&apos;);</span><br><span class="line">&#125;</span><br><span class="line">第二步：定义使用iconfont的样式；</span><br><span class="line">.iconfont&#123;</span><br><span class="line">font-family:&quot;iconfont&quot; !important;</span><br><span class="line">font-size:16px;font-style:normal;</span><br><span class="line">-webkit-font-smoothing: antialiased;</span><br><span class="line">-webkit-text-stroke-width: 0.2px;</span><br><span class="line">-moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br><span class="line">第三步：挑选相应图标并获取字体编码，应用于页面；</span><br><span class="line">&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;</span><br><span class="line">★总结：这种方法本质上就是自定义一种Webfont字体，唯一的区别在于这种字体不是设定某个常见字符的显示样式，而是为某些自定义的转义字符（&amp;#xxx）设置对应的显示图形——字体的本质就是</span><br><span class="line">将计算机内存储的特定编码转换为对应的文字图形以显示；</span><br><span class="line"></span><br><span class="line">■Font-class方法：</span><br><span class="line">第一步：引入项目下面生成的fontclass代码：</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./iconfont.css&quot;&gt;</span><br><span class="line">第二步：挑选相应图标并获取类名，应用于页面：</span><br><span class="line">&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</span><br><span class="line">★总结：这是unicode方法的一种简化封装，它将字体的声明封装到特定的css文件中，并在其中自定义一个使用该声明字体的类，以及对每个转义字符定义一个带有before伪元素的类，在对应类的伪</span><br><span class="line">元素中添加该转义字符。只要同时获得了这两个类名的元素，就会在其内容之前的before伪元素中将对应的转义字符显示为对应的icon图标字体，使用起来要比unicode方法方便。</span><br><span class="line">■symbol方法引用：</span><br><span class="line">第一步：引入项目下面生成的symbol代码：</span><br><span class="line">&lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">第二步：加入通用css代码（引入一次就行）：</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.icon &#123;</span><br><span class="line">width: 1em; height: 1em;</span><br><span class="line">vertical-align: -0.15em;</span><br><span class="line">fill: currentColor;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">第三步：挑选相应图标并获取类名，应用于页面：</span><br><span class="line">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">&lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>⒂CSS过渡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">transition属性：简写属性（无必需，★缺省项设置默认值），默认值all 0s ease 0s ，不继承，用来在一个声明中为元素设置一个或若干个过渡属性，以及每个过渡属性的过渡时间、过渡时间曲线和过渡延时；</span><br><span class="line">结构：transition: transition-property transition-duration transition-timing-function transition-delay[,第二组过渡][...];</span><br><span class="line">transition: all transition-duration transition-timing-function transition-delay;</span><br><span class="line">★注意：如果只提供一个&lt;time&gt;参数，则为transition-duration的值定义；如果提供二个&lt;time&gt;参数，则第一个为transition-duration的值定义，第二个为transition-delay的值定义！</span><br><span class="line">子属性：</span><br><span class="line">transition-property：默认值是all，不继承，用来设置元素中应用过渡效果的CSS属性的名称，当指定的该CSS属性值发生改变时（状态伪类作用时），过渡效果将使其在设定的时间段内连续地变化到最终值，而不是直接修改；</span><br><span class="line">结构：transition-property: all;</span><br><span class="line">transition-property: none;</span><br><span class="line">transition-property: single-transition-property[, single-transition-property][...];</span><br><span class="line">★注意：并不是所有的CSS属性都支持过渡效果，只有支持过渡的属性设置后才能有作用，如大多数长度、颜色、位置类型的属性！！！</span><br><span class="line"></span><br><span class="line">★★过渡的▲本质▲：</span><br><span class="line">当设置元素的某一（支持过渡的）属性的过渡效果后，若页面运行过程中此属性的当前值发生改变时，会在设定的延时过后的过渡时间内按照规定的时间曲线连续地由起始值向终值变化直至</span><br><span class="line">为结果状态，从而产生动画的效果。过渡本质上并不是针对元素本身的状态（如位置、颜色、大小）的改变来进行过渡，有时虽然发生了元素状态的改变，却不会产生过渡效果，这是由于：</span><br><span class="line">①造成元素状态发生改变的变化属性不支持过渡，例如position属性；</span><br><span class="line">②变化的属性支持过渡，但变化前后有一端设置的属性值无法与层叠/被层叠的属性值之间产生过渡过程，如top的默认值auto，border-width的默认值medium；</span><br><span class="line">③变化的属性支持过渡，但变化前后被层叠端没有主动设置该属性的值，要么是该属性的默认值无法与层叠的数值之间产生过渡[本质同②]，要么该属性就没有默认值及属性值——自然无法过渡；</span><br><span class="line">④还有就是多个属性值之间相互影响而造成，例如定位时用bottom或right设置位置，而在伪类中则用top或left重置位置，则虽然元素位置发生了改变，却不会产生连续的过渡位移，</span><br><span class="line">因为在伪类作用于元素之前，元素中并没有主动设置具体的top或left的值（即采取默认值auto，而★auto无法过渡到具体数值），也就不可能让其值过渡到结果状态，当伪类作用</span><br><span class="line">之后，bottom或right的值就被忽视而不起作用了，即使设置新值并可以过渡变化，但也无法产生实际效果。</span><br><span class="line">★★★★综上所述，当出现变化的属性不支持过渡、属性变化前后的属性值之间无法过渡或者属性之间相互影响时，过渡机制中就采取让该属性不过渡——即使其瞬间变化！</span><br><span class="line">★★★★注意：在动画中如果碰到上述情况，采取的是分段取值的方式，这是动画与过渡的一大★主要区别★！！！</span><br><span class="line">总之，利用某些属性的过渡设计动画效果时，必须保证状态改变前后都有这些过渡属性作用于该元素，而且最好明确的设置出其前后值★；</span><br><span class="line"></span><br><span class="line">transition-duration：默认值是0s，不继承，用来设置对象某个或所有过渡效果所花费的时间；</span><br><span class="line">结构：transition-duration: time[,第二个过渡属性的持续时间][...];</span><br><span class="line">★注意：只设置一个值时，代表所有过渡效果具有相同的持续时间，也可以为设置的每个过渡属性分别设置花费的时间！！！</span><br><span class="line">☆注：单位必须是s或ms！</span><br><span class="line">transition-timing-function：默认值是ease，不继承，用来设置某个或所有过渡效果的时间速度曲线；</span><br><span class="line">结构：transition-timing-function: single-transition-timing-function[,第二个过渡属性的时间速度曲线][...];</span><br><span class="line">★注意：同上！</span><br><span class="line">属性值类型：</span><br><span class="line">linear线性过渡，等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)；</span><br><span class="line">ease平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)；</span><br><span class="line">ease-in由慢到快，等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)；</span><br><span class="line">ease-out由快到慢，等同于贝塞尔曲线(0, 0, 0.58, 1.0)；</span><br><span class="line">ease-in-out由慢到快再到慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)；</span><br><span class="line">step-start等同于steps(1, start)；</span><br><span class="line">step-end等同于steps(1, end)；</span><br><span class="line">steps(&lt;integer&gt;[, start|end])接受两个参数的步进函数，第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 </span><br><span class="line">cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 ；</span><br><span class="line">transition-delay：默认值是0s，不继承，用来设置过渡效果开始之前需要等待的时间；</span><br><span class="line">结构：transition-delay: time[,第二个过渡属性的延时时间][...];</span><br><span class="line">★注意：只设置一个值时，代表所有过渡效果具有相同的延时时间，也可以为设置的每个过渡属性分别设置延时的时间！！！</span><br><span class="line">☆注：单位必须是s或ms！</span><br></pre></td></tr></table></figure><p>⒃2D/3D转换[2D/3D变形]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">transform属性：默认值是none，不继承，用于向元素应用一种或多种2D/3D转换的组合，对该元素进行移动、旋转、缩放或倾斜；</span><br><span class="line">结构：transform: none;</span><br><span class="line">transform: transform-function[,transform-function];</span><br><span class="line">属性值类型是一种或多种2D/3D转换函数的叠加或none。</span><br><span class="line">★注意：当属性值是多种转换函数的叠加时，把这些转换★依次★施加在元素上就能得到元素的最终状态，所以一定要注意这些转换的★先后顺序★，因为有的转换可能对其他转换造成影响！！！</span><br><span class="line">★例如：2D旋转与2D位移的先后，元素的结果状态虽然并不会有所不同，但过渡过程中的运动路线却大相径庭，先移后旋——直线，先旋后移——螺旋线；</span><br><span class="line">3D旋转过程中，元素的坐标系会相对地跟着转动，所以使用其他参照坐标系的转换就必须考虑到旋转的影响；</span><br><span class="line">none无转换，即元素的原始状态；</span><br><span class="line">transform-function类型：</span><br><span class="line">Ⅰ.2D转换：</span><br><span class="line">matrix()matrix(&lt;number&gt;[,&lt;number&gt;]&#123;5,5&#125;)，以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，相当于直接应用一个[a,b,c,d,e,f]变换矩阵；</span><br><span class="line">□了解：http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/</span><br><span class="line">□了解：http://help.adobe.com/zh_CN/FlashPlatform/reference/actionscript/3/flash/geom/Matrix3D.html</span><br><span class="line">translate()translate(&lt;translation-value&gt;[,&lt;translation-value&gt;]?)， 指定对象的2D translation（2D平移）——从当前位置开始的偏移，第一个参数对应X轴（水平向右为正方向），第二个参数对应Y轴（垂直向下为正方向），如果第二个参数未提供，则默认其为0；</span><br><span class="line">★注意：translate-value可以设置为百分比，以自身宽度或高度为基准！！！</span><br><span class="line">translateX()translatex(&lt;translation-value&gt;)，指定对象X轴（水平方向）的平移；</span><br><span class="line">translateY()translatey(&lt;translation-value&gt;)，指定对象Y轴（垂直方向）的平移；</span><br><span class="line">rotate()rotate(&lt;angle&gt;)，指定对象的2D rotation（2D旋转）——以transform-origin为中心/基点旋转，正值顺时针/负值逆时针（等价于rotateZ），需先有 transform-origin 属性的定义；</span><br><span class="line">scale()scale(&lt;number&gt;[,&lt;number&gt;]?)，指定对象的2D scale（2D缩放）——以transform-origin为基点缩放，缩放倍数必须为正，第一个参数对应X轴，第二个参数对应Y轴，如果第二个参数未提供，则默认取第一个参数的值；</span><br><span class="line">scaleX()scalex(&lt;number&gt;)，指定对象X轴的（水平方向）缩放；</span><br><span class="line">scaleY()scaley(&lt;number&gt;)，指定对象Y轴的（垂直方向）缩放；</span><br><span class="line">skew()skew(&lt;angle&gt;[,&lt;angle&gt;]?)，指定对象skew transformation（斜切扭曲）——以transform-origin为基点，X轴正向水平向右，Y轴正向垂直向下，若像素点的坐标为(x,y)，则水平移动距离为tan(angleX)*y，垂直移动距离为tan(angleY)*x，第一个参数对应X轴，第二个参数对应Y轴，如果第二个参数未提供，则默认值为0；</span><br><span class="line">skewX()skewx(&lt;angle&gt;)，指定对象X轴的（水平方向）扭曲；</span><br><span class="line">skewY()skewy(&lt;angle&gt;)，指定对象Y轴的（垂直方向）扭曲；</span><br><span class="line"></span><br><span class="line">Ⅱ.3D转换：</span><br><span class="line">matrix3d()matrix3d(&lt;number&gt;[,&lt;number&gt;]&#123;15,15&#125;)，以一个4x4矩阵的形式指定一个3D变换；</span><br><span class="line">translate3d()translate3d(&lt;translation-value&gt;,&lt;translation-value&gt;,&lt;length&gt;)，指定对象的3D位移，第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略；</span><br><span class="line">translateZ()translatez(&lt;length&gt;)，指定对象Z轴的平移；</span><br><span class="line">rotate3d()rotate3d(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;angle&gt;)，指定对象进行任意方向的3D旋转，其中以transform-origin为原点建立★基础坐标系★，并由前3个参数分别表示出一个旋转的矢量(x,y,z)——即旋转轴的正向，第4个参数表示绕该旋转轴旋转的角度——根据★左手定则★，参数不允许省略；</span><br><span class="line">★基础坐标系★：在3D变换中，基础坐标系是以transform-origin为原点，水平向右为X轴正方向，垂直向下为Y轴正方向，垂直于屏幕向用户为Z轴正方向，并且要注意的是在3D旋转</span><br><span class="line">中基础坐标系会跟随着一同旋转。</span><br><span class="line">★左手定则★：在3D旋转中，用左手握住旋转轴，拇指指向旋转轴的正向，剩余四指指向的便是旋转的正方向，旋转角若为负值，则反过来转动！！！</span><br><span class="line">rotateX()rotatex(&lt;angle&gt;)，指定对象在x轴上的旋转角度；</span><br><span class="line">rotateY()rotatey(&lt;angle&gt;)，指定对象在y轴上的旋转角度；</span><br><span class="line">rotateZ()rotatez(&lt;angle&gt;)，指定对象在z轴上的旋转角度；</span><br><span class="line">scale3d()scale3d(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;)，指定对象的3D缩放，第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略；</span><br><span class="line">scaleZ()scalez(&lt;number&gt;)，指定对象的z轴缩放；</span><br><span class="line">perspective()perspective(&lt;length&gt;)，指定透视距离。</span><br><span class="line">★★★★注意：当使用transform转换配合transition过渡或animation动画来制作页面动画效果时，要理解到transform不过是一个普通的属性，它是以元素没有设置transform属性之前的状态为基础，向元素</span><br><span class="line">添加一系列变形效果，本质就是给元素设置一个新状态，并没有给元素添加真正的连续性动作。动画产生的真正原因在于transition过渡属性或animation动画属性的作用，当元素在两个不同的</span><br><span class="line">transform属性值之间进行过渡/动画时，实质上就是在两个新状态之间过渡/动画，而这两个新状态都是以没有设置transform之前的相同状态为基础。</span><br><span class="line"></span><br><span class="line">transform-origin属性：默认值是50% 50% 0，不继承，用来设置2D/3D转换时的基点（基础坐标系原点，也是旋转缩放时的不动点）的位置，而其属性值是基于元素本身原始坐标系，其原点为元素border-box的左上角，右X轴正向，下Y轴正向；</span><br><span class="line">结构：transform-origin: x-axis y-axis z-axis;</span><br><span class="line">属性值类型：</span><br><span class="line">x-axis</span><br><span class="line">left盒子左边界横坐标；</span><br><span class="line">center盒子水平中心；</span><br><span class="line">right盒子右边界横坐标；</span><br><span class="line">length具体长度值；</span><br><span class="line">%以元素本身的宽度为基准；</span><br><span class="line">y-axis</span><br><span class="line">top盒子上边界纵坐标； </span><br><span class="line">center 盒子垂直中心；</span><br><span class="line">bottom 盒子下边界纵坐标；</span><br><span class="line">length 具体长度值；</span><br><span class="line">%以元素本身的高度为基准；</span><br><span class="line">z-axis</span><br><span class="line">length长度；</span><br><span class="line">★注意：如果提供两个，第一个用于横坐标，第二个用于纵坐标；如果只提供一个，该值将用于横坐标，纵坐标将默认为50%！！！</span><br><span class="line"></span><br><span class="line">transform-style属性：默认值flat，不继承，用于设置如何在3D空间中呈现被嵌套的子元素；</span><br><span class="line">属性值类型：</span><br><span class="line">flat子元素将不保留其3D位置，即该元素整体被看作为一个平面图形，在该元素的内部空间中具有3D坐标的子元素，只能呈现为其在父元素上的投影； </span><br><span class="line">preserve-3d子元素将保留其3D位置，即该元素整体被看作为一个三维图形。</span><br><span class="line"></span><br><span class="line">perspective属性：默认值none，可继承属性，用于设置该元素上的观察者与该元素平面之间的距离，当其属性值为非none/0时，使得具有三维位置变换的子元素产生透视效果——三维元素本身或某一部分的[z&gt;0]（离观察者越近）时会比正常在父元素平面内显示的要大，而「z&lt;0」时则比正常小，大小程度由该属性的值决定；</span><br><span class="line">属性值类型：</span><br><span class="line">none默认值，与0相同，不设置透视；</span><br><span class="line">length当该属性值为「非none」时，元素将会创建局部堆叠上下文。</span><br><span class="line">perspective-origin属性：默认值是50% 50%，不继承，用于设置透视点（观察者在该元素平面的垂点）的位置；</span><br><span class="line">结构：perspective-origin: x-axis y-axis;</span><br><span class="line">属性值类型：</span><br><span class="line">x-axis</span><br><span class="line">left盒子左边界横坐标；</span><br><span class="line">center盒子水平中心；</span><br><span class="line">right盒子右边界横坐标；</span><br><span class="line">length具体长度值；</span><br><span class="line">%以元素本身的宽度为基准；</span><br><span class="line">y-axis</span><br><span class="line">top盒子上边界纵坐标； </span><br><span class="line">center 盒子垂直中心；</span><br><span class="line">bottom 盒子下边界纵坐标；</span><br><span class="line">length 具体长度值；</span><br><span class="line">%以元素本身的高度为基准；</span><br><span class="line">★注意：如果提供两个，第一个用于横坐标，第二个用于纵坐标；如果只提供一个，该值将用于横坐标，纵坐标将默认为50%！！！</span><br><span class="line">backface-visibility属性：默认值是visible，不继承，用于设置元素不面向屏幕时是否可见；</span><br><span class="line">属性值类型：</span><br><span class="line">visible背面是可见的； </span><br><span class="line">hidden背面是不可见的。</span><br></pre></td></tr></table></figure><p>⒄CSS动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">@keyframes语法：通过 @keyframes 规则，能够创建一组动画效果的基本框架——一个动画周期内的特定时间点以及每个特定时间点的帧状态；</span><br><span class="line">@keyframes  animationname &#123;</span><br><span class="line">keyframes-selector &#123; keyframes-blocks &#125;</span><br><span class="line">[...]</span><br><span class="line">keyframes-selector &#123; keyframes-blocks &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes identifier &#123;</span><br><span class="line">from &#123; keyframes-blocks &#125;</span><br><span class="line">[20% &#123; keyframes-blocks &#125;]</span><br><span class="line">[30% &#123; keyframes-blocks &#125;]</span><br><span class="line">[50% &#123; keyframes-blocks &#125;]</span><br><span class="line">[85% &#123; keyframes-blocks &#125;]</span><br><span class="line">to &#123; keyframes-blocks &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes identifier &#123;</span><br><span class="line">0% &#123; keyframes-blocks &#125;</span><br><span class="line">[20% &#123; keyframes-blocks &#125;]</span><br><span class="line">[40% &#123; keyframes-blocks &#125;]</span><br><span class="line">[60% &#123; keyframes-blocks &#125;]</span><br><span class="line">[80% &#123; keyframes-blocks &#125;]</span><br><span class="line">100% &#123; keyframes-blocks &#125;</span><br><span class="line">&#125;</span><br><span class="line">animationname定义一个动画的名称；</span><br><span class="line">keyframes-selector定义一个动画周期T内某些特定时间点[T * n%]；</span><br><span class="line">keyframes-blocks定义一个动画周期T内在每个特定时间点的样式，即帧状态；</span><br><span class="line"></span><br><span class="line">★动画的原理★——由一套 CSS 样式逐渐变化为另一套 CSS 样式；</span><br><span class="line">●动画过程：</span><br><span class="line">1.@keyframes动画框架规定了一个动画周期T内，每个特定时间点[T * n%]作用于元素的框架样式，其中最重要也是必不可少的两个点为——[from|0%]和[to|100%]；</span><br><span class="line">2.首先，分析[from|0%]和[to|100%]时元素的全部属性样式——即元素的开始状态与结束状态（除了在这两个点添加的框架样式之外，★特别地★，还要将元素本身动画前原有设定的属性值包括在内），对比在这两个特定时间点之间的所有样式属性的变动：</span><br><span class="line">★★★★注意：动画框架内设定的样式优先级要高于元素本身非动画状态下的所有样式，包括!important修饰过的样式！！！</span><br><span class="line">①若在这两个时间点上有支持过渡的属性值设置且改变，且在这两个时间点之间没有其他时间点主动设置了该属性的值，则该属性的值在这两个时间点间按照所设定的时间曲线过渡；</span><br><span class="line">②若在这两个时间点上设置变化的属性并不支持过渡或者设置的属性值之间无法过渡以及仅有某一端该属性没有值，且中间没有其他时间点设置该属性的值，则将这个时间区段分割成两份，并让这两个属性值/[有|无]值按原有顺序先后起作用；</span><br><span class="line">③在上述两例子中，如果中间还有其他时间点设置了该属性的值，则用这些设置了该属性的时间点去分割整个时间段，并在所有设置该属性的每两个最近的时间点之间去依次判断能否过渡；</span><br><span class="line">④若在始末这两个时间点上某属性都没有显式设置（即始末采取默认值或没有值），但在中间的其他时间点设置了该属性的值，一样要同上分段去判断，并且要注意分段判断中仍然必需要包括[from|0%]和[to|100%]这两个特殊点，而没有显式设置该属性的中间点就不考虑——这些时间点的该属性值由包含它们的分段两端去决定；</span><br><span class="line">⑤在对某个属性的每个分段中，参照①②中的标准去判断。</span><br><span class="line">总结：在动画过程中某属性的整个变化过程，需要判断[from|0%]和[to|100%]以及所有设置了该属性的中间点上该属性值的状态！这些时间点将整个动画周期分段，每个分段的两端点上的该</span><br><span class="line">属性的值之间如果可以过渡，则该属性在这个分段期间就在此两值之间过渡，若不能过渡（包括属性不支持/值不支持/没有值），则在这个分段期间内两端点的属性状态就先后起作用。</span><br><span class="line"></span><br><span class="line">●动画示例：</span><br><span class="line">@keyframes move &#123;</span><br><span class="line">from &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0px;</span><br><span class="line">left: 0px;</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">position: relative;</span><br><span class="line">top: 100px;</span><br><span class="line">left: 0px;</span><br><span class="line">&#125;</span><br><span class="line">to &#123;</span><br><span class="line">position: static;</span><br><span class="line">top: 200px;</span><br><span class="line">left: 0px;</span><br><span class="line">background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">background-color: red;</span><br><span class="line">animation: move 10s 3 linear;</span><br><span class="line">&#125;</span><br><span class="line">●详细分析：</span><br><span class="line">1.当给元素设定的某个动画开始时，会在第一个动画周期前经过（唯一）一次给该动画设定的延时时间，之后开始周期循环；</span><br><span class="line">2.</span><br><span class="line">3.</span><br><span class="line">4.要注意，元素最开始0%时的颜色就设定为red</span><br><span class="line"></span><br><span class="line">animation属性：简写属性（缺省项设置默认值），默认值是none 0 ease 0 1 normal running，不继承，用来在一个声明中为元素设置一组或多组组动画以及每个动画的执行时间、时间曲线、延迟时间、执行次数、是否反向、执行外状态和动画状态；</span><br><span class="line">结构：animation：animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode animation-play-state[, 第二组动画设置][...];</span><br><span class="line">★注意：如果只提供一个 time 参数，则为 animation-duration 的值定义；如果提供二个 time 参数，则第一个为 animation-duration 的值定义，第二个为 animation-delay 的值定义！！</span><br><span class="line">子属性：</span><br><span class="line">animation-name：默认值none，不继承，用来设置给元素所应用的 @keyframes 规定的动画名称，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">none默认值，规定无动画效果（可用于覆盖来自级联的动画）；</span><br><span class="line">keyframename规定需要绑定到选择器的 keyframe 的名称。 </span><br><span class="line">animation-duration：默认值0，不继承，用来设置动画完成一个周期所需要的时间，以秒或毫秒计，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">0默认值，意味着没有动画效果；</span><br><span class="line">time规定完成动画所花费的时间。</span><br><span class="line">animation-timing-function：默认值ease，不继承，用来设置元素动画的过渡类型——时间速度曲线，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">同transition-timing-function。</span><br><span class="line">animation-delay：默认值0，不继承，用来设置元素到动画循环开始所延迟的时间，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">0默认值，意味着没有延时；</span><br><span class="line">time定义动画开始前等待的时间，以秒或毫秒计。</span><br><span class="line">animation-iteration-count：默认值1，不继承，用来设置元素动画的循环次数，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">n定义动画播放次数的正整数值；</span><br><span class="line">infinite规定动画应该无限次播放。  </span><br><span class="line">animation-direction：默认值normal，不继承，用来设置对象动画在循环中是否反向运动，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">normal默认值，动画只正向播放； </span><br><span class="line">alternate动画应该轮流正反向播放，即正一次，反一次，正一次……轮流直至满足循环次数（★注意：每次反向播放都算是一次独立的循环，计入总循环次数），如果提供多个属性值，以逗号进行分隔。</span><br><span class="line">animation-fill-mode：默认值none，不继承，用来设置元素在动画时间之外的状态；</span><br><span class="line">none默认值，不改变默认行为——元素在动画执行之前（包括延时时间中）以及动画完全结束之后的状态为原始状态，即不受动画中样式属性影响时的状态；</span><br><span class="line">forwards当动画完成后，元素保持最后一个帧状态中的属性值（在最后一个关键帧中定义，优先级比!important高）；</span><br><span class="line">backwards在 animation-delay 所指定的一段时间内，即在动画显示之前，应用开始帧中的属性值（在第一个关键帧中定义）； </span><br><span class="line">both向前和向后填充模式都被应用。 </span><br><span class="line">animation-play-state：默认值running，不继承，用来设置元素动画的当前状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式，如果提供多个属性值，以逗号进行分隔；</span><br><span class="line">running默认值，规定动画正在播放；</span><br><span class="line">paused规定动画已暂停（没结束）。</span><br></pre></td></tr></table></figure><p>⒅伸缩布局[弹性布局]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">弹性盒子[父元素]——当给某元素设置display属性为flex时，该元素即转变为弹性盒子，这将影响其内部子元素的排列方式；</span><br><span class="line">display: flex;</span><br><span class="line">★注意：在弹性盒子内部存在着一条主轴与一条侧轴，侧轴永远垂直于主轴，且侧轴的方向要么为垂直向下，要么为水平向右，所以只需要通过flex-direction属性设置主轴方向即可同时改变侧轴！！！</span><br><span class="line">首先，盒子内子元素参照主轴方向并根据justify-content属性设置的主轴对齐方式排列——这两者将影响子元素在主轴方向的尺寸；</span><br><span class="line">然后，如果盒子内的子元素只有一行，那么将根据align-items属性设置的弹性行内元素侧轴对齐方式来在侧轴排列元素——当弹性盒子内只有一行子元素时默认这一行始终占满弹性盒子侧轴尺寸，此时忽视align-content；</span><br><span class="line">      如果盒子内的子元素不止一行，那么将先根据align-content属性设置的弹性行侧轴对齐方式来在侧轴方向排列弹性行的位置（同时影响了其每行在侧轴所占长度），再根据align-items</span><br><span class="line">      属性来设置每一行内的子元素在该行的侧轴对齐方式。</span><br><span class="line">★注意：弹性属性都是不继承的，包括display: flex，也就是说弹性盒子的子项并不一定是弹性盒子！！！</span><br><span class="line"></span><br><span class="line">flex-flow属性：简写属性（缺省项设置默认），默认值是row nowrap，不继承，用来在一个声明中设置弹性盒子模型对象（父元素）的子元素排列方式——主轴/侧轴方向和是否换行；</span><br><span class="line">结构：flex-flow: flex-direction flex-wrap;</span><br><span class="line">子属性：</span><br><span class="line">flex-direction：默认值是row，不继承，该属性通过定义flex容器的主轴方向来决定felx子项在flex容器中的位置；</span><br><span class="line">属性值类型：</span><br><span class="line">row主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）；</span><br><span class="line">row-reverse对齐方式与row相反；</span><br><span class="line">column主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）；</span><br><span class="line">column-reverse对齐方式与column相反。</span><br><span class="line">flex-wrap：默认值是nowrap，不继承，该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向；</span><br><span class="line">属性值类型：</span><br><span class="line">nowrapflex容器为单行，该情况下flex子项可能会溢出容器；</span><br><span class="line">wrapflex容器为多行，该情况下flex子项溢出的部分会被放置到新行，子项内部会发生断行；</span><br><span class="line">wrap-reverse反转 wrap 排列。</span><br><span class="line">justify-content属性：默认值是flex-start，不继承，设置弹性盒子元素在主轴（横轴）方向上的对齐方式；</span><br><span class="line">属性值类型：</span><br><span class="line">flex-start弹性盒子元素将向行起始位置对齐。该行的第一个子元素的主起始位置的边界将与该行的主起始位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐；</span><br><span class="line">flex-end弹性盒子元素将向行结束位置对齐。该行的第一个子元素的主结束位置的边界将与该行的主结束位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐；</span><br><span class="line">center弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐，同时第一个元素与行的主起始位置的边距等同与最后一个元素与行的主结束位置的边距（如果剩余空间是负数，则保持两端相等长度的溢出）；</span><br><span class="line">space-between弹性盒子元素会平均地分布在行里。如果最左边的剩余空间是负数，或该行只有一个子元素，则该值等效于&apos;flex-start&apos;。在其它情况下，第一个元素的边界与行的主起始位置的边界对齐，同时最后一个元素的边界与行的主结束位置的边距对齐，而剩余的伸缩盒项目则平均分布，并确保两两之间的空白空间相等；</span><br><span class="line">space-around弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。如果最左边的剩余空间是负数，或该行只有一个伸缩盒项目，则该值等效于&apos;center&apos;。在其它情况下，伸缩盒项目则平均分布，并确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半。</span><br><span class="line">align-content属性：默认值是stretch，不继承，用来设置容器内所有伸缩行在侧轴方向上的对齐方式，当伸缩容器的侧轴还有多余空间时，本属性可以用来调准「伸缩行」在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的 &lt;&apos; justify-content &apos;&gt; 属性类似。请注意本属性在只有一行的伸缩容器上没有效果；</span><br><span class="line">属性值类型：</span><br><span class="line">flex-start各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行；</span><br><span class="line">flex-end各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行；</span><br><span class="line">center各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离）；</span><br><span class="line">space-between各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;flex-start&apos;。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等； </span><br><span class="line">space-around各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;center&apos;。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半； </span><br><span class="line">stretch各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于&apos;flex-start&apos;。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。</span><br><span class="line"></span><br><span class="line">align-items属性：默认值是stretch，不继承，用来设置每个伸缩行内的子元素在本伸缩行内纵轴方向上的对齐方式；</span><br><span class="line">属性值类型：</span><br><span class="line">flex-start弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界；</span><br><span class="line">flex-end弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界；</span><br><span class="line">center弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）；</span><br><span class="line">baseline如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐；</span><br><span class="line">stretch如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。</span><br><span class="line"></span><br><span class="line">弹性子项[子元素]——当某元素的直接父元素被设置为弹性盒子时，该子元素将默认被转换为弹性子项（忽视display设置的inline/block），它可以设置宽高，不过此时的设置宽高不一定就是其实际宽高；</span><br><span class="line">★★★★准确地讲，弹性子项的实际宽高是由其父元素的属性以及子项的属性共同决定的：</span><br><span class="line">①先确定主轴方向的尺寸：</span><br><span class="line">  弹性子项在其父元素主轴方向上的尺寸（父元素主轴水平——指宽度，主轴垂直——指高度）是由其本身设置的flex属性、父元素主轴尺寸与同行的其他元素所共同决定的。</span><br><span class="line">  1.首先要确定所有弹性子项的flex-basis属性的计算值（真值）——即在主轴方向上的基准尺寸，按照该基准值计算能在这一行排列的有那些子项，若父盒子设置了nowrap，则所有子项在</span><br><span class="line">    同一行排列，若设置wrap，则超出该行的子项将换下一行去排列；</span><br><span class="line">  2.然后，先用父元素主轴方向尺寸减去该行所有边框和padding/margin的值，再减去该行排列的所有子项的flex-basis总和，计算出该行的超出（负值）或剩余（正值）尺寸；</span><br><span class="line">  3.最后，如果剩余，则根据每个元素的flex-grow扩展比确定该元素伸展的尺寸；如果超出，则根据每个元素的flex-shrink收缩比以及flex-basis基准值，计算其收缩的尺寸。</span><br><span class="line">★注意：计算每行的剩余/超出尺寸时一定要减去行内的所有边框、padding、margin等固定尺寸，而且扩展和收缩时也不影响这些尺寸的大小，只会影响子项的宽度或者高度！！！</span><br><span class="line">②再确定侧轴方向的尺寸：</span><br><span class="line">  弹性子项在其父元素侧轴方向上的尺寸（父元素主轴水平|侧首垂直——指高度，主轴垂直|侧轴水平——指宽度）是由自身设置的侧轴尺寸、内容所决定的尺寸、所在伸缩行的侧轴尺寸以及父元素的align-items属性共同决定。</span><br><span class="line">  1.当弹性子项自身显式设置侧轴方向的尺寸时，就取该尺寸值；</span><br><span class="line">  2.当子项自身没有显式设置侧轴方向的尺寸时，就默认该尺寸由其内容所决定。不过，此时若父元素设置align-items属性为stretch，且其所在伸缩行的侧轴尺寸比其内容所决定的尺寸要大，</span><br><span class="line">    则该子项将在侧轴方向上伸展到与伸缩行相同的尺寸；</span><br><span class="line">☆注：总结伸缩子项所在的伸缩行的尺寸</span><br><span class="line">▲伸缩行的侧轴尺寸最少不得小于该行内子项（显式设置或由内容决定的）侧轴尺寸的最大值——即该行的最小尺寸；</span><br><span class="line">▲若父元素只有唯一一行/列子元素，且在侧轴方向的尺寸大于该伸缩行的最小尺寸，则默认将该伸缩行的侧轴尺寸伸展为父元素的侧轴尺寸，故此时align-content属性不起作用，而只有align-items起作用；</span><br><span class="line">▲若父元素内含有多行/列子元素，且在侧轴方向仍有剩余空间（即减去所有行的侧轴最小尺寸之后），而align-content属性为stretch，则将剩余空间平分并添加给每个伸缩行，以扩展其尺寸；</span><br><span class="line">▲其他情况下，该伸缩行的侧轴尺寸取其最小值。</span><br><span class="line">★★★★注意：在弹性布局中，子项的尺寸不仅仍要考虑到min/max-width/height的限制，还有当子项中含有文本内容时，★其主轴方向的尺寸不能小于一个文本行的大小★，而这可能造成子项无法按照预想的样子来伸缩！！！</span><br><span class="line"></span><br><span class="line">flex属性：简写属性（没有设置flex时采用右侧的各属性默认值，但设置时若缺省某项则按如下方式取默认值），默认值是0 1 auto，不继承，用来在一个声明中设置该弹性子项的扩展比率、收缩比率以及主轴基准尺寸； </span><br><span class="line">★缺省项默认值取法：</span><br><span class="line">1.flex-grow：在设置的 flex 属性中该值如果被省略则默认为 1 ，它用来指定该子项扩展比率——当该行主轴方向上剩余空间是正值时，此 flex子项 相对于该伸缩行里其他 flex子项 能</span><br><span class="line">     分配到空间比例，计算该子项扩展尺寸方法为（该子项flex-grow/该行所有子项flex-grow总和）*剩余空间。 </span><br><span class="line">2.flex-shrink：在设置的 flex 属性中该值如果被省略则默认为 1 ，它用来指定该子项收缩比率——当该行主轴方向上剩余空间是负值时，此 flex子项 相对于该行里其他 flex子项 需收</span><br><span class="line">       缩的空间比例，计算该子项收缩尺寸方法为（该子项flex-shrink*flex-basis/该行所有子项加权乘积flex-shrink*flex-basis总和）*剩余[收缩]空间。</span><br><span class="line">       ★注意：在收缩的时候收缩比率需要与伸缩基准值加权！！！</span><br><span class="line">3.flex-basis：在设置的「flex」属性中该值如果被省略则默认为「0%」，用来指定伸缩基准值，即在根据伸缩比率计算出剩余空间的分布之前，「flex子项」长度的起始数值。</span><br><span class="line">      ★注意：在「flex」属性中该值如果被指定为「auto」，则伸缩基准值的计算值是自身的 width 设置，如果自身的宽度没有定义，则长度取决于内容；</span><br><span class="line">★注意：可以给flex属性设置关键字none，none关键字的计算值为: 0 0 auto！！！</span><br><span class="line"></span><br><span class="line">flex-grow：默认值是0，不继承，用数值来定义扩展比率，不允许负值；</span><br><span class="line">flex-shrink：默认值是1，不继承， 用数值来定义收缩比率，不允许负值；</span><br><span class="line">flex-basis：默认值auto，不继承，设置或检索弹性盒伸缩基准值；</span><br><span class="line">&lt;length&gt;用长度值来定义基准值，不允许负值；</span><br><span class="line">&lt;percentage&gt;用基于父元素主轴尺寸的百分比来定义基准值，不允许负值；</span><br><span class="line">auto不定义特定值，将取决于其它属性值；</span><br><span class="line">content基于内容自动计算宽度。</span><br><span class="line">align-self属性：默认值auto，不继承，定义flex子项单独在侧轴（纵轴）方向上的对齐方式；</span><br><span class="line">auto如果&apos;align-self&apos;的值为&apos;auto&apos;，则其计算值为元素的父元素的&apos;align-items&apos;值，如果其没有父元素，则计算值为&apos;stretch&apos;；</span><br><span class="line">flex-start弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界；</span><br><span class="line">flex-end弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界；</span><br><span class="line">center弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）；</span><br><span class="line">baseline如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐；</span><br><span class="line">stretch如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记 三</title>
    <link href="http://yoursite.com/2014/02/25/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <id>http://yoursite.com/2014/02/25/CSS学习笔记03/</id>
    <published>2014-02-25T02:20:36.000Z</published>
    <updated>2018-02-16T16:17:11.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记-·-三"><a href="#CSS学习笔记-·-三" class="headerlink" title="CSS学习笔记 · 三"></a>CSS学习笔记 · 三</h1><p>⑷元素的显示方式：元素有行内元素、块级元素和行内块级元素等不同显示方式，浏览器对不同的标签有不同的默认display属性；</p><p>  基本分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①行内元素：一个行单元之内可以有多个（与文本内容一起按顺序排列，占满后换下一行显示），宽高由内容所决定，且不可以设置宽高[display:inline]；</span><br><span class="line">如：a标签、span标签、b/u/i/s标签、strong/em/del/ins标签、font标签等。</span><br><span class="line">②块级元素：一个行单元之内只能有一个（不论其大小，其他元素都不能显示在所占的这一行），默认情况下宽度（准确说是内容宽+左右内边距+左右边框宽的和）继承父元素宽度，高度由内容所决定，但可以设置宽高[display:block]；</span><br><span class="line">如：html标签、body标签、p标签、h系列标签、div标签、ul标签、ol标签、dl标签、dt/dd标签、li（display:list-item）。</span><br><span class="line">★注意：html标签与body标签都是块级元素，且html以浏览器窗口为父元素！！！</span><br><span class="line">③行内块级元素：一个行单元内可以有多个（同行内元素一样），默认情况下宽度和高度由内容决定，但可以设置宽高[display:inline-block]；</span><br><span class="line">如：img标签、input标签、多媒体标签。</span><br></pre></td></tr></table></figure><p>  其他类别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table标签：一个行单元之内只能有一个，默认情况下宽度和高度由内容决定，可以设置宽高[display:table]；</span><br><span class="line">tr：一个行单元之内只能有一个，宽度继承父元素宽度且不能修改，默认情况下高度由浏览器自动分配，但可以单独设置其中若干个高度却不能全部设置[display:table-row]；</span><br><span class="line">tbody：display:table-row-group；</span><br><span class="line">普通文本内容：类似于行内元素，但又有一些不同，例如：1.不受vertical-align影响，一直放在每个文本行的基线上；</span><br></pre></td></tr></table></figure><p>  转换块级元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:block;</span><br></pre></td></tr></table></figure><p>  转行内块元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:inline-block;</span><br></pre></td></tr></table></figure><p>  转行内元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display:inline;</span><br><span class="line">总结：一般情况下，如果我们希望页面中的行内元素设置宽度和高度，那么我考虑将行内元素转化为块级元素或行内块元素。不需要将行内块元素转化为行内元素或者块级元素。</span><br></pre></td></tr></table></figure><p>★★注意：文本行不同于行单元——</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.文本行用来存放文本内容，其高度仅由line-height属性决定。默认情况下浏览器会根据当前文字字体大小设置一个合适的行高（通常要比文字高一点且上下等间距），且文本在文本行内基本垂直居中显示</span><br><span class="line">（因文字是放在文本框的基线上，文本框就是文字图片的外边框，本质是文本图片在文本行内垂直居中）；但有设置或继承行高的情况下，文字大小（实际上即文本框大小）就不一定小于行高，文字大于行高</span><br><span class="line">  时便会超出文本行显示（仍然居中），此时要注意垂直相邻的文本行的文字内容便会相互遮盖（如果文本行是紧密相邻的）；行内/行内块级元素以及浮动元素在同一行单元显示时会占据文本行的宽度，但</span><br><span class="line">  不影响文本行高度。</span><br><span class="line">2.行内元素的高度仅由内容决定——准确地说此处受文本行以及文本框共同影响，当文字大小高于行高时，行内元素高度还包括文字字体超出文本行的那一部分，简单地说行内元素的高度由行单元和文字超出</span><br><span class="line">  部分共同决定；块级元素和行内块级元素的默认高度也由内容决定——但此处高度仅受文本行的高度影响，超出文本行的文本字体不再算入在内，简单地说块及行内块的默认高度仅由行单元总高度决定。</span><br><span class="line">3.行单元是HTML元素默认按行排列时的结构单元，其中块级元素完全占据一个行单元，此时该行内不能存在其他文本行、行内或行内块级元素等，而该行单元的高度仅由该块元素决定（盒子高度+上下外边距）；</span><br><span class="line">  而行内/行内块级元素、浮动元素以及文本内容则可以在同一行单元内排布，此时行单元的高度是根据文本行高度、行内子元素文本行高度和行内块级子元素盒子加外边距高度及两者垂直对齐方式vertical-align</span><br><span class="line">  共同决定，但不受文字大小、浮动元素直接影响。</span><br></pre></td></tr></table></figure><p>⑸CSS三大特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">●继承：子元素可以继承到父元素的某些属性值。</span><br><span class="line">继承分为两种——该属性本身就是可继承的，或特定元素的某属性默认时继承父元素的属性值；</span><br><span class="line">可继承的属性：text文本相关属性、background背景相关属性、font字体相关属性等；</span><br><span class="line">默认时继承的情况：块级元素的宽等。</span><br></pre></td></tr></table></figure><p>★★★★★注意：某些标签拥有用户代理（浏览器内核）设置的默认属性值（user agent stylesheet），而继承得到的属性值优先级是最低的，所以继承的属性值会被这些默认设置层叠掉，如a标签的蓝色自带下划线与h1标签的字体大小2em！！！<br>★★★★★注意：浏览器默认的字体大小16px以及文字颜色黑色则比继承属性值的优先级还要低，不属于以上的默认设置！！<br>★★★★★注意：⒈浏览器设置的默认字体大小为1em=16px，即如果在不设置且无继承字体大小属性的前提下在某容器上使用以em为单位的长度，就以1em=16px为基准，但如果有设置或继承到字体大小属性，则此时的em基准就改变了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">⒉使用以em为单位的固定长度来重新设置font-size时，该固定长度中的em单位以没有通过任何选择器改变font-size时的字体大小为基准（★即父元素的font-size大小），而设置后的em单位的基准改变为新的字体大小即font-size的新值；</span><br><span class="line">⒊含有更改字体大小属性的同一选择器中若有其他地方使用em为单位，则em以改变后的字体大小为基准，不论先后顺序。实际上，当字体大小font-size改变后，同一元素中所有以em为单位的其他属性便会随之改变（不论是否在同一选择器中设置），除了font-size自身！</span><br><span class="line"></span><br><span class="line">●层叠：当同一元素的同一属性通过不同的方式得到了多个取值时，该元素的该属性最终实际值只能取其中的一个，所以必然导致其他取值全部不起作用，叫做层叠。</span><br><span class="line">  方式：</span><br><span class="line">1.优先级最高的取值会层叠掉其他所有优先级较低的设置值；</span><br><span class="line">2.两个取值的优先级相同时，后面的会覆盖掉前面的。</span><br><span class="line"></span><br><span class="line">●优先级：属性值的优先级取决于该属性值所在的位置（不同的位置赋予不同的优先级）。</span><br><span class="line">★注意：优先级是属性值的优先级，而不是选择器的优先级（同样两个选择器中不同属性的属性值优先级关系可能相反）！</span><br><span class="line"></span><br><span class="line">简单选择器：直接看属性值所在的位置及选择器类型</span><br></pre></td></tr></table></figure><p>★★★★animation动画对应的@keyframes中…&gt;该属性值具有的!important后缀…&gt;行内样式中所赋予的优先级&gt;ID选择器…&gt;类选择器|伪类选择器|属性选择器…&gt;标签选择器…&gt;通配符选择器所赋予的优先级&gt;浏览器默认设置中所赋予属性值的优先级&gt;在父元素中通过继承所赋予属性值的优先级<br>★★★★注意：!important不能继承，即使父元素的某属性值上有!important后缀，但从父元素继承过来的该属性值上没有带!important后缀，即!important不作用于继承过程！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复合选择器：计算权重</span><br></pre></td></tr></table></figure><p>★★★★方法：对所有直接作用于该元素某属性的每个属性值计算4维数组(该属性值上的!important个数,所在ID选择器个数,类|伪类|属性选择器个数,标签选择器个数)，然后从第一个数开始，数值大的优先级高，数值相同时比较下一个数。<br>★★★★注意：当用伪元素给某个元素设置样式时，浏览器会将对应的结构从该父元素中分离出来当作独立的子元素，此时这些伪子元素的样式只受对应的伪元素选择器直接控制，而父元素中设置的样式只能通过继承传过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">★注意：在外联写法与嵌套写法中优先级并不会改变，另外link标签与style标签的相对顺序，决定其中的选择器之间的逻辑先后顺序！！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">    ◆一般我们通过css设置样式的时候，不要把选择器的优先级设置的太高或者太低。</span><br></pre></td></tr></table></figure><p>⑹盒子模型：HTML中——万物皆盒子！！！</p><p>  盒子内：<br>①内  容：width/height；<br>②内边距：padding；<br>③边  框：border；</p><p>  盒子外：<br>④外边距：margin；</p>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记 二</title>
    <link href="http://yoursite.com/2014/02/24/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>http://yoursite.com/2014/02/24/CSS学习笔记02/</id>
    <published>2014-02-24T02:10:36.000Z</published>
    <updated>2018-02-16T16:16:06.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记-·-二"><a href="#CSS学习笔记-·-二" class="headerlink" title="CSS学习笔记 · 二"></a>CSS学习笔记 · 二</h1><p>CSS选择器：用来确定设置的样式作用于哪些元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;属性:值; ...&#125;</span><br></pre></td></tr></table></figure><p>Ⅰ基础选择器：</p><p>①标签选择器：标签选择器会选中body中所有具有该标签名的标签；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">html标签名&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    x标签{...}        /*选中所有的x标签*/&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;x标签&gt;&lt;!--第一个x标签--&gt;</span><br><span class="line">&lt;x标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  </p><p>②类选择器：类选择器会选中body中所有具有该类名的标签，同一类名可以给任意多个标签设置，一个标签也可以同时拥有多个类名（多个类名用空格隔开表示）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">.自定义类名&#123;属性:值;...&#125;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">.x&#123;...&#125;/*选中所有类名为x的标签*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签 class=&quot;x&quot;...&gt;&lt;!--第一个类名为x的元素--&gt;</span><br><span class="line">&lt;b标签 class=&quot;x&quot;...&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  </p><p>③ID选择器：ID选择器会选中body中具有该ID名的那个标签，标签的ID名不能重复且只能有一个；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">#自定义id名称&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;</code></pre><h1 id="x-…-选中ID名为x的标签"><a href="#x-…-选中ID名为x的标签" class="headerlink" title="x{…}            /选中ID名为x的标签/"></a>x{…}            /<em>选中ID名为x的标签</em>/</h1><pre><code>&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签 id=&quot;x&quot;...&gt;&lt;!--ID名为x的元素--&gt;</span><br><span class="line">&lt;b标签 id=&quot;y&quot;...&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>★★注意：类名与ID名的命名规则——必须由字母、数字、“-”和“_”组成，并且不能由数字开头，不推荐使用汉字！</p><p>④通配符选择器：通配符选择器会选中所有的html标签——包括html根标签（例如：伪类*:first-child选择器就会选中html）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">*&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    *{...}            /*选中所有的标签*/&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签&gt;</span><br><span class="line">&lt;b标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  </p><p>Ⅱ复合选择器：由两个及以上选择器组合而成的选择器，查找元素是否符合该选择器时按照从右向左的顺序来确认是否选中；</p><p>①并集选择器：并集选择器会选中两个选择器对应标签集合的并集，两个选择器用“,”分隔；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">选择器,选择器&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    a标签,b标签{...}    /*选中所有的a标签和b标签*/&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签&gt;</span><br><span class="line">&lt;b标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  </p><p>②交集选择器（又称标签指定式选择器）：交集选择器会选中两个选择器对应标签集合的交集，两个选择器直接连写，但若有标签选择器则其必须在前（标签指定式选择器）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">标签名.类名&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    a.x{...}        /*选中标签名为a且类名为x的标签*/</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b#y&#123;...&#125;/*选中标签名为b且ID名为y的标签*/</span><br><span class="line">#y.x&#123;...&#125;/*选中ID名为y且类名为x的标签*/</span><br></pre></td></tr></table></figure><pre><code>&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签 class=&quot;x&quot;&gt;&lt;!--标签名为a且类名为x的标签--&gt;</span><br><span class="line">&lt;b标签 id=&quot;y&quot; class=&quot;x&quot;&gt;&lt;!--标签名为b且ID名为y的标签--&gt;</span><br><span class="line">&lt;a标签&gt;</span><br><span class="line">&lt;b标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  </p><p>③后代选择器：后代选择器会选中所有包含在父选择器对应元素下的子选择器对应元素，两个选择器用空格“ ”相连，父在前子在后；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">选择器 选择器&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    a标签 b标签{...}    /*选中所有包含在a标签中的b标签*/&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签&gt;&lt;!--父元素--&gt;</span><br><span class="line">&lt;b标签&gt;&lt;/b标签&gt;&lt;!--直接子元素1--&gt;</span><br><span class="line">&lt;b标签&gt;&lt;!--直接子元素2--&gt;</span><br><span class="line">&lt;b标签&gt;&lt;/b标签&gt;&lt;!--间接子元素--&gt;</span><br><span class="line">&lt;/b标签&gt;</span><br><span class="line">&lt;/a标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>★注意：多层连写时，如“div p span”，表示选中的span标签是某个p标签的后代，且这个p标签又是某个div标签的后代！！！<br>★注意：后代选择器只能选中所有的后代元素，而不能选中其父元素！！</p><p>④直接子元素选择器：直接子元素选择器会选中子选择器对应元素中是父选择器对应元素的直接子元素的那些元素，两个选择器用“&gt;”相连，父在前子在后；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">选择器&gt;选择器&#123;属性:值;...&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;style&gt;    a标签&gt;b标签{...}    /*选中所有包含在a标签第一层中的b标签*/&lt;/style&gt;</code></pre><p>  …<br>  <body></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a标签&gt;&lt;!--父元素--&gt;</span><br><span class="line">&lt;b标签&gt;&lt;!--直接子元素--&gt;</span><br><span class="line">&lt;b标签&gt;&lt;/b标签&gt;&lt;!--间接子元素--&gt;</span><br><span class="line">&lt;/b标签&gt;</span><br><span class="line">&lt;/a标签&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>★注意：多层连写时，类同于后代选择器！<br>★注意：直接子元素选择器也只能选中所有的子代元素，而不能选中其父元素！！</p><p>⑤伪类——伪类选择器：<br>      ★什么是伪类？——伪类不是类，但却与类有相似的功能和用法，所以叫做伪类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">★类是通过给标签赋予特定的类名，将该标签划分到某个对应集合中，以方便进行相同属操作的一种分类方法。</span><br><span class="line">★而伪类也是一种划分标签的方法，它们之间的区别在于：</span><br><span class="line">☆类名是不固定的，可以按照特定的规则任意命名；类名必须主动赋予给某个标签元素后才能起作用，让此元素享受该类选择器内设置的样式值；</span><br><span class="line">☆伪类名则是固定的，既不能任意创造，且每个伪类名有规定好的含义；伪类名也不能主动赋予给某个标签元素，只有当一个标签元素满足该伪类名对应的特定结构或状态条件时，该标签才能被该伪类名对应的伪类选择器选中。</span><br><span class="line">  可以把这个过程看作，当一个元素符合某种结构或状态时，它被自动而非主动地赋予了隐含的对应伪类名！！！</span><br><span class="line"></span><br><span class="line">结构：</span><br><span class="line">:伪类名&#123;属性:值;...&#125;&lt;!--作用于所有符合该伪类的元素--&gt;</span><br></pre></td></tr></table></figure><p>Ⅰ结构伪类选择器：当元素所在的标签结构满足下列条件时，会被对应的伪类选择器选中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:first-child选中元素是其父元素的第一个子元素；★注意：所谓的第一个指的是包括同类元素与非同类元素在内的所有子元素中排在第一个！！！★★★html根标签一直满足该条件！！！</span><br><span class="line">:last-child选中元素是其父元素的最后一个子元素</span><br><span class="line">:nth-child(n)选中元素是其父元素的第n个子元素，其中：</span><br><span class="line">n可以设置一个正整数（0及负数无效，没有对应元素）；</span><br><span class="line">n可以设置关键字odd(奇数个数)|even（偶数个数）；</span><br><span class="line">n可以设置固定形式的表达式&quot;an+b&quot;，其中a和b可以是任意整数（a为步长，b是起始位序号），n是自变量，自动从0开始依次取所有的正整数； </span><br><span class="line">:nth-last-child(n)选中元素是其父元素的倒数第n个子元素，其中：</span><br><span class="line">n可以设置一个正整数（0及负数无效，没有对应元素）；</span><br><span class="line">n可以设置关键字odd(奇数个数)|even（偶数个数）；</span><br><span class="line">n可以设置固定形式的表达式&quot;an+b&quot;，其中a和b可以是任意整数（a为步长，b是起始位序号），n是自变量，自动从0开始依次取所有的正整数；</span><br></pre></td></tr></table></figure><p>Ⅱ状态伪类选择器：当元素的状态满足下列条件时，会被对应的伪类选择器选中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:link选中元素未被访问过（浏览器内核的历史记录里没有相应记录），用来设定未访问过的状态下的样式（★注意：只作用于a标签，因为只有超链接才能被访问并记录）；</span><br><span class="line">:visited选中元素已被访问过（浏览器内核的历史记录里有相应的记录），用来设定已访问过的状态下的样式（★注意：只作用于a标签，因为只有超链接才能被访问并记录）；</span><br><span class="line">:hover选中元素上有鼠标悬停，用来设定鼠标覆盖该元素时的样式，可以作用于任意标签；</span><br><span class="line">:active选中元素正被鼠标激活，用来设定鼠标激活该元素时的样式，可以作用于任意标签；</span><br><span class="line">:focus选中元素获得当前焦点，用来设定该元素获得焦点时的样式；</span><br></pre></td></tr></table></figure><p>Ⅲ目标伪类选择器：当元素作为某锚链接的目标且由该链接跳转到该元素时，会被目标伪类选择器选中（既有结构要求，又有状态条件）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:target选中元素是某个锚链接的目标，并且已经由该锚链接跳转到该元素，用来设置锚目标被跳转后的样式；</span><br></pre></td></tr></table></figure><p>★注意：:visited中只能设置与颜色相关的属性！！！<br>★注意：锚伪类的顺序——L V H A，记忆方法——爱（LoVe）恨（HAte）原则；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:link</span><br><span class="line">:visited</span><br><span class="line">:hover:hover必须位于:link和:visited之后，因为:link、:visited中设置的样式也作用于悬停时（相当于同时设置了:hover），故当★优先级相同时，:link/visited可以覆盖掉之前:hover中设置的样式；</span><br><span class="line">:active:active必须位于:hover之后，因为:hover中设置的样式也作用于激活时（相当于同时设置了:active），故当★优先级相同时，:hover可以覆盖掉之前:active中设置的样式；</span><br><span class="line">★★★注意：不使用伪类而直接设置a标签的样式时，相当于同时设置了其:link、:visited、:hover和:active四种状态时的样式，故当★优先级相同时，不带伪类的选择器可以覆盖掉在此之前的以上所有设置。</span><br><span class="line">    进而推论——当不使用伪类而直接设置某标签元素时，其设置的值在优先级相同的情况下，会覆盖之前所有作用于该元素的伪类中的同属性设置，因为不使用伪类的设置值本身就会在满足伪类条件</span><br><span class="line">    时起作用，所以当该元素满足伪类条件时，便拥有了多个属性值设置，需要判断有伪类与无伪类设置的优先级。</span><br><span class="line">★★★注意：在优先级的判断上伪类的作用等价于类！！！</span><br></pre></td></tr></table></figure><p>⑥属性选择器：属性选择器会选中设置了某种HTML属性或者属性值的元素，不仅限于class和id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">结构：</span><br><span class="line">[HTML属性条件]&#123;CSS属性:值;...&#125;</span><br><span class="line"></span><br><span class="line">[attribute]选取设置了指定属性的元素；</span><br><span class="line">[attribute=value]选取设置了指定属性和属性值的元素； </span><br><span class="line">[attribute^=value]选取设置了指定属性且其值以指定值开头的每个元素； </span><br><span class="line">[attribute$=value]选取设置了指定属性且其值以指定值结尾的每个元素； </span><br><span class="line">[attribute*=value]选取设置了指定属性且其值中包含指定值的每个元素； </span><br><span class="line">[attribute~=value]选取设置了指定属性，其值中包含指定值且作为单词存在的元素（★注：这里必须是作为独立存在的单词，即没有与除空格外的其他符号相连接）； </span><br><span class="line">[attribute|=value]选取设置了指定属性，其值中包含指定值且作为开头单词的前缀存在的元素（★注：这里必须是作为开头单词的前缀，即前面为空且后面跟上“-”）。</span><br></pre></td></tr></table></figure><p>★★注意：必须是具有显式设定出来的对应属性的元素才会被选中，如果标签内没有设置，而是使用默认值的元素，即使属性值满足条件也不会被选中！！！<br>★注意：这里的属性指的是HTML内的属性，而非CSS的属性！！！<br>★★★注意：属性选择器在优先级的判断上作用等价于类和伪类，不论其中究竟是哪个属性！！！（例如：id选择器给的优先级大于id属性选择器）</p><p>⑦伪元素——伪元素选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">★什么是伪元素？——伪元素不是元素（HTML标签），它只是页面元素的某个子结构，但是CSS中可以把它当作一个独立的元素来为其设置样式，所以叫做伪元素。</span><br><span class="line">★元素是在HTML代码中可以明确看到的标签；</span><br><span class="line">★伪元素则是HTML标签元素的一个子部分或子结构，它虽然逻辑上存在于这些元素结构中，但是在HTML语言中没有可以直接操纵它的对应标签，而在CSS中可以把这些子结构其视作为一个独立的元素并单独设</span><br><span class="line">置其样式。</span><br><span class="line"></span><br><span class="line">结构：</span><br><span class="line">父元素选择器::伪元素名&#123;属性名:值;...&#125;&lt;!--CSS1和CSS2标准中使用“:”，与伪类相同，有些浏览器现仍然可以识别--&gt;</span><br></pre></td></tr></table></figure><p>★注意：伪元素可以看作是CSS给相应标签虚构出来的子元素，所以通常要配合其他选择器来使用，前面的选择器指定该伪元素的父元素，如果没有时会选中所有元素对应的伪元素——即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::伪元素名&#123;...&#125;</span><br><span class="line">相当于</span><br><span class="line">*::伪元素名&#123;...&#125;</span><br><span class="line"></span><br><span class="line">::first-letter将父选择器对应元素中第一个行单元的第一个字符位置（★该位置放置的不一定是字符，所以不能用“第一个字符”笼统代替）作为伪元素并向其添加样式，CSS2.1之前只用于块级元素上，且可应用的属性是有限的；</span><br><span class="line">::first-line将父选择器对应元素中第一个行单元位置（★必须是真正的第一行）作为伪元素并向其添加样式，该伪元只能用于块级元素上，可应用的属性也是有限的；</span><br><span class="line">::selection将父选择器对应元素中文本内容被选中的部分作为伪元素并向其添加样式，只能对该为伪元素设置与颜色相关的属性；</span><br></pre></td></tr></table></figure><p>★★★注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.当父元素的第一个行单元被块级子元素完全占据时，:first-letter和:first-line会作用于该子元素内的第一个字符和第一个行，若该子元素内没有内容的话，则即便此时看不到，但实际上其仍然占据着第一行，固设置的样式仍然只作用于该子元素内；</span><br><span class="line">2.当父元素的第一个行单元的开头位置不是文本字符，而是一个行内/行内块级子元素时，:first-letter会作用于该子元素内的第一个字符，同上若没有内容就看不到效果；</span><br><span class="line">3.当父元素的第一个行单元内含有行内/行内块级子元素时，:first-line同时会作用于该子元素内的第一个行；</span><br><span class="line">4.::selection只能选中该父元素内的被选中文本内容，而作用不到其子元素内的被选中文本的样式；</span><br><span class="line"></span><br><span class="line">::before将父选择器对应元素中所有内容之前的紧邻位置作为一个伪子元素并向其添加样式，★该伪元素默认情况下是行内元素（可以通过display修改），还可以通过content属性向该伪元素中添加文本（带&quot;&quot;或&apos;&apos;）或url()中的内容；</span><br><span class="line">::after将父选择器对应元素中所有内容之后的紧邻位置作为一个伪子元素并向其添加样式，★该伪元素默认情况下是行内元素（可以通过display修改），还可以通过content属性向该伪元素中添加文本（带&quot;&quot;或&apos;&apos;）或url()中的内容；</span><br><span class="line">★★注意：::before和::after必须添加content属性，即使内容为空&quot;&quot;，否则该伪元素实际不生成！！！</span><br><span class="line">★注意：::before和::after作为伪元素时相当于选定元素的子元素级别，且其显示方式默认是行内元素！！！</span><br><span class="line"></span><br><span class="line">★注意：伪元素与优先级？？？</span><br><span class="line">div.one::first-line &#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">div.one::first-letter &#123;</span><br><span class="line">color:green;</span><br><span class="line">&#125;</span><br><span class="line">div.one &#123;</span><br><span class="line">color:blue !important;</span><br><span class="line">&#125;</span><br><span class="line">结果是——第一个字符为绿色，第一行其余字符为红色，其余行都为蓝色！！！</span><br><span class="line">分析：第一个字符以及第一行剩余字符被分离出来作为两个子元素，它们只能继承到父元素的蓝色，而!important不继承，因而被对应的伪元素选择器中的样式层叠掉了。</span><br><span class="line">结论：当用伪元素给某个元素设置样式时，浏览器会将对应的结构从该父元素中分离出来当作独立的子元素，此时这些伪子元素的样式只受对应的伪元素选择器直接控制，而父元素中设置的样式只能通过继承传过来。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">  ◆伪元素必须设置content属性，否则没有作用，哪怕设置空字符；</span><br><span class="line">  ◆伪元素属于行内元素；</span><br><span class="line">  ◆伪元素中不能再创建伪元素，且伪元素上不支持伪类（待确认？但可以利用父元素的伪类方法达到近似的代替效果）。</span><br><span class="line">错误div::before:hover &#123;...&#125;</span><br><span class="line">正确div:hover::before &#123;...&#125;</span><br></pre></td></tr></table></figure><p>☆注：能够操纵input标签中placeholder的伪元素有，谷歌苹果webkit内核——::-webkit-input-placeholder，火狐内核——::-moz-placeholder，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以及IE内核提供的伪类——:-ms-input-placeholder。</span><br></pre></td></tr></table></figure><p>⑧相邻兄弟选择器：选中与该元素位置上相邻的下一个兄弟元素，用”+”连接；<br>⑨后续兄弟选择器：选中与该元素同级的所有后续兄弟元素，用”~”连接；</p>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记 一</title>
    <link href="http://yoursite.com/2014/02/22/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://yoursite.com/2014/02/22/CSS学习笔记01/</id>
    <published>2014-02-22T02:00:36.000Z</published>
    <updated>2018-02-16T16:15:11.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记-·-一"><a href="#CSS学习笔记-·-一" class="headerlink" title="CSS学习笔记 · 一"></a>CSS学习笔记 · 一</h1><p>⑴W3C的三层分离标准：<br>  结构标准Html：从语义的角度描述页面的结构（尽管Html中也有一些用来设置样式的属性，但根据三层分离标准不推荐使用）；<br>  表现标准CSS：从样式的角度来修饰页面；<br>  行为标准JavaScript：从交互的角度提升用户体验。</p><p>⑵CSS层叠样式表（Cascading Style Sheets）：表现标准，给页面上的结构“穿上衣服”；<br>  作用：1.美化网页（通过css控制标签的样式）；<br>    2.网页布局（通过css控制标签的位置）。<br>    ☆注意：CSS必须以Html页面为基础，没有Html页面上的标签元素就无法显示设置的CSS样式！</p><p>  CSS的三种写法结构：<br>    ①行内样式：将CSS样式中的“属性名:值;”对直接放在对应标签内的style属性中，不使用选择器，但作用域仅限于当前标签；<br>          <x标签 style="属性名:属性值;属性名:属性值" ...=""><br>    ②嵌套样式：将CSS样式中的选择器及属性值设置放在位于head中的style标签里，必须使用相应的选择器，其作用域是当前整个Html文档；<br>          <head><br>            <style><br>                选择器 {<br>                    属性名:属性值;        /<em>声明：一对属性名与属性值既为一个声明。属性值一般用””括起来</em>/<br>                    …;<br>                }<br>            </style><br>        </head><br>    ③外联样式：将CSS样式中的选择器及属性值设置放在外部的后缀名为.css的文件中，并使用link标签引用到当前Html文档中，必须使用相应的选择器，其作用域是所有引用该CSS文件的Html文档。<br>        .css文件中：<br>        选择器 {<br>            属性名:属性值;        /<em>声明：一对属性名与属性值既为一个声明。属性值一般用””括起来</em>/<br>            …;<br>        }<br>        …<br>        .html页面中：<br>          <link rel="stylesheet" href="CSS文件路径"><br>    ★注意：外联样式表中不需要设置style标签，因为该标签是Html页面中的元素，而非CSS的组成部分！<br>    ★注意：行内样式中的属性值会具有较高的优先级，而内嵌和外联样式并不改变任何优先级顺序，只是要注意不同样式表对应的style标签或link标签引入时的顺序，这会优先级相同的属性值之间的层叠关系！！！</x标签></p>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记 四</title>
    <link href="http://yoursite.com/2014/02/21/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
    <id>http://yoursite.com/2014/02/21/HTML学习笔记04/</id>
    <published>2014-02-21T06:50:14.000Z</published>
    <updated>2018-02-16T14:54:40.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记-·-四"><a href="#HTML学习笔记-·-四" class="headerlink" title="HTML学习笔记 · 四"></a>HTML学习笔记 · 四</h1><p>⒋Html中的空格合并现象：<br>  原因：html对空格、tab以及换行不敏感，即所有相连的空格符、制表符以及回车符都会被合并为一个空格来显示。<br>  作用：方便调整页面代码布局，使其更加整洁，条理清晰。<br>★注意：只有HTML代码内容中的空格会合并，字符串属性值内的空格并不合并，因为其本身也是数据的一部分！！！<br>★注意：使用 <pre> 标签可以原样输出标签里的内容，即不进行 空格 合并！！！</pre></p><p>⒌Html中的转义字符：<br>           空格        &nbsp;<br>  &lt;        小于号        &lt;</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 大于号&amp;gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  &amp;        与号        &amp;<br>  …        …        …<br>★注意后面一定要以分号结尾！！！</p></blockquote><p>⒍SEO与标签的语义化：<br>  SEO：搜索引擎优化，让网页在搜索引擎的结果中具有更靠前的排名，以便增加点击量和访问流量；<br>  方法：花钱买排名；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将页面做成静态页面（区别JSP动态页面，通过运行Java程序动态生成的页面）；</span><br><span class="line">发外链（在其它网站上放上自己网站的链接）；</span><br></pre></td></tr></table></figure><p>★当前最重要：使页面更加的友好（规范）！在合适的地方使用合适的标签，合适地使用标签的语义化。<br>  只为讨好搜索引擎——网络爬虫！</p><p>  语义化：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）；<br>  方法：1.选择有语义的标签，尽可能少用div和span；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.在语义不明确的时候，要选择有语义的标签；</span><br><span class="line">3.如果要设置样式，推荐使用css，不要使用纯样式标签b、i、u、s以及font标签；</span><br><span class="line">4.需要强调文本时可以使用strong、em、ins或del。</span><br></pre></td></tr></table></figure><p>  意义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.网页结构合理；</span><br><span class="line">2.有利于SEO：和搜索引擎建立良好沟通，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取；</span><br><span class="line">3.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）；</span><br></pre></td></tr></table></figure><pre><code>4.便于团队开发和维护。</code></pre><p>⒏Html中标签的嵌套规则：<br>★注意：Html中的标签是不能随意嵌套的，例如：在p标签中放置div标签，浏览器会默认将p标签拆分并补全成两份p标签，使得div与p标签同级（网页源代码内容不变，Elements解析中的内容改变）！！</p><pre><code>1.推荐行内元素包含行内元素；2.段落标签中不能出现块级元素。</code></pre>]]></content>
    
    <summary type="html">
    
      HTML学习笔记
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记 三</title>
    <link href="http://yoursite.com/2014/02/20/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <id>http://yoursite.com/2014/02/20/HTML学习笔记03/</id>
    <published>2014-02-20T06:35:10.000Z</published>
    <updated>2018-02-16T14:54:27.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记-·-三"><a href="#HTML学习笔记-·-三" class="headerlink" title="HTML学习笔记 · 三"></a>HTML学习笔记 · 三</h1><p>¤双标签¤</p><p>①html标签：所有Html标签的一个根节点，有且只能有一个；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;&quot;&gt;其他标签&lt;/html&gt;</span><br></pre></td></tr></table></figure><pre><code>lang属性：当前页面主要信息使用的语言，影响SEO搜索引擎优化的权重计算，以及一些其他特殊设置——盲人语音系统。</code></pre><p>  body标签：html标签下的第二个子节点，同时也是所有浏览器窗口内显示元素的根节点，同样有且只能有一个；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;...&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>★★★★注意：html标签与body标签都是块级元素，而实际上html以浏览器窗口为父元素！！！可以设置html与body的宽高为100%，从而得到一个随着浏览器窗口大小改变而改变的盒子！！！<br>★★★★注意：给body设置背景时，该背景并不以body为基准，而是以整个浏览器窗口为基准，作为整个浏览器窗口的背景！！！奇怪！！</p><p>②head标签：用于存放title、meta、base、style、link、script等标签；<br>      <head>…</head><br>★注意：Head标签中必须要设置的只有title标签！</p><p>  title标签：让页面拥有一个标题；<br>      <title>标题文本</title><br>★注意：title中的文本在SEO中占有很大的权重！</p><p>  style标签：放置嵌入的CSS样式；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;...&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>  script标签：放置嵌入的JS脚本；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;...&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>③h系列的标签（Header）：h1、h2、h3、h4、h5、h6，标题标签（带有浏览器默认样式，字体大小、加粗，h1字体最大）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;标题1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;标题2&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>★注意：在一个网页中最好只有一个h1标签，有利于SEO！！！</p><p>④p标签（Paragraph）：段落标签（带有浏览器默认样式，单独占一行，与其他元素有外间距）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;内容&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>⑤格式化标签：b（Bold），i（Italic），s（Strikethrough），u（Underlined），strong，em，del，ins，font；<br>  标签作用：<br>  b：加粗             <b></b><br>  i：倾斜             <i></i><br>  s：删除线             <s></s><br>  u：下划线             <u></u><br>★注意：以上标签没有携带语义——一个字母没有其字面含义，推荐用下面的标签替代！！！<br>  strong：用加粗强调内容    <strong></strong><br>  em：用倾斜强调内容        <em></em><br>  del：用删除线强调内容        <del></del><br>  ins：用下划线强调内容        <ins></ins><br>★注意：以上四个标签的语义是通过特定的样式“强调”内容，可以使用！<br>  font：设置文字颜色或者大小；    <font color="" size="1-10">文本</font></p><p>⑥a标签（Anchor）：锚标签/超链接/锚链接，语义是跳转到当前或其他页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; target=&quot;&quot;&gt;文本或图片内容&lt;/a&gt;&lt;!--href指明跳转页面的URL，&quot;#&quot;表示跳转到当前页面顶端（不刷新），网页路径后面会加上#显示已经跳转，&quot;&quot;表示刷新当前页面，&quot;javascript:;&quot;或&quot;javascript:void(0);&quot;表示（当使用JS来实现跳转功能时）充当填充符，点击无任何跳转，&quot;&quot;；target表示在何处打开跳转页面，_blank空白页面，默认值_self当前页面--&gt;</span><br><span class="line">★其他用法（锚链接）：跳转到当前页面或其他页面的特定位置（href=&quot;#id&quot;或href=&quot;页面路径#id&quot;），下载压缩包中的文件（不建议使用）。</span><br><span class="line">☆非必要属性title：同img；</span><br><span class="line">★注意：a标签之间必须有文本或图片标签内容，否则该链接不可见（行内元素大小根据内容）！</span><br><span class="line">★base标签：放在head标签中，为页面上所有链接规定默认地址或默认目标，&lt;base href=&quot;&quot; target=&quot;&quot; /&gt;；</span><br></pre></td></tr></table></figure><p>⑦两个没有语义的标签：div与span；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div标签：一行之内只能有一个，默认情况下宽继承（通常占一整行），高由内容来决定，可以设置大小——块级元素；</span><br></pre></td></tr></table></figure><p>★注意：现在多采用Div+CSS设计样式，其中通常使用div来进行页面布局——即将页面划分为若干个功能部分！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span标签：一行之内可以有多个，默认情况下大小由内容来决定，不可以设置大小——行内元素；</span><br></pre></td></tr></table></figure><p>⑧Html5中新增的语义标签（替代div）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">section标签：网页布局中的大区域</span><br><span class="line">&lt;section&gt;&lt;/section&gt;</span><br><span class="line">header标签：网页布局中的头部——页眉</span><br><span class="line">&lt;header&gt;&lt;/header&gt;</span><br><span class="line">nav标签：表示的就是导航区域</span><br><span class="line">&lt;nav&gt;&lt;/nav&gt;</span><br><span class="line">article标签：网页布局中的文章部分</span><br><span class="line">&lt;article&gt;&lt;/article&gt;</span><br><span class="line">aside标签：网页布局中侧边栏部分</span><br><span class="line">&lt;aside&gt;&lt;/aside&gt;</span><br><span class="line">footer标签：网页布局中的结尾部分——页脚</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">总结:◆这些标签的用法与div用法一样；</span><br><span class="line">     ◆这些标签有语义，而div没有语义。</span><br></pre></td></tr></table></figure><p>⑨列表标签：ul、ol和dl，成一列或一行的数据通常使用列表标签；</p><p>  ul标签（Unordered List）：无序列表，各个列表项之间没有顺序级别之分，是并列的关系；<br>  <ul>                <!--块级元素：默认的display生成框类型是block--></ul></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;容器内容&lt;/li&gt;&lt;!--li:List Item，无序或有序列表的列表项，是一个容器，默认的display生成框类型是list-item--&gt;</span><br><span class="line">&lt;li&gt;...&lt;/li&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>  常用属性type：用来设置列表项开头标记的显示方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type=&quot;none&quot;：不显示任何标记；</span><br><span class="line">type=&quot;disc&quot;：默认值，显示一个实心圆；</span><br><span class="line">type=&quot;square&quot;：显示一个实心方块；</span><br><span class="line">type=&quot;circle&quot;：显示一个空心圆圈。</span><br></pre></td></tr></table></figure><p>★注意：1.无序列表中的数据没有先后顺序之分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.ul标签不要独自出现，至少有一组li标签。</span><br><span class="line">3.ul标签是用来管理li标签的。</span><br><span class="line">4.ul标签中只能放li标签。</span><br><span class="line">5.li标签是一个容器。</span><br><span class="line">6.li标签中可以放其他标签。</span><br></pre></td></tr></table></figure><p>  ol标签（Ordered List）：有序列表，即有排列顺序的列表，其各个列表项按照一定的顺序排列定义；<br>  <ol>                <!--块级元素：默认的display生成框类型是block--></ol></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;容器内容&lt;/li&gt;</span><br><span class="line">&lt;li&gt;...&lt;/li&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>  常用属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type属性：设置有序列表项前序号的类型，属性值“1”数字，“a”小写字母，“A”大写字母，“i”小写罗马数字，“I”大写罗马数字。</span><br><span class="line">start属性：设置列表项的序号是从第几个开始的，默认值是1。</span><br></pre></td></tr></table></figure><p>  ☆注：还可以在li标签中设定属性value＝”n”来强行改变当前列表项序号，后面紧跟的列表项自动递增。</p><p>  dl标签（Definition List）：自定义列表,常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号；<br>  <dl>                <!--块级元素：默认的display生成框类型是block--></dl></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dt&gt;&lt;/dt&gt;&lt;!--dt:Definition Term，自定义列表项的标题，块级元素：默认的display生成框类型是block--&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;&lt;!--dd:Definition Description，自定义列表中的项目，块级元素：默认的display生成框类型是block--&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">...</span><br><span class="line">&lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <br>  常用位置：网页最下方的服务栏。</p><p>⑩table标签：表格标签，显示多行多列的数据；</p><p>  基本结构：table框、tr行、td/th列（单元格）<br>  <table>                    <!--默认的display生成框类型是table--></table></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--tbody--&gt;&lt;!--浏览器解析的时候会自动默认添加一个tbody标签，默认的display生成框类型是table-row-group--&gt;</span><br><span class="line">&lt;tr&gt;&lt;!--行容器，默认的display生成框类型是table-row--&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;&lt;!--单元格，默认的display生成框类型是table-cell--&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!--/tbody--&gt;</span><br></pre></td></tr></table></figure><p>  </p><p>  完整结构：caption标题、thead头部、tbody主体、tfoot尾部<br>  <table></table></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;caption&gt;&lt;/caption&gt;&lt;!--表格标题--&gt;</span><br><span class="line">&lt;thead&gt;&lt;!--thead必须与tbody和tfoot一同使用，必须包含一个tr，thead的默认行高样式要低一些以突出tbody主题内容，默认的display生成框类型是table-row-group--&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;&lt;/th&gt;&lt;!--th:表头标题单元格，默认加粗居中显示，默认的display生成框类型是table-cell--&gt;</span><br><span class="line">&lt;th&gt;&lt;/th&gt;</span><br><span class="line">&lt;th&gt;&lt;/th&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tfoot&gt;&lt;!--必须包含一个tr，tfoot的默认行高样式也要低一些以突出tbody主题内容，默认的display生成框类型是table-row-group--&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tfoot&gt;</span><br><span class="line">&lt;tbody&gt;&lt;!--浏览器会默认添加tbody--&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><p>  </p><p>  常用属性：根据W3C三层分离标准，以下HTML属性皆不推荐使用，而用CSS样式！<br>  border：设置边框宽度（包括单元格边框与总边框），默认值0（Html中属性值一般无单位，px是CSS单位）；<br>  width：设置表格宽度，可用具体数值（不带单位）或者百分比%（以父元素宽度为基准）；<br>  height：设置表格高度，可用具体数值（不带单位）或者百分比%（以父元素宽度为基准）；<br>  cellspacing：设置单元格间距，默认值是2（间距值为0时，单元格的相邻边框相接，总宽度是border的2倍）；<br>  cellpadding：设置单元格填充，默认值是1；<br>  align：设置对齐方式，属性值是left默认/center/right；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置给table标签时——让表格在父容器中靠左/居中/靠右，但不影响内部文字的对齐方式；</span><br><span class="line">设置给tr、td/th时——让内部的文本内容靠左/居中/靠右；</span><br></pre></td></tr></table></figure><p>  bgcolor：设置表格、行或单元格的背景颜色（red、#ccc、rgb()）；</p><p>★合并单元格方法：给想要合并的单元格中最左上的单元设置以下属性，并删除被合并的多余单元格；<br>  rowspan：设置单元格所占据的行单位，默认是1，用来进行纵向合并；<br>  colspan：设置单元格所占据的列单位，默认是1，用来进行横向合并；<br>  本质：让该单元格占据更大的空间单位，从而像是合并了一样！</p><p>  CSS样式：<br>  table{border:1px solid red;border-collapse：collapse;}    /<em>表格属性：border-collapse属性设置边框强制合并，并忽略border-spacing和empty-cells属性</em>/<br>  th,td{border:1px solid red;}<br>★注意：在不使用CSS属性的情况下，去制作细线表格的方法，利用bgcolor背景色和cellspacing单元格间距来“假装”有1px的边框！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.table背景色设为想要的边框颜色，且不设边框；</span><br><span class="line">2.单元格的背景色设为白色（假装没有背景色）；</span><br><span class="line">3.cellspacing设为边框宽度（让单元格间出现table背景色，装作边框）。</span><br></pre></td></tr></table></figure><p>⑪表单：主要负责数据采集功能，收集用户的信息，将来提交到对应的服务器程序；<br>  组成：表单域、提示信息和表单控件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.表单域：form标签，相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器；</span><br><span class="line">&lt;form name=&quot;form_name&quot; action=&quot;url&quot; method=&quot;get|post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;/form&gt;</span><br><span class="line">name：定义表单的名称；</span><br><span class="line">action：用来指定表单处理程序的路径(服务器端脚本处理程序）；</span><br><span class="line">method：定义表单结果从浏览器传送到服务器的方式，默认参数为get（显示具体的name=value信息），而post不显示具体信息；</span><br><span class="line">enctype：指定上传文件的编码类型，常用&quot;multipart/form-data&quot;；</span><br><span class="line">2.提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作；</span><br><span class="line">3.表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等；</span><br></pre></td></tr></table></figure><p>  控件分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.input控件：一种表单控件标签，用来收集用户的信息，将来提交到对应的服务器程序，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型；</span><br></pre></td></tr></table></figure><pre><code>&lt;input type=&quot;text&quot; value=&quot;设置default默认值&quot; readonly /&gt;                &lt;!--文本框--&gt;&lt;input type=&quot;password&quot; value=&quot;设置default默认值&quot; disabled /&gt;                &lt;!--密码框--&gt;&lt;input type=&quot;hidden&quot; value=&quot;设置default默认值&quot; /&gt;                    &lt;!--隐藏域--&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; multiple accept=&quot;选择文件类型或后缀&quot;&gt;&lt;!--文件上传--&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;input type=&quot;radio&quot; checked name=&quot;设置所属分组名&quot; value=&quot;设置输入值&quot; /&gt;            &lt;!--单选框，每一组同时只有一个能够被选中，可设置某一个默认被选中，当同组的多个被设置默认选中时，最后一个默认选中起作用--&gt;&lt;input type=&quot;checkbox&quot; checked name=&quot;设置所属分组名[]&quot; value=&quot;设置输入值&quot; /&gt;        &lt;!--复选框--&gt;&lt;input type=&quot;reset&quot; value=&quot;设置文本&quot; /&gt;                            &lt;!--重置按钮，默认显示“重置”，功能是将同一张表单中所有元素重置--&gt;&lt;input type=&quot;submit&quot; /&gt;                                    &lt;!--提交按钮，默认显示“提交”，点击提交表单--&gt;&lt;input type=&quot;image&quot; src=&quot;路径&quot; /&gt;                            &lt;!--图片提交按钮，点击提交表单--&gt;&lt;input type=&quot;button&quot; value=&quot;设置按钮上文本&quot; /&gt;                        &lt;!--普通按钮，不能直接提交表单，通常配合JS使用--&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">★注意：reset和submit/image必须放在form标签结构中才能起作用，而且其作用范围也只限于当前form标签中的表单元素！！！</span><br><span class="line">常用属性：size设置该控件在页面中的显示宽度；</span><br><span class="line">  readonly设置该控件内容为只读（不能编辑或修改）；</span><br><span class="line">  disabled设置该控件默认为禁用（样式为灰色）；</span><br><span class="line">  checked设置单选框或复选框默认被选中；</span><br><span class="line">  maxlength设置该文本输入控件允许输入的最多字符数。</span><br><span class="line">配合标签：label标签可以给input元素设置一个标注，点击该标注元素时会选中其连接的input元素；</span><br><span class="line">&lt;label for=&quot;input标签的id&quot;&gt;标签名称&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">HTML5新增的智能表单控件：</span><br><span class="line">&lt;input type=&quot;email&quot;&gt;&lt;!--邮箱输入框，自动检查输入内容是否复合邮箱地址的格式--&gt;</span><br><span class="line">&lt;input type=&quot;url&quot;&gt;&lt;!--网址输入框，自动检查输入内容是否复合url的格式--&gt;</span><br><span class="line">&lt;input type=&quot;number&quot;&gt;&lt;!--数字输入框，只能输入数字--&gt;</span><br><span class="line">&lt;input type=&quot;tel&quot;&gt;&lt;!--电话号码输入，自动检查……--&gt;</span><br><span class="line">&lt;input type=&quot;color&quot;&gt;&lt;!--颜色输入框，点击弹出一个拾色器--&gt;</span><br><span class="line">&lt;input type=&quot;range&quot;&gt;&lt;!--滑块--&gt;</span><br><span class="line">&lt;input type=&quot;time&quot;&gt;&lt;!--时间输入框，点击弹出时间选择器--&gt;</span><br><span class="line">&lt;input type=&quot;date&quot;&gt;&lt;!--日期--&gt;</span><br><span class="line">&lt;input type=&quot;week&quot;&gt;&lt;!--星期--&gt;</span><br><span class="line">&lt;input type=&quot;month&quot;&gt;&lt;!--月份--&gt;</span><br><span class="line">☆注：新增表单控件一般有兼容性问题，通常在PC端使用！！！</span><br><span class="line">2.非input控件：</span><br><span class="line">  select与optgroup、option：下拉/多选列表框与列表组、列表项；</span><br><span class="line">&lt;select name=&quot;&quot; multiple size=&quot;&quot;&gt;</span><br><span class="line">&lt;optgroup label=&quot;&quot;&gt;</span><br><span class="line">&lt;option value=&quot;值1&quot;&gt;选项1&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;值2&quot; selected&gt;选项2&lt;/option&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">  常用属性：multiple设置该列表框可以多选，方法是按住Ctrl键点击多个要选择的选项，此时列表框不用点击展开而是一直展开；</span><br><span class="line">    size设置列表框同一时间可见选项的数目；</span><br><span class="line">    selected设置该option选项默认情况下被选中，单选状态下，同时只有一个能够被选中，当多个被设置默认选中时，最后一个默认选中起作用；</span><br><span class="line">      多选状态下，可以同时设置多个被默认选中。</span><br><span class="line"></span><br><span class="line">  textarea：多行文本输入框；</span><br><span class="line">&lt;textarea rows=&quot;显示行数&quot; cols=&quot;每行可输入字符数&quot;&gt;文本内容&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">  fieldset与legend：表单控件集合域与集合名；</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">&lt;legend&gt;区域标题&lt;/legend&gt;</span><br><span class="line">&lt;input...&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">  datalist：外挂式数据列表控件；</span><br><span class="line">&lt;input type=&quot;text&quot; list=&quot;listID&quot;&gt;</span><br><span class="line">&lt;datalist id=&quot;listID&quot;&gt;</span><br><span class="line">&lt;option value=&quot;bj&quot;&gt;数据&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p>  通用属性：name设置控件名称和value设置控件值（或默认内容）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  1.当提交一张表单时，浏览器向处理程序传递一对对的（name=value）——键值对，其中name对应传递给处理程序该张表单的某个表单控件的name属性，而后面的value值所代表的意义是用户在该控件上做了</span><br><span class="line">    什么操作——即输入了什么内容或者选择了那个选项，并不一定就是该控件默认value属性值。例如，文本框/密码框/隐藏框/邮件框/地址框等文本输入框中，value属性设置的是默认输入内容，也即默认显</span><br><span class="line">    示文本（前提没有设置placeholder），若用户没有输入修改则提交该默认信息，若用户修改了输入框内容，则提交新的信息；但是对于单选框/复选框/下拉框等非文本输入控件，若某项被选中时提交的就</span><br><span class="line">    是给该项设置的value属性值以及对应的name属性值。所以要根据控件类型的不同来设置对应的name和value属性。</span><br><span class="line">  2.单选框：通过设置相同的name来确认分组，同一组中的单选框同时只能有一个是被选中的，而提交时只提交被选中的单选框对应的value值和该组的公共name，单选框的value值一般应是不同的，处理程序</span><br><span class="line">    通过value值来判断用户选择了那一个选项。</span><br><span class="line">  3.多选框：通过设置相同的name来进行分组，同一组中的多选框同时可以有多个是被选中的，且提交时将提交所有选中多选框对应的value值和该组的公共name，所以一般要在name中加上&quot;[]&quot;以表示该名称对应</span><br><span class="line">    的值有多个，服务器在接收时会将其作为一个数组。</span><br><span class="line">★4.所有可能同时拥有多个value值的表单控件名name，都应当在其末尾带上&quot;[]&quot;，否则，虽然提交表单时所有的数据都会以（name=value）键值对的形式传递给服务端，但是服务器接收相同name名的数据时，</span><br><span class="line">    只会使用同一个位置——即会造成同名数据之间的覆盖，只有最后一个value值能真正地被保留到服务端；服务端接收带有&quot;[]&quot;name值的value数据时，会将其解析为一个多值的数组，这样同名的数据之间</span><br><span class="line">    才不会相互覆盖——例如，input.checkbox多选按钮、select:multiple多选状态下的下拉列表、input.file:multiple多选状态下的上传文件按钮！！！</span><br></pre></td></tr></table></figure><p>  HTML5新增表单属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">placeholder：占位符，设置输入内容为空且没有获得焦点的状态下（有些内核中获得焦点下依然显示该信息）显示在文本框中的提示信息，要区别该属性与value属性设置的默认值，占位符不会提交；</span><br><span class="line">&lt;input type=&quot;text&quot; placeholder=&quot;显示的提示文本&quot;&gt;</span><br><span class="line">autofocus：自动获取焦点；</span><br><span class="line">&lt;input type=&quot;text&quot; autofocus&gt;</span><br><span class="line">autocomplete：自动完成，控件会在一个datalist数据列表中显示之前提交过的内容；</span><br><span class="line">&lt;input type=&quot;text&quot;  autocomplete=&quot;off|on&quot;&gt;</span><br><span class="line">required：必填项，如果当前内容为空时会提示无法提交表单；</span><br><span class="line">&lt;input type=&quot;text&quot;  required&gt;</span><br><span class="line">form：关联form表单，将一个位于form标签外的表单控件作为该表单的一部分；</span><br><span class="line">&lt;input type=&quot;text&quot;  form=&quot;表单ID&quot;&gt;</span><br><span class="line">novalidate：关闭验证，关闭智能控件的验证信息；</span><br><span class="line">&lt;form novalidate&gt;&lt;/form&gt;</span><br><span class="line">★注意：在表单控件及下面的多媒体控件的属性中，有很多属性是不需要属性值的，如表单控件checked、selected、disabled和多媒体控件control等，只要该属性名出现在标签内，无论其属性值是什么，都可以</span><br><span class="line">起作用，所以设置该属性的时候可以不设置属性值，只添加上属性名就行了！！！</span><br></pre></td></tr></table></figure><p>⑫多媒体标签：video和audio；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">video：视频标签；</span><br><span class="line">&lt;video src=&quot;&quot; controls loop autoplay poster=&quot;封面图片url&quot;&gt;&lt;/video&gt;</span><br><span class="line">或</span><br><span class="line">&lt;video controls loop autoplay&gt;</span><br><span class="line">&lt;source src=&quot;播放源1&quot;&gt;&lt;!--设置多个播放源文件，按顺序选择第一个能够播放的文件进行播放，这样可以防止由于不支持某种格式的文件而导致播放失败--&gt;</span><br><span class="line">&lt;source src=&quot;播放源2&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/video&gt;</span><br><span class="line">audio：音频标签；</span><br><span class="line">&lt;audio src=&quot;&quot; controls loop autoplay&gt;&lt;/audio&gt;</span><br><span class="line">或</span><br><span class="line">&lt;audio controls loop autoplay&gt;</span><br><span class="line">&lt;source src=&quot;播放源1&quot;&gt;&lt;!--设置多个播放源文件，按顺序选择第一个能够播放的文件进行播放，这样可以防止由于不支持某种格式的文件而导致播放失败--&gt;</span><br><span class="line">&lt;source src=&quot;播放源2&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line">常用属性：</span><br><span class="line">src：设置视频的路径；</span><br><span class="line">controls：显示控制栏；</span><br><span class="line">loop：设置视频循环播放；</span><br><span class="line">autoplay：自动播放；</span><br></pre></td></tr></table></figure><p>★注意：多媒体标签都有自己的缩放比例关系，包括img标签！！！</p>]]></content>
    
    <summary type="html">
    
      HTML学习笔记
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记 二</title>
    <link href="http://yoursite.com/2014/02/19/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>http://yoursite.com/2014/02/19/HTML学习笔记02/</id>
    <published>2014-02-19T06:30:06.000Z</published>
    <updated>2018-02-16T16:08:18.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记-·-二"><a href="#HTML学习笔记-·-二" class="headerlink" title="HTML学习笔记 · 二"></a>HTML学习笔记 · 二</h1><hr><h2 id="HTML标签-·-单标签："><a href="#HTML标签-·-单标签：" class="headerlink" title="HTML标签 · 单标签："></a>HTML标签 · 单标签：</h2><p><strong>①hr标签（Horizontal Rule）：</strong>水平线标签，显示一条水平直线。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>②br标签（Break）：</strong>换行标签，在当前位置添加换行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③meta标签：</strong>元信息标签，提供页面元信息；</p><ul><li><p>常用用法1：主要用于提供当前网页的信息;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--content属性是必须的，提供以下名称对所应的值！</span></span><br><span class="line"><span class="comment">name="description"：表示content内容是对网站的描述——SEO与搜索引擎权重；</span></span><br><span class="line"><span class="comment">name="keywords"：表示content内容是该网站的关键字——SEO与搜索引擎权重；</span></span><br><span class="line"><span class="comment">name="author"：网页的制作者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name="viewport"：定义视口（html标签）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, height=3000, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name="apple-mobile-web-app-status-bar-style"：设置移动端状态条颜色样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name="format-detection"：设置取消电话号码的默认格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>常用用法2：Xhtml和Html4;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--content属性是必须的，提供以下名称对所应的值！</span></span><br><span class="line"><span class="comment">http-equiv="Content-Type"：告知浏览器该文件类型及charset字符集；</span></span><br><span class="line"><span class="comment">http-equiv="Refresh"：网页重定向，如content="5;url=http://www.w3school.com.cn"表示5秒后跳转到url指定的网页；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">""</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">""</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--http-equiv="X-UA-Compatible"：设置浏览器优先使用什么模式来渲染页面；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>☆注：</em>http-equiv提供的元信息会被添加在响应报文头，优先传递给浏览器；  </p></li><li><p>常用用法3：Html5;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--告知浏览器当前Html文件的字符集编码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--字符集：表示文件存储时采用的字符编码系统，同一个字符在不同字符集中对应的二进制代码不一定相同，因而文件存储时采用的字符编码必须与meta标签提供的信息相一致，否则浏览器无法正确识别出网页内容，产生乱码现象。text记事本在保存时可以选择编码方式，sublime中可以通过文件菜单选项改变编码格式。</span></span><br><span class="line"><span class="comment">UTF-8：国际，全字符，大、慢，汉字3字节；</span></span><br><span class="line"><span class="comment">GBK：中国，中文日文，小、快，汉字2字节。--&gt;</span></span><br></pre></td></tr></table></figure><p>★注意：meta中设置的所有内容在页面中都不会显示，只用来提供给浏览器使用！</p></li></ul><p><strong>④注释标签：</strong>将页面上的一段代码无效化，但仍然保留在源码当中；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释内容--&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>作用：</em></strong>在写页面时可以使用注释来划分结构！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--这是页面的头部，Begin--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--头部内容--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--这是页面的头部，End--&gt;</span></span><br></pre></td></tr></table></figure><p><em>☆注：</em>页面中注释的分类有</p><ul><li><p>Html注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释内容--&gt;</span><br></pre></td></tr></table></figure></li><li><p>CSS注释：位于style标签内；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*注释内容*/</span><br></pre></td></tr></table></figure></li><li><p>Javascript注释：位于script标签内；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//单行内容</span><br><span class="line">/*多行内容*/</span><br></pre></td></tr></table></figure><p><strong><em>★注意：</em></strong>Html和CSS的注释以及JS的多行注释都不能嵌套！！！</p></li></ul><p><strong>⑤base标签：</strong>为当前页面内的所有超链接设置默认的href和target属性值；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">""</span>/&gt;</span>|<span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑥link标签：</strong>引用一个外部文件；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必要属性：rel表示连接的类型，href表示连接文件的路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引用外部样式表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">".css"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引用网页图标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑦img标签（Image）：</strong>图片标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必要属性：src表示文件的相对或绝对路径URL，alt表示无法显示图片时的替换文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--非必要属性title：通常是图片的描述说明，鼠标停留在图片上时显示；</span></span><br><span class="line"><span class="comment">非必要属性width/height：设置宽度/高度--&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>★注意：</em></strong>由于搜索引擎通过查看alt属性值来分类图片，所以通常要使用alt设置图片描述信息，有利于<strong>SEO</strong>！！</p><p><strong><em>★注意：</em></strong>给img标签设置<strong>width</strong>或<strong>height</strong>属性，单独设置某一项时，另一项会按比例关系缩放（因为多媒体标签有自己的缩放比例关系），但是同时设置两个值时就有可能扭曲失真！！！<br><strong><em>★注意：</em></strong>当浏览器内核显示页面过程中发现需要显示一个图片元素时，就需要再次发送一个请求报文，来从服务器获取该图片！</p><hr><h2 id="文件路径分类："><a href="#文件路径分类：" class="headerlink" title="文件路径分类："></a>文件路径分类：</h2><h3 id="1-相对路径："><a href="#1-相对路径：" class="headerlink" title="1.相对路径："></a>1.相对路径：</h3><p>​    从当前文件所在的文件夹开始（./表示当前目录且可省略，../表示上一级目录且可以连用），只能访问到同一个盘符下的文件，无法访问到其他盘符下的文件。</p><h3 id="2-绝对路径："><a href="#2-绝对路径：" class="headerlink" title="2.绝对路径："></a>2.绝对路径：</h3><p>​    从某盘符或网络IP地址开始（如 C:...或<a href="https://192.168.1.1/...），可以通过绝对路径访问其他盘的文件。" target="_blank" rel="noopener">https://192.168.1.1/...），可以通过绝对路径访问其他盘的文件。</a></p>]]></content>
    
    <summary type="html">
    
      HTML学习笔记
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记 一</title>
    <link href="http://yoursite.com/2014/02/17/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://yoursite.com/2014/02/17/HTML学习笔记01/</id>
    <published>2014-02-17T06:20:00.000Z</published>
    <updated>2018-02-16T15:31:32.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记-·-一"><a href="#HTML学习笔记-·-一" class="headerlink" title="HTML学习笔记 · 一"></a>HTML学习笔记 · 一</h1><hr><h2 id="㈠-认识网页："><a href="#㈠-认识网页：" class="headerlink" title="㈠ 认识网页："></a>㈠ 认识网页：</h2><h3 id="1-网页组成："><a href="#1-网页组成：" class="headerlink" title="1.网页组成："></a>1.网页组成：</h3><p>​    网页是由文字、图片、按钮、输入框、视频……等元素组成的，而这些元素的本质是——HTML标签；</p><p>​    所以，网页其实就是由各种<strong><em>HTML标签</em></strong>组成的！</p><h3 id="2-网页标准："><a href="#2-网页标准：" class="headerlink" title="2.网页标准："></a>2.网页标准：</h3><ul><li>结构标准：<strong><em>HTML</em></strong>        -&gt; 搭建网页结构；</li><li>表现标准：<strong><em>CSS</em></strong>        -&gt;  修饰美化网页；</li><li>行为标准：<strong><em>JavaScript</em></strong>    -&gt; 让网页有动作；</li></ul><hr><h2 id="㈡浏览器与服务器："><a href="#㈡浏览器与服务器：" class="headerlink" title="㈡浏览器与服务器："></a>㈡浏览器与服务器：</h2><h3 id="1-浏览器："><a href="#1-浏览器：" class="headerlink" title="1.浏览器："></a>1.浏览器：</h3><p>​    浏览器是指，可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。</p><h3 id="2-服务器："><a href="#2-服务器：" class="headerlink" title="2.服务器："></a>2.服务器：</h3><p>​    服务器也称伺服器，是指提供计算服务的设备。</p><h3 id="3-一般工作过程："><a href="#3-一般工作过程：" class="headerlink" title="3.一般工作过程："></a>3.一般工作过程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器地址栏中输入域名 → 浏览器发送请求报文 → 服务器发送响应报文 → 浏览器内核解释并渲染网页内容 → 显示网页</span><br></pre></td></tr></table></figure><p><strong><em>★注意：</em></strong>输入的<strong>域名</strong>可以通过<em>DNS域名解析</em>服务转换为具体的<strong>IP地址</strong>，地址栏中一个完整的URL包括——</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议名(Http/Https/Ftp/File等)://域名或IP地址[:端口号]/路径标识?查询参数#hash地址</span><br></pre></td></tr></table></figure><p><em>☆注：</em>①Http协议：超文本传输协议，也就是浏览器和服务器端的网页传输数据的约束和规范，包括请求报文、响应报文、URL统一资源定位符等；</p><p>Https协议：使用安全套接字进行加密传输，比<strong>Http</strong>更加安全，目前用的最多；</p><p>Ftp协议：文件传输协议。</p><p>②可以在地址栏中用<strong>localhost</strong>代表本地主机的IP地址。</p><p>③如果地址栏中没有设置要访问的端口号，则<strong>浏览器</strong>会采用默认的端口<strong><em>80</em></strong>；如果没有设置要访问的具体页面，则<strong><em>服务器</em></strong>通常会返回设置的默认主页。</p><h3 id="4-浏览器开发者工具："><a href="#4-浏览器开发者工具：" class="headerlink" title="4.浏览器开发者工具："></a>4.浏览器开发者工具：</h3><p>通过页面中右键菜单的<em>审查元素/检查</em>或按<em>F12</em>可以打开浏览器中的开发者工具。</p><ul><li>Network→Name选择相应网页文件→Headers查看请求报文及响应报文相关信息Request Headers/Response Headers→Response查看响应报文内容；      </li></ul><ul><li><p>Elements→将网页源代码解析整理之后以元素的形式排列显示，可以在该处暂时删除修改元素、调整样式布局、直接修改盒子模型等；</p><p><strong><em>★注意：</em></strong>此处的内容并不一定与源代码完全相同，内核可能会自动更改一些错误！！！</p></li></ul><h3 id="5-浏览器内核："><a href="#5-浏览器内核：" class="headerlink" title="5.浏览器内核："></a>5.浏览器内核：</h3><p>​    又称<strong>渲染引擎</strong>——负责对网页语法的解释并渲染网页内容，不同的内核在渲染同一内容时会有差别；</p><p>分类：</p><ul><li>Trident——<strong><em>微软IE</em></strong>，猎豹，360，百度；</li><li>Gecko——<strong><em>火狐Firefox</em></strong>；</li><li>Presto——<strong><em>欧鹏Opera</em></strong>，现已放弃转向Blink；</li><li>Webkit——<strong><em>苹果Safari</em></strong>；</li><li>Blink——<strong><em>谷歌Chrome</em></strong>，Opera；</li></ul><h3 id="6-浏览器的基本组成："><a href="#6-浏览器的基本组成：" class="headerlink" title="6.浏览器的基本组成："></a>6.浏览器的基本组成：</h3><ul><li>用户界面；</li><li>浏览器引擎：<ul><li>渲染引擎(内核)：处理HTML和CSS；</li><li>JS解析器：处理JavaScript。</li></ul></li></ul><h3 id="7-浏览器生成页面的步骤：内核渲染引擎的工作过程；"><a href="#7-浏览器生成页面的步骤：内核渲染引擎的工作过程；" class="headerlink" title="7.浏览器生成页面的步骤：内核渲染引擎的工作过程；"></a>7.浏览器生成页面的步骤：内核渲染引擎的工作过程；</h3><pre><code>1.根据HTML生成结构树；2.根据CSS生成样式树；3.将结构树和样式树结合生成渲染树(页面已经可以准备进行渲染了)；4.渲染操作：  4.1 排列：将元素设置到指定位置，并设置指定尺寸；  4.2 绘制：写字，画颜色，画图片；5.通过用户和浏览器的交互操作，可能会触发页面的一些效果，而这些效果会引发重排和重绘，从而对页面的性能造成影响。</code></pre><hr><h2 id="㈢HTML-Hyper-Text-Markup-Language-超文本标记语言："><a href="#㈢HTML-Hyper-Text-Markup-Language-超文本标记语言：" class="headerlink" title="㈢HTML(Hyper Text Markup Language)超文本标记语言："></a>㈢HTML(Hyper Text Markup Language)超文本标记语言：</h2><p>​    网页的<strong><em>结构标准</em></strong>，是一种在浏览器上运行的<em>标记语言</em>。</p><h3 id="1-HTML基本结构："><a href="#1-HTML基本结构：" class="headerlink" title="1.HTML基本结构："></a>1.HTML基本结构：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--DOCTYPE标签：告诉浏览器当前文档的类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE...&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Html标签：Html结构中的根标签，有且只能有一个--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Head标签：可以设置网页样式style，可以设置网页标题title，设置网页关键字meta，网页描述信息meta，js代码编写script，链接文件link--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Title标签：设置网页标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Meta标签：提供元信息——名称/值对，name/http-equiv提供名称，content提供对应的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Style标签：放置CSS样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Script标签：放置JS脚本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Base标签：设置所有超链接的默认属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Link标签：链接CSS等文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Body标签： 放置的是网页的主体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--其他代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-DOCTYPE："><a href="#2-DOCTYPE：" class="headerlink" title="2.DOCTYPE："></a>2.DOCTYPE：</h3><p>​    <strong>文档类型标签</strong>位于文件最开头，html标签之上，用来告知浏览器该文档使用的规范；</p><h4 id="1-Xhtml的Transitional过渡型规范："><a href="#1-Xhtml的Transitional过渡型规范：" class="headerlink" title="1)Xhtml的Transitional过渡型规范："></a>1)Xhtml的Transitional过渡型规范：</h4><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></p><h4 id="2-Xhtml的Strict严格型规范："><a href="#2-Xhtml的Strict严格型规范：" class="headerlink" title="2)Xhtml的Strict严格型规范："></a>2)Xhtml的Strict严格型规范：</h4><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p><h4 id="3-Xhtml的Frameset框架集定义规范："><a href="#3-Xhtml的Frameset框架集定义规范：" class="headerlink" title="3)Xhtml的Frameset框架集定义规范："></a>3)Xhtml的Frameset框架集定义规范：</h4><h4 id="4-Html4的Transitional过渡型规范："><a href="#4-Html4的Transitional过渡型规范：" class="headerlink" title="4)Html4的Transitional过渡型规范："></a>4)Html4的Transitional过渡型规范：</h4><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p><h4 id="5-Html4的Strict严格型规范："><a href="#5-Html4的Strict严格型规范：" class="headerlink" title="5)Html4的Strict严格型规范："></a>5)Html4的Strict严格型规范：</h4><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></p><h4 id="6-Html4的Frameset框架集定义规范："><a href="#6-Html4的Frameset框架集定义规范：" class="headerlink" title="6)Html4的Frameset框架集定义规范："></a>6)Html4的Frameset框架集定义规范：</h4><p>  <em>☆注：</em>W3C——W3C标准组织，制定了<strong><em>三层分离</em></strong>标准（HTML结构，CSS样式，JavaScript行为）；DTD（Document Type Definition）——文档类型定义。</p><h4 id="7-现在使用HTML5规范："><a href="#7-现在使用HTML5规范：" class="headerlink" title="7)现在使用HTML5规范："></a>7)现在使用HTML5规范：</h4><p>&lt;!DOCTYPE HTML&gt;</p><p><strong><em>★注意：</em></strong>每个页面都必须设置一个DOCTYPE，如果不设置，浏览器会默认开启<strong><em>quirks mode怪异模式</em></strong>解析页面！！！</p><h3 id="3-标签分类："><a href="#3-标签分类：" class="headerlink" title="3.标签分类："></a>3.标签分类：</h3><h4 id="写法分类："><a href="#写法分类：" class="headerlink" title="写法分类："></a>写法分类：</h4><ul><li>单标签（开放标签/自闭合标签）：只有一个开始标签；</li></ul><p><em>☆注：</em>Xhtml规定——单标签必须自己闭合自己，即在末尾加”/“；<br>        Html4中不加”/“；<br>        Html5中都可以，标准中大多不加”/“。</p><ul><li>双标签（闭合标签）：有开始标签和结束结束（名称相同，结束开头加/）；</li></ul><h4 id="关系分类："><a href="#关系分类：" class="headerlink" title="关系分类："></a>关系分类：</h4><ul><li>并列关系：兄弟；</li><li>嵌套关系：父子。</li></ul>]]></content>
    
    <summary type="html">
    
      HTML学习笔记
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>常用快捷键及命令</title>
    <link href="http://yoursite.com/2014/02/16/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2014/02/16/windows常用命令/</id>
    <published>2014-02-16T05:53:27.000Z</published>
    <updated>2018-02-16T10:08:13.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用快捷键及命令"><a href="#常用快捷键及命令" class="headerlink" title="常用快捷键及命令"></a>常用快捷键及命令</h1><hr><h2 id="1-Windows操作系统"><a href="#1-Windows操作系统" class="headerlink" title="1.Windows操作系统"></a>1.Windows操作系统</h2><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><ul><li><p>Ctrl+A—————全选</p></li><li><p>Ctrl+C—————复制</p></li><li><p>Ctrl+V—————粘贴</p></li><li><p>Ctrl+X—————剪切</p></li><li><p>Ctrl+S—————保存</p></li><li><p>Ctrl+Z—————撤销上一个操作</p></li><li><p>Ctrl+Y—————还原上一个操作</p></li><li><p>Alt+Tab————–切换程序（按住Alt）</p></li><li><p>Alt+F4—————退出程序</p></li><li><p>F5———————刷新</p></li><li><p>Ctrl+Alt+Del——–显示安全选项</p></li><li><p>Win+D—————切换到桌面</p></li><li><p>Win+E—————打开资源管理器</p></li><li><p>Win+L—————锁屏</p></li><li><p>Win+R—————打开“运行”窗口，输入CMD打开命令提示符窗口：</p><pre><code>calc：运行计算器mspaint：运行画图notepad：运行记事本</code></pre></li><li><p>Win+数字键——–打开或显示超级任务栏第N个图标代表的程序</p></li><li><p>Win+方向键——–最大化、还原/最小化窗口</p></li></ul><hr><h3 id="CMD命令："><a href="#CMD命令：" class="headerlink" title="CMD命令："></a>CMD命令：</h3><ul><li>calc——————启动计算器</li><li>clipbrd————–剪贴板查看器</li><li>devmgmt.msc—–设备管理器</li><li>explorer————资源管理器</li><li>eudcedit————造字程序</li><li>notepad————打开记事本</li><li>magnify————放大镜实用程序</li><li>mem.exe———–显示内存使用情况</li><li>mspaint————打开画图板</li><li>mstsc—————远程桌面连接</li><li>regedit.exe——–注册表</li><li>write—————–写字板</li></ul>]]></content>
    
    <summary type="html">
    
      记录常用的快捷键及命令
    
    </summary>
    
      <category term="general" scheme="http://yoursite.com/categories/general/"/>
    
    
      <category term="general" scheme="http://yoursite.com/tags/general/"/>
    
  </entry>
  
</feed>
